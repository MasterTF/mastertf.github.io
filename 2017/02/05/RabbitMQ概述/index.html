<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="安装mac上安装rabbitmq比较简单，参考官网教程 http://www.rabbitmq.com/install-standalone-mac.html 即可。遇到了下载很慢问题，找了其他网站上下。 其他系统安装方式在官网也有详细描述，不再累述。">
<meta name="keywords" content="消息队列,RabbitMQ">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ概述">
<meta property="og:url" content="http://yoursite.com/2017/02/05/RabbitMQ概述/index.html">
<meta property="og:site_name" content="Stay Hungry">
<meta property="og:description" content="安装mac上安装rabbitmq比较简单，参考官网教程 http://www.rabbitmq.com/install-standalone-mac.html 即可。遇到了下载很慢问题，找了其他网站上下。 其他系统安装方式在官网也有详细描述，不再累述。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/img/15255306886088.jpg">
<meta property="og:updated_time" content="2021-11-18T15:48:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RabbitMQ概述">
<meta name="twitter:description" content="安装mac上安装rabbitmq比较简单，参考官网教程 http://www.rabbitmq.com/install-standalone-mac.html 即可。遇到了下载很慢问题，找了其他网站上下。 其他系统安装方式在官网也有详细描述，不再累述。">
<meta name="twitter:image" content="http://yoursite.com/img/15255306886088.jpg">

<link rel="canonical" href="http://yoursite.com/2017/02/05/RabbitMQ概述/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RabbitMQ概述 | Stay Hungry</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?dd92700263571bbe9d14e94c4c5fb0c4";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Stay Hungry</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/05/RabbitMQ概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="于大帅">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stay Hungry">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RabbitMQ概述
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-05 22:27:19" itemprop="dateCreated datePublished" datetime="2017-02-05T22:27:19+08:00">2017-02-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-18 23:48:05" itemprop="dateModified" datetime="2021-11-18T23:48:05+08:00">2021-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>mac上安装rabbitmq比较简单，参考官网教程 <a href="http://www.rabbitmq.com/install-standalone-mac.html" target="_blank" rel="noopener">http://www.rabbitmq.com/install-standalone-mac.html</a> 即可。遇到了下载很慢问题，找了其他网站上下。</p>
<p>其他系统安装方式在官网也有详细描述，不再累述。</p>
<a id="more"></a>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li>查找默认配置位置：find / -name “rabbitmq.config.example”，我这边搜索结果是：/usr/share/doc/rabbitmq-server-3.6.1/rabbitmq.config.example</li>
<li>复制默认配置：cp /usr/share/doc/rabbitmq-server-3.6.1/rabbitmq.config.example /etc/rabbitmq/</li>
<li>修改配置文件名：cd /etc/rabbitmq ; mv rabbitmq.config.example rabbitmq.config</li>
<li>开启 Web 界面管理：rabbitmq-plugins enable rabbitmq_management</li>
<li>重启 RabbitMQ 服务：service rabbitmq-server restart</li>
<li>开放防火墙端口：<ul>
<li>sudo iptables -I INPUT -p tcp -m tcp –dport 15672 -j ACCEPT</li>
<li>sudo iptables -I INPUT -p tcp -m tcp –dport 5672 -j ACCEPT</li>
<li>sudo service iptables save</li>
<li>sudo service iptables restart</li>
</ul>
</li>
<li>浏览器访问：<a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a> 默认管理员账号：guest 默认管理员密码：guest</li>
</ol>
<p>参考<a href="https://github.com/judasn/Linux-Tutorial/blob/master/RabbitMQ-Install-And-Settings.md" target="_blank" rel="noopener">https://github.com/judasn/Linux-Tutorial/blob/master/RabbitMQ-Install-And-Settings.md</a></p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>简单来说就是消息队列服务器</p>
<h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>消息交换机，服务器中的实体，用来接收生产者发送的消息并将这些消息路由给服务器中的队列</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>消息队列载体，用来保存消息直到发送给消费者，每个消息都会被投入到一个或多个队列</p>
<h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p>绑定器，它的作用就是把exchange和queue按照路由规则绑定起来</p>
<h3 id="Binding-Key"><a href="#Binding-Key" class="headerlink" title="Binding Key"></a>Binding Key</h3><p>绑定关键字，Exchange视自身类型来决定Binding的路由行为</p>
<h3 id="Routing-Key"><a href="#Routing-Key" class="headerlink" title="Routing Key"></a>Routing Key</h3><p>消息的路由关键字，Exchange根据这个关键字决定如何路由某条消息</p>
<h3 id="vhost"><a href="#vhost" class="headerlink" title="vhost"></a>vhost</h3><p>虚拟主机，一批交换器、消息队列和相关对象，虚拟主机是共享相同的身份认证和加密环境的独立服务器域，一个broker里可以开设多个vhost，用作不同用户的权限分离</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>多路复用连接中的一条独立的双向数据流通道，为会话提供物理传输介质，在客户端的每个连接里，可建立多个channel</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消费者，一个从消息队列中请求消息的客户端应用程序</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>生产者，一个向交换器发布消息的客户端应用程序</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/img/15255306886088.jpg" alt></p>
<ol>
<li>消息生产者将消息发布(Public)到 Exchange 中.</li>
<li>Exchange 根据队列的绑定关系将消息分发到不同的 Queue 中.</li>
<li>AMQP broker 根据订阅规则将消息发送给消费者 或 消费者自行根据需要从消息队列中获取消息.</li>
</ol>
<p>Message是当前模型中所操纵的基本单位，它由Producer产生，经过Broker被Consumer所消费。它的基本结构有两部分: Header和Body。Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。Body是真正需要传送的数据，它是对Broker不可见的二进制数据流，在传输过程中不应该受到影响。</p>
<h2 id="Exchange-和-Exchange-类型"><a href="#Exchange-和-Exchange-类型" class="headerlink" title="Exchange 和 Exchange 类型"></a>Exchange 和 Exchange 类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>默认预定义的名字</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct Exchange</td>
<td>空字符串和 amq.direct</td>
</tr>
<tr>
<td>Fanout Exchange</td>
<td>amq.fanout</td>
</tr>
<tr>
<td>Topic Exchange</td>
<td>amq.topic</td>
</tr>
<tr>
<td>Headers Exchange</td>
<td>amq.match(在 RabbitMQ 中, 额外提供amq.headers)</td>
</tr>
</tbody>
</table>
<h3 id="关于默认-Exchange"><a href="#关于默认-Exchange" class="headerlink" title="关于默认 Exchange"></a>关于默认 Exchange</h3><p>默认的 exchange 是一个由 broker 预创建的匿名的(即名字是空字符串) direct exchagne. 对于简单的程序来说, 默认的 exchange 有一个实用的属性: 如果没有显示地绑定 Exchnge, 那么创建的每个 queue 都会自动绑定到这个默认的 exchagne 中, 并且此时这个 queue 的 route key 就是这个queue 的名字.</p>
<p>例如当我们声明了一个名为 “search-indexing-online” 的 queue, 那么 AMQP broker 会以 “search-indexing-online” 作为 route key 将此 queue 绑定到默认的 exchange 中. 因此当一个消息以 route key 为 “search-indexing-online” 投递到默认的 exchange 中时, 此消息就会被路由到这个 queue 中去. 换句话说, 由于有默认的 exchagne 的存在, 我们就好像可以直接将消息投递到指定的 queue 中去而不需要经过 exchange 一样.</p>
<h2 id="RabbitMQ应用场景"><a href="#RabbitMQ应用场景" class="headerlink" title="RabbitMQ应用场景"></a>RabbitMQ应用场景</h2><p>官网中有很详细的样例，各个语言都有，<a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">http://www.rabbitmq.com/getstarted.html</a> 此处不再说明。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>服务重启时, 是否能恢复队列中的数据.</p>
<p>考虑这样的场景, 当消息被暂存到队列后, 在没有被提取的情况下, RabbitMQ 服务停掉了怎么办.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'hello'</span>)</span><br><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>, routing_key=<span class="string">''</span>, body=<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码, 我们创建了一条内容为 Hello World! 的消息, 通过命令行工具:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>  ./rabbitmqctl list_queues</span><br><span class="line">Listing queues ...</span><br><span class="line">hello    1</span><br><span class="line">...done.</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ./rabbitmqctl list_exchanges</span><br><span class="line">Listing exchanges ...</span><br><span class="line">    direct</span><br><span class="line">amq.direct    direct</span><br><span class="line">amq.fanout    fanout</span><br><span class="line">amq.headers    headers</span><br><span class="line">amq.match    headers</span><br><span class="line">amq.rabbitmq.log    topic</span><br><span class="line">amq.rabbitmq.trace    topic</span><br><span class="line">amq.topic    topic</span><br><span class="line">first    fanout</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure>
<p>可以查到, 在名为 hello 的队列中, 有 1 条消息. 有一个类型为 fanout , 名为 first 的交换器.</p>
<p>此时通过 Ctrl-C 或 ./rabbitmqctl stop 把 RabbitMQ 服务停掉, 再重启. 交换器, 队列, 消息都是不会恢复的.</p>
<p>所以, 默认情况下, <strong>消息</strong>, <strong>队列</strong>, <strong>交换器</strong> 都不具有持久化的性质. 如果我们需要持久化功能, 那么在声明的时候就需要配置好.</p>
<p>交换器和队列的持久化性质, 在声明时通过一个 durable 参数即可实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'fanout'</span>, durable=<span class="literal">True</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>, durable=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这样, 在服务重启之后, first 和 hello 都会恢复. 但是 hello 中的消息不会, 还需要额外配置. 这是 <strong>消息</strong> 的属性的相关内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                      routing_key=<span class="string">''</span>,</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                         delivery_mode = <span class="number">2</span>,<span class="comment"># make message persistent</span></span><br><span class="line">                      ))</span><br></pre></td></tr></table></figure>
<p>这里注意一下, 消息的持久化并不是一个很强的约束, 涉及数据落地的时机, 及系统层面的 <strong>fsync</strong> 等问题, 不要认为消息完全不会丢. 如果要尽可能高地提高消息的持久化的有效性, 还需要配置其它的一些机制, 比如后面会谈到的 <strong>状态反馈</strong> 中的 <strong>confirm mode</strong>.</p>
<p><strong>交换器 , 队列, 消息</strong> 这三者的持久化问题都介绍过了. 前两者是一经声明, 则其性质无法再被更改, 即你不能先声明一个非持久化的队列, 再声明一个持久化的同名队列, 企图修改它, 这是不行的. 你重复声明时, 相关参数需要一致. 当然, 你可以删除它们再重新声明:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_delete(queue=<span class="string">'hello'</span>)</span><br><span class="line">channel.exchange_delete(exchange=<span class="string">'first'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><p>交换器如何把消息给到哪些队列, 是每个队列给一条, 或者把一条消息给多个队列.</p>
<p>我们考虑交换器 Exchange 和队列 Queue 的关系. Exchange 在得到消息后会依据规则把消息投到一个或多个队列当中.</p>
<p>在调度策略方面, 有两个需要了解的地方, 一是交换器的类型(前面我们用的是 fanout), 二是交换器和队列的绑定关系. 在绑定了的前提下, 我们再谈不同类型的交换器的规则. 绑定动作本身也会影响交换器的行为.</p>
<p>交换器的类型, 内置的有四种, 分别是:</p>
<ul>
<li>fanout</li>
<li>direct</li>
<li>topic</li>
<li>headers</li>
</ul>
<p>下面一一介绍.</p>
<h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><p>故名思义, fanout 类型的交换器, 其行为是把消息转发给所有绑定的队列上, 就是一个”广播”行为.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;first&apos;, type=&apos;fanout&apos;)</span><br><span class="line">channel.queue_declare(queue=&apos;A&apos;)</span><br><span class="line">channel.queue_declare(queue=&apos;B&apos;)</span><br><span class="line">channel.queue_declare(queue=&apos;C&apos;)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=&apos;first&apos;, queue=&apos;A&apos;)</span><br><span class="line">channel.queue_bind(exchange=&apos;first&apos;, queue=&apos;B&apos;)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=&apos;first&apos;,</span><br><span class="line">                      routing_key=&apos;&apos;,</span><br><span class="line">                      body=&apos;Hello World!&apos;)</span><br></pre></td></tr></table></figure>
<p>运行 N 次, 通过 rabbitmqctl 可以看到 A 和 B 中就有 N 条消息, 而 C 中没有消息. 因为只有 A 和 B 是绑定到了 first 上的.</p>
<h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p>direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 routing_key , 消息的 routing_key 匹配时, 才会被交换器投送到绑定的队列中去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'direct'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'B'</span>)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'A'</span>, routing_key=<span class="string">'a'</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'B'</span>, routing_key=<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                      routing_key=<span class="string">'a'</span>,</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>A 和 B 虽然都绑定在了类型为 direct 的 first 上, 但是绑定时的 routing_key 不同.</p>
<p>当一个 routing_key 为 a 的消息出来时, 只会被 first 投送到 A 里.</p>
<h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><p>topic 和 direct 类似, 只是匹配上支持了”模式”, 在”点分”的 routing_key 形式中, 可以使用两个通配符:</p>
<ul>
<li>* 表示一个词.</li>
<li># 表示零个或多个词.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'topic'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'B'</span>)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'A'</span>, routing_key=<span class="string">'a.*.*'</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'B'</span>, routing_key=<span class="string">'a.#'</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                      routing_key=<span class="string">'a'</span>,</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                      routing_key=<span class="string">'a.b.c'</span>,</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>在发出的两条消息当中, a 只会被 a.# 匹配到. 而 a.b.c 会被两个都匹配到.</p>
<p>所以, 最终的结果会是 A 中有一条消息, B 中有两条消息.</p>
<h3 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h3><p>headers 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型.</p>
<p>在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'headers'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'B'</span>)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'A'</span>, arguments=&#123;<span class="string">'a'</span>: <span class="string">'1'</span>&#125;)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'B'</span>, arguments=&#123;<span class="string">'b'</span>: <span class="string">'2'</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'x-match'</span>: <span class="string">'all'</span>&#125;)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                      routing_key=<span class="string">''</span>,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                          headers = &#123;<span class="string">'a'</span>: <span class="string">'2'</span>&#125;,</span><br><span class="line">                      ),</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                      routing_key=<span class="string">''</span>,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                          headers = &#123;<span class="string">'a'</span>: <span class="string">'1'</span>, <span class="string">'b'</span>: <span class="string">'2'</span>&#125;,</span><br><span class="line">                      ),</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>绑定时, 通过 arguments 参数设定匹配规则, x-match 是一个特殊的规则, 表示需要全部匹配上, 还是只匹配一条:</p>
<ul>
<li>all , 全部匹配.</li>
<li>any , 只匹配一个.</li>
</ul>
<p>消息的 headers 属性会用于规则的匹配.</p>
<p>上面的代码中, 第一条消息不会匹配任何规则. 第二条消息, 匹配到 A , 但是不会匹配到 B (虽然有一条 b:2 ).</p>
<p>最终的结果是, A 中有一条消息, B 中没有消息.</p>
<h2 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h2><p>队列面对消费者时, 如何把消息吐出去, 来一个消费者就把消息全给它, 还是只给一条.</p>
<p>调度策略是影响 Exchange 是不是要把消息给 Queue , 而分配策略影响队列如何把消息给 Consuming .</p>
<p>考虑这样的场景: 队列中有多条消息, 每一个消费者取出消息后, 都要花 10 秒来处理它, 处理完一条消息之后才可能再取出一条继续处理. 刚开始只有一个消费者, 过了 2 秒后来了第二个消费者, 此时, 这两个消费者获取消息的行为是一个什么状态?</p>
<p>我们的需求可能是, 当一个消费者来时, 只给它一条消息, 等它再”请求”时, 再给. 或者也可能是, 当有消费者时, 就把目前有的消息全给它(因为不知道是否还有其它的消费者, 所以既然来了一个就让它尽量多处理一些消息).</p>
<p>先产生一些等待处理的消息:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                          routing_key=<span class="string">''</span>,</span><br><span class="line">                          body=str(i))</span><br></pre></td></tr></table></figure>
<p>然后是消费者的实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">print</span> body</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=<span class="string">'A'</span>, no_ack=<span class="literal">True</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<p>上面的代码, 是假设处理一条消息需要 10 秒的时间. 但是事实上, 你只要一执行代码, 马上再使用 rabbitmqctl 查看队列状态时, 会发现队列已经空了. 因为在关闭 ack 的情况下, Queue 的行为是, 一旦有消费者请求, 那么当前队列中的消息它都会一次性吐很多出去.</p>
<p>ack 机制在后面 状态反馈 会介绍到, 简单来说是一种确认消息被正确处理的机制.</p>
<p>如果我们想一次只吐一条消息, 当其它消费者连上来时, 还可以并行处理, 简单地把 ack 打开就可以了(默认就是打开的).</p>
<p>再考虑一下细节. 当有多个消费者连上时, 它是从队列一次取一条消息, 还是一次取多条消息(这样至少可以改善性能). 这可以通过配置 channel 的 qos 相关参数实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-importpika</span></span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line">channel.basic_qos(prefetch_count=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">defcallback(ch, method, properties, body):</span><br><span class="line">    importtime</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">print</span> body</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<p>通过配置 prefetch_count 参数, 来设置一次从队列中取多少条消息. 要看到效果, 至少需要启 2 个消费者.</p>
<p>之前是 10 个数字按顺序入了队列, channel 的配置是一次取 2 个, 那么启 2 个消费者的话, 过 10 秒, 在两个消费者的输出中分别能看到 0 , 2 . 这时把两个消费者都 Ctrl-C , 通过 rabbitmqctl 能看到 A 队列中还有 8 条消息.</p>
<h2 id="状态反馈"><a href="#状态反馈" class="headerlink" title="状态反馈"></a>状态反馈</h2><p>当消息从某一个队列中被提出后, 这个消息的生命周期就此结束, 还是说需要一个具体的信号以明确标识消息已被正确处理.</p>
<p>状态反馈 的功能目的是为了确认行为的结果. 比如, 当你向 Exchange 提交一个消息时, 这个消息是否提交成功, 是否送达到了队列中. 当你从队列中提取消息之后, RabbitMQ 的 Server 如何处理, 因为在提取消息之后, Consuming 可能判断消息有问题, 可能在处理的过程中出现了异常.</p>
<p>在一些关键的节点上, 要保证消息的正确处理, 安全处理, 是需要很多细节上的控制的. AMQP 协议本身也为此作了相关设计, 甚至是事务机制. 事实上在 AMQP 中要确保消息的业务可靠性只能使用事务, 不过在 RabbitMQ 中有一些相应的简便的扩展机制来达到同样目的.</p>
<h3 id="信息发布的确认"><a href="#信息发布的确认" class="headerlink" title="信息发布的确认"></a>信息发布的确认</h3><p>回看一下之前的一段代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>, routing_key=<span class="string">''</span>, body=<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码要做的事, 是把一条消息发给名为 first 的交换器. 这个过程中可能出现意外:</p>
<ul>
<li>exchange 的名字写错了.</li>
<li>exchange 得到消息后, 发现没有对应的 queue 可以投送.</li>
<li>投送到 queue 后当前没有消费者来提取它.</li>
</ul>
<p>上面的三种情况, 第一种, 会直接引发一个调用错误. 第三种, 通常不是问题, 反正消息会在 queue 中暂存. 但是第二种情况很多时候是需要避免的, 否则消息就丢失了, 更严重的是 Producing 对此浑然不知.</p>
<p>在这个地方, 我们就需要确认消息发出之后, 是否成功地被投送到 queue 中去了(或者知道它不能被投送到任何 queue 中去).</p>
<p>要确认这些状态信息, 首先需要把 channel 设置到 confirm mode , 也称之为 Publisher Acknowledgements 机制 (和消息的 ack 机制区分开). 它的目的就是为了确认 Producing 发出的信息的状态.</p>
<p>打开 confirm mode 的方法是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.confirm_delivery()</span><br></pre></td></tr></table></figure>
<p>之后的 publish 行为就可以收到服务器的反馈. 比如在 basic_publish 函数中, 通过 mandatory=True 参数来确认发出的消息是否有 queue 接收, 并且所有 queue 都成功接收.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#channel.queue_bind(exchange='first', queue='A')</span></span><br><span class="line"></span><br><span class="line">channel.confirm_delivery()</span><br><span class="line"></span><br><span class="line">r = channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                          routing_key=<span class="string">''</span>,</span><br><span class="line">                          body=<span class="string">'Hello'</span>,</span><br><span class="line">                          mandatory=<span class="literal">True</span>,</span><br><span class="line">                         )</span><br><span class="line"><span class="keyword">print</span> r</span><br></pre></td></tr></table></figure>
<p>上面的代码中, 因为名为 first 的 Exchange 没有绑定任何的 queue , 在 mandatory 参数的作用下, basic_publish 会返回 False .</p>
<p>对于持久化性质, confirm mode 的确认结果是表示, 一条 persisting 的消息, 投送给一个 durable 的队列成功, 并且数据已经成功写到磁盘. 当然, 因为系统缓存的问题, 为确保数据成功落地, 得到确认信息有时可能需要长达几百毫秒的时间, 应用对此应该有所准备, 而不至于在性能上受此影响.</p>
<h3 id="消息提取的确认"><a href="#消息提取的确认" class="headerlink" title="消息提取的确认"></a>消息提取的确认</h3><p>在未关闭消息的 ack 机制的情况下, 当消息被 Consuming 从队列中提取后, 在未明确获取确认信息之前, 队列中的消息是不会被删除的. 这样, 流程上就变成, 当消息被提取之后, 队列中的这条消息处于”等待确认”的状态. 如果 Consuming 反馈”成功”给队列, 则消息可以安全地被删除了. 如果反馈”拒绝”给队列, 则消息可能还需要再次被其它 Consuming 提取.</p>
<p>看下面的例子, 我们先创建顺序的 10 个数字为内容的 10 条消息:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">'first'</span>, routing_key=<span class="string">''</span>, body=str(i))</span><br></pre></td></tr></table></figure>
<p>提取消息的逻辑:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">r = channel.basic_get(queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>) <span class="comment">#0</span></span><br><span class="line"><span class="keyword">print</span> r[<span class="number">-1</span>], r[<span class="number">0</span>].delivery_tag</span><br></pre></td></tr></table></figure>
<p>上面的代码会提取第一条消息, 但是并没有向 Queue 反馈此消息是否被正确处理, 所以这条消息在队列中仍然存在, 直到 Connection 被释放后, 被提取过但是未被确认的消息的状态被重置, 它就可以被重新提取.</p>
<p>要确认消息, 或者拒绝消息, 使用对应的 basic_ack 和 baskc_reject 方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">r = channel.basic_get(queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>) <span class="comment">#0</span></span><br><span class="line"><span class="keyword">print</span> r[<span class="number">-1</span>], r[<span class="number">0</span>].delivery_tag</span><br><span class="line"><span class="comment">#channel.basic_ack(delivery_tag=r[0].delivery_tag)</span></span><br><span class="line">channel.basic_reject(delivery_tag=r[<span class="number">0</span>].delivery_tag)</span><br></pre></td></tr></table></figure>
<p>AMQP 协议中, 只提供了 reject 方法, 它只能处理一条消息. 因为 Consuming 是可以一次性提取多条消息的, 所以 RabbitMQ 为此做了扩展, 提供了 basic_nack 方法, 它和 basic_reject 的唯一区别就是支持一次性拒绝多条消息.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">r = channel.basic_get(queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>) <span class="comment">#0</span></span><br><span class="line">r = channel.basic_get(queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>) <span class="comment">#1</span></span><br><span class="line">r = channel.basic_get(queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>) <span class="comment">#2</span></span><br><span class="line">channel.basic_nack(delivery_tag=r[<span class="number">0</span>].delivery_tag, multiple=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>delivery_tag 是在 channel 中的一个消息计数, 每次消息提取行为都对应一个数字. nack 的 multiple 机制会自动把不大于指定 delivery_tag 的消息提取都 reject 掉.</p>
<p>在 reject 和 nack 中还有一个 requeue 参数, 表示被拒绝的消息是否可以被重新分配. 默认是 True . 如果消息被 reject 之后, 不希望再被其它的 Consuming 得到, 可以把 requeue 参数设置成 False :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">r = channel.basic_get(queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>) <span class="comment">#0</span></span><br><span class="line">channel.basic_nack(delivery_tag=r[<span class="number">0</span>].delivery_tag, multiple=<span class="literal">False</span>, requeue=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>basic_consume 和 basic_get 都是从指定 queue 中提取消息, 前者是一个更高层的方法, 还支持 qos 等.</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>打钱! 打钱! 打钱😡😡😡</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat_pay.jpeg" alt="于大帅 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/消息队列/" rel="tag"><i class="fa fa-tag"></i> 消息队列</a>
              <a href="/tags/RabbitMQ/" rel="tag"><i class="fa fa-tag"></i> RabbitMQ</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/11/23/spring事务管理/" rel="prev" title="spring事务管理">
      <i class="fa fa-chevron-left"></i> spring事务管理
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/03/29/ZSH-安装/" rel="next" title="ZSH 安装">
      ZSH 安装 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装"><span class="nav-number">1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置"><span class="nav-number">2.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心概念"><span class="nav-number">3.</span> <span class="nav-text">核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Broker"><span class="nav-number">3.1.</span> <span class="nav-text">Broker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchange"><span class="nav-number">3.2.</span> <span class="nav-text">Exchange</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue"><span class="nav-number">3.3.</span> <span class="nav-text">Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binding"><span class="nav-number">3.4.</span> <span class="nav-text">Binding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binding-Key"><span class="nav-number">3.5.</span> <span class="nav-text">Binding Key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Routing-Key"><span class="nav-number">3.6.</span> <span class="nav-text">Routing Key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vhost"><span class="nav-number">3.7.</span> <span class="nav-text">vhost</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel"><span class="nav-number">3.8.</span> <span class="nav-text">Channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumer"><span class="nav-number">3.9.</span> <span class="nav-text">Consumer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Producer"><span class="nav-number">3.10.</span> <span class="nav-text">Producer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作流程"><span class="nav-number">4.</span> <span class="nav-text">工作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exchange-和-Exchange-类型"><span class="nav-number">5.</span> <span class="nav-text">Exchange 和 Exchange 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于默认-Exchange"><span class="nav-number">5.1.</span> <span class="nav-text">关于默认 Exchange</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ应用场景"><span class="nav-number">6.</span> <span class="nav-text">RabbitMQ应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#持久化"><span class="nav-number">7.</span> <span class="nav-text">持久化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度策略"><span class="nav-number">8.</span> <span class="nav-text">调度策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fanout"><span class="nav-number">8.1.</span> <span class="nav-text">fanout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#direct"><span class="nav-number">8.2.</span> <span class="nav-text">direct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#topic"><span class="nav-number">8.3.</span> <span class="nav-text">topic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#headers"><span class="nav-number">8.4.</span> <span class="nav-text">headers</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分配策略"><span class="nav-number">9.</span> <span class="nav-text">分配策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态反馈"><span class="nav-number">10.</span> <span class="nav-text">状态反馈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#信息发布的确认"><span class="nav-number">10.1.</span> <span class="nav-text">信息发布的确认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息提取的确认"><span class="nav-number">10.2.</span> <span class="nav-text">消息提取的确认</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="于大帅"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">于大帅</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">于大帅</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
