<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式初学者指南</title>
    <url>/2022/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9D%E5%AD%A6%E8%80%85%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><ul>
<li><strong>为了真正有效地应用设计模式，必须知道如何设计以及设计的过程。不要期望简单地在代码中即兴使用设计模式就会得到好的代码，这样做不会使程序得到太大改进，甚至可能让程序变得更糟。</strong></li>
<li>编码是最后一步，是设计的实现。</li>
<li>既然代码是设计的实现，想得到优雅代码需要有好的设计，得到好的设计需要有好的分析，过程为：用例 -&gt; 分析 -&gt; 设计 -&gt; 代码。</li>
</ul>
<a id="more"></a>
<h2 id="面向对象与设计模式"><a href="#面向对象与设计模式" class="headerlink" title="面向对象与设计模式"></a>面向对象与设计模式</h2><h3 id="究竟什么是设计模式"><a href="#究竟什么是设计模式" class="headerlink" title="究竟什么是设计模式"></a>究竟什么是设计模式</h3><ol>
<li>设计模式是被发现而不是被发明出来的。</li>
<li>设计模式使用来解决一类相关问题的通用技术，而不是及决问题的特解。解决具体问题时仍要具体问题具体分析。</li>
<li>每种设计模式不是“固定”的：每种模式描述了所处理的问题和对应的解决方法(“四人帮”书中成为“意图”(intent))。比如想设计一个通风的房子，总结出一个“穿堂风”模式，其意图为“允许空气在半人搞得高度直接水平地穿过房间，从而减少闷热并使房间更加舒适”。<strong>任何符合“意图”的架构机制都是该模式合法的具体化(reification)。</strong></li>
<li>不能简单地通过结构(UML图)来识别模式，要弄清对象和类的意图。</li>
</ol>
<h3 id="模式的分类"><a href="#模式的分类" class="headerlink" title="模式的分类"></a>模式的分类</h3><p><img src="/img/image-20230119171459687.png" alt="image-20230119171459687"></p>
<p>“四人帮”将模式分为两大类：类模式(class pattern)和对象模式(object pattern).</p>
<p>在每个大类内部，模式进一步被分为三类：</p>
<ul>
<li>创建型模式：关注的都是对象的创建，如抽象工厂模式提供了一种可以在不知道对象的实际类型的情况下生成对象。</li>
<li>结构型模式：都是静态模型模式，关注与程序的机构化组织方式。</li>
<li>行为型模式：都是动态型模式，关注与各个对象在运行时如何交互。</li>
</ul>
<h3 id="模式与设计"><a href="#模式与设计" class="headerlink" title="模式与设计"></a>模式与设计</h3><p>OOD(面向对象设计)与OOP(面向对象编程)有很大不同，很多人将编程和设计混淆了。</p>
<p>拿建筑行业做一个类比：建筑是由建筑师“设计”出来的，但却是由工人“建造”的。同样，面向对象系统是由面向对象设计人员设计、由面向对象程序员实现的。这两个角色可以由同一人充当，也可以由不同人充当。</p>
<p>优秀的编码者可以不懂设计，但可以将设计人员的设计方案转换为漂亮的代码。在华为，有专门的的SE做方案设计，然后由编码者进行实现。</p>
<p>不要将易于维护和降低复杂性混淆。面向对象的系统通常比面向过程的系统更加复杂，但更易于维护：其思想是将实际的软件系统内的必然的复杂性组织起来，而不是减少其复杂性——对于减少复杂性这一目标，面向对象设计人员认为是不可能达到的。</p>
<ul>
<li><p>编码是最后一步，是设计的实现。</p>
</li>
<li><p>既然代码是设计的实现，想得到优雅代码需要有好的设计，得到好的设计需要有好的分析，过程为：用例 -&gt; 分析 -&gt; 设计 -&gt; 代码。</p>
</li>
<li><p><strong>为了真正有效地应用设计模式，必须知道如何设计以及设计的过程。不要期望简单地在代码中即兴使用设计模式就会得到好的代码，这样做不会使程序得到太大改进，甚至可能让程序变得更糟。</strong></p>
</li>
<li><p>本篇讲的是模式，是关于将面向对象设计转变为具体的实现，关于OOAD自行学习。</p>
</li>
</ul>
<h2 id="使用接口和创建型模式编程"><a href="#使用接口和创建型模式编程" class="headerlink" title="使用接口和创建型模式编程"></a>使用接口和创建型模式编程</h2><h3 id="为什么组合优于继承"><a href="#为什么组合优于继承" class="headerlink" title="为什么组合优于继承"></a>为什么组合优于继承</h3><p>经常说 “组合由于继承”，这是为什么呢？工作中是如何实践的？有意识到遵循这项原则吗？</p>
<h3 id="extends的问题"><a href="#extends的问题" class="headerlink" title="extends的问题"></a>extends的问题</h3><ul>
<li>强耦合</li>
<li>脆弱的基类问题：用一种表面上安全的方式修改基类，但修改后，可能会导致派生类不能正常运行。</li>
</ul>
<h4 id="强耦合"><a href="#强耦合" class="headerlink" title="强耦合"></a>强耦合</h4><p>例子：通过继承ArrayList实现栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> <span class="keyword">extends</span> <span class="title">ArrayList</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> topOfStack = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">( Object article )</span> </span>&#123;   </span><br><span class="line">    add( topOfStack++, article );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> remove( --topOfStack ); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushMany</span><span class="params">( Object[] articles )</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; articles.length; ++i )</span><br><span class="line">         push( articles[i] );</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好像没什么问题，考虑以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack aStack = <span class="keyword">new</span> Stack(); </span><br><span class="line">aStack.push(<span class="string">"1"</span>); </span><br><span class="line">aStack.push(<span class="string">"2"</span>); </span><br><span class="line">aStack.clear();</span><br></pre></td></tr></table></figure>
<p>调用clear方法时没有重置 topOfStack，导致下次调用push方法会存放到ArrayList的第三个位置，与预期不一致。</p>
<p>有人可能想到重写clear方法，调用stack的clear方法时直接抛出异常。这种做法并不好：</p>
<ul>
<li>stack也是ArrayList，其他以ArrayList作为参数的方法，调用clear方法时不会期望得到异常</li>
<li>将编译期的错误转移到了运行时。</li>
<li>从概念上来看，stack不是ArrayList：ArrayList提供的方法对于Stack 来说大部分都不需要，这些方法对Stack是无意义的。</li>
</ul>
<p>设计Stack类更好的方法是使用封装而不是派生来进行设计，这样讲就无需担心不想要的方法会被继承下来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> topOfStack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> ArrayList theData = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">( Object article )</span> </span>&#123; </span><br><span class="line">        theData.add( topOfStack++, article ); </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> theData.remove( --topOfStack ); </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushMany</span><span class="params">( Object[] articles )</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; articles.length; ++i )</span><br><span class="line">            push( articles[i] );</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="comment">// current stack size. </span></span><br><span class="line">        <span class="keyword">return</span> theData.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="错弱的基类问题"><a href="#错弱的基类问题" class="headerlink" title="错弱的基类问题"></a>错弱的基类问题</h4><p>假设想丰富stack的能力，希望能跟踪一段时间内栈最大值和最小值。</p>
<p>通过增加“高水位”和“低水位”标记的方法实现该功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorableStack</span> <span class="keyword">extends</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> highWaterMark = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lowWaterMark = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">( Object o )</span> </span>&#123;   </span><br><span class="line">        push(o);</span><br><span class="line">        <span class="keyword">if</span>( size() &gt; highWaterMark ) </span><br><span class="line">            highWaterMark = size();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Object poppedItem = pop(); </span><br><span class="line">        <span class="keyword">if</span>( size() &lt; lowWaterMark )</span><br><span class="line">            lowWaterMark = size(); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> poppedItem;	</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> highWaterMark; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lowWaterMark; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetMarks</span> <span class="params">()</span> </span>&#123; highWaterMark = lowWaterMark = size(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去是正常的。该类没有重写pashMany()方法，pushMany方法是通过push()方法来工作。</p>
<p>调用了push()，highWaterMark才会变更。</p>
<p>某天，某人发现基类stack性能有问题，为提高性能，使用数组替换ArrayList：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> topOfStack = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] theData = <span class="keyword">new</span> Object[<span class="number">1000</span>];</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">( Object article )</span> </span>&#123; </span><br><span class="line">        theData[ ++topOfStack ] = article; </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Object popped = theData[ topOfStack-- ];</span><br><span class="line">        theData[topOfStack] = <span class="keyword">null</span>; <span class="comment">// prevent memory leak</span></span><br><span class="line">        <span class="keyword">return</span> popped;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushMany</span><span class="params">( Object[] articles )</span> </span>&#123; </span><br><span class="line">        <span class="keyword">assert</span> (topOfStack + articles.length) &lt; theData.length;</span><br><span class="line">        System.arraycopy(articles, <span class="number">0</span>, theData, topOfStack+<span class="number">1</span>, articles.length);</span><br><span class="line">        topOfStack += articles.length; </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  <span class="comment">// current stack size.</span></span><br><span class="line">        <span class="keyword">return</span> topOfStack + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意新的pushMany()不再多次调用push()。导致子类MonitorableStack再也不能正常工作。</strong></p>
<hr>
<p><strong>不仅修改已有的方法可能导致问题，在基类添加方法也可能有问题：</strong></p>
<p>假设要提供批量清空栈的能力，但不希望通过显示地弹出栈中每一个元素来完成，于是在stack中加入以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discardAll</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  stack = <span class="keyword">new</span> Object[<span class="number">1000</span>];</span><br><span class="line">  topOfStack = -<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>似乎安全且合理。但discardAll()没有调用pop()方法，导致<strong>MonitorableStack</strong>虽然清空了，但高水位和低水位没有被更新。</p>
<hr>
<p>所以，每次修改基类时，为避免发生错误，<strong>需要子类重写每个方法</strong>。</p>
<p><strong>当重写所有方法时，实际上就不是继承，而是实现接口。</strong></p>
<h4 id="使用接口减少脆弱基类问题"><a href="#使用接口减少脆弱基类问题" class="headerlink" title="使用接口减少脆弱基类问题"></a>使用接口减少脆弱基类问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">push</span><span class="params">( Object o )</span></span>;</span><br><span class="line">    <span class="function">Object  <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">pushMany</span><span class="params">( Object[] articles )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleStack</span> <span class="keyword">implements</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>       topOfStack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> ArrayList theData    = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">( Object article )</span></span>&#123; </span><br><span class="line">        theData.add( topOfStack++, article );</span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> theData.remove( --topOfStack );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushMany</span><span class="params">( Object[] articles )</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; articles.length; ++i )</span><br><span class="line">            push( articles[i] );</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="comment">// current stack size. </span></span><br><span class="line">        <span class="keyword">return</span> theData.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorableStack</span> <span class="keyword">implements</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> highWaterMark = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lowWaterMark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    SimpleStack stack = <span class="keyword">new</span> SimpleStack();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">( Object o )</span> </span>&#123;   </span><br><span class="line">        stack.push(o);</span><br><span class="line">        <span class="keyword">if</span>( size() &gt; highWaterMark ) </span><br><span class="line">            highWaterMark = size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object returnValue = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>( stack.size() &lt; lowWaterMark )</span><br><span class="line">            lowWaterMark = stack.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushMany</span><span class="params">( Object[] articles )</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; articles.length; ++i )</span><br><span class="line">            push( articles[i] );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( stack.size() &gt; highWaterMark )</span><br><span class="line">            highWaterMark = stack.size();</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">maximumSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> highWaterMark; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">minimumSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lowWaterMark;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetMarks</span> <span class="params">()</span> </span>&#123; highWaterMark = lowWaterMark = size(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">size</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> stack.size(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何替换extends"><a href="#如何替换extends" class="headerlink" title="如何替换extends"></a>如何替换extends</h3><h4 id="优先使用组合"><a href="#优先使用组合" class="headerlink" title="优先使用组合"></a>优先使用组合</h4><p>总是能通过实现接口而不用extends就能得到继承。其做法是将默认实现放在接口中，并在接口中定义方法来访问所包含的默认实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Implementation</span> <span class="keyword">implements</span> <span class="title">Base</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Effectively extend both Something and Base.Implementation:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Something</span> <span class="keyword">implements</span> <span class="title">Base</span> </span>&#123;   </span><br><span class="line">    Base delegate = <span class="keyword">new</span> Base.Implementation();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        delegate.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用创建型模式"><a href="#使用创建型模式" class="headerlink" title="使用创建型模式"></a>使用创建型模式</h4><p>进行重构时，将extend改为接口，原来new某个类的地方都要改为new 某个接口，需要进行大量的修改。</p>
<p>最好将new抛弃或者隐藏。</p>
<h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p>抽象工厂有不同的变种，如工厂是具体的。但都有一个共同主题：<strong>使用工厂来创建确切类型尚不知道的对象。</strong></p>
<p>只知道创建的对象实现的接口，但并不知道对象具体的类。</p>
<p>Java中的collection是抽象工厂的优秀例子：工厂和产品都是抽象的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client</span><span class="params">(Collection c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Iterator i = c.iterator(); c.hasNext();)&#123;</span><br><span class="line">        doSth(i.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>抽象工厂的主要优点是 隔离创建对象的过程，严格按照接口编程。</strong></p>
<h4 id="命令和策略模式"><a href="#命令和策略模式" class="headerlink" title="命令和策略模式"></a>命令和策略模式</h4><p>策略模式也能以抽象的方式创建对象，策略模式是命令模式的特例。</p>
<p><strong>命令模式的基本思想是将如何作模式的知识封装在对象中，进而可以将其到处传送。</strong>如Java中创建线程的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommandObject</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="comment">// stuff to do on the thread goes here &#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Thread controller = <span class="keyword">new</span> Thread( <span class="keyword">new</span> CommandObject() ); </span><br><span class="line">    controller.start(); <span class="comment">//fire up the thread</span></span><br></pre></td></tr></table></figure>
<p>Commond对象封装了线程中要运行的代码。Thread对象完全是通用的，只负责创建及管理线程，单不需要负责线程会做什么事情。</p>
<p><strong>命令模式的主要特性是 客户类（使用命令对象的类）不知道命令对象将会做什么事情。</strong></p>
<p><strong>策略模式思想也很简单：</strong>使用命令对象来定义<strong>某些操作</strong>的策略，并在运行时<strong>传递给其他对象</strong></p>
<p>在实践中，大部分代码只是给类起名叫XXXStrategy，直接实例化类并调用方法，并没有传递。</p>
<p>Java中使用策略模式的优秀例子是java.awt.Container及其派生类使用的LayoutManager。可以向Container添加可视化对象(按钮等)，Container通过委派策略对象来处理布局。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Frame container = <span class="keyword">new</span> Frame();</span><br><span class="line"><span class="comment">// 添加四个按钮并排布局</span></span><br><span class="line">container.setLayout( <span class="keyword">new</span> FlowLayout() );</span><br><span class="line">container.add( <span class="keyword">new</span> Button(<span class="string">"1"</span>) ); </span><br><span class="line">container.add( <span class="keyword">new</span> Button(<span class="string">"2"</span>) ); </span><br><span class="line">container.add( <span class="keyword">new</span> Button(<span class="string">"3"</span>) ); </span><br><span class="line">container.add( <span class="keyword">new</span> Button(<span class="string">"3"</span>) );</span><br><span class="line"></span><br><span class="line">Frame container = <span class="keyword">new</span> Frame();</span><br><span class="line"><span class="comment">// 添加四个按钮，2*2的方式布局</span></span><br><span class="line">container.setLayout( <span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">2</span>) );</span><br><span class="line">container.add( <span class="keyword">new</span> Button(<span class="string">"1"</span>) ); </span><br><span class="line">container.add( <span class="keyword">new</span> Button(<span class="string">"2"</span>) ); </span><br><span class="line">container.add( <span class="keyword">new</span> Button(<span class="string">"3"</span>) ); </span><br><span class="line">container.add( <span class="keyword">new</span> Button(<span class="string">"3"</span>) );</span><br></pre></td></tr></table></figure>
<p>如果使用继承方式，则必须写两个子类，一个叫FlowFrame,完成流式风格的布局，还要写一个GridFrame，完成网格风格的布局。</p>
<p>而使用LayoutManager策略对象(实现了LayoutManager接口但不继承任何类)免除了使用继承，并简化实现。</p>
<p><strong>策略模式是工厂方法的很好替代品，使用策略模式就不需要使用继承对创建对象的方法进行重写.</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>为了在需求变化时能够容易的对程序进行修改，代码中超过80%的内容应该通过接口来编写而不是具体的类。</p>
<p>以下几种模式可以做到只知道接口而不知道实际类来创建对象：</p>
<ol>
<li>单例：一个对象，一种类型只有一个</li>
<li>抽象工厂：一个“工厂”，由其创建一组相关对象。仅知道对象的接口，但具体的类是隐藏(外部看不到，内部可以看到，因为总要在工厂里创建具体的对象)。</li>
<li>模板方法：一个占位方法，位于基类层次中，在派生类中被重写(不推荐，有脆弱的基类问题)。要有节制的使用。另外模板方法只是多态的普通应用，不配叫“模式”。</li>
<li>工厂方法：一种模板方法，在具体类 未知的情况下创建对象。工厂方法的名字容易造造成误解，认为任何创建对象的方法都是工厂方法，但还有其他创建型的方法。与抽象工厂的区别在于工厂是具体的。</li>
<li>命令：一个对象，封装了一个未知的算法。</li>
<li>策略：一个对象，封装了解决已知问题的策略。在创建型模式的上下文中，可以向创建者传递一个工厂对象，工厂中封装了实例化其他对象的策略。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>软件开发复杂性</title>
    <url>/2022/06/20/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%A4%8D%E6%9D%82%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>软件的复杂性是一个基本特征，而不是偶然如此。从根本上来说，我们可以掌握这种复杂性，但不能消除这种复杂性。</p>
</blockquote>
<ul>
<li>对公司来讲，做业务要有利润。利润=收入-成本。在软件开发中，需求解决【提升收入】的问题，设计解决【降低成本】的问题。公式可以改为【利润=需求-设计】</li>
<li>研发团队能做的是设计好的方案，【降低成本】。但好的方案不是唾手可得，有难度。为什么有难度？因为软件开发是复杂的。为什么是复杂的，复杂在哪儿？如何掌控？</li>
</ul>
<a id="more"></a>
<h2 id="复杂性来源"><a href="#复杂性来源" class="headerlink" title="复杂性来源"></a>复杂性来源</h2><ul>
<li><strong>问题域的复杂性</strong>：包括需求及质量要求。需求已经比较复杂了，还要在此基础上考虑质量要求(性能、可用性、安全、正确性、扩展性等)。再加上出方案时“随心所欲”，时间越久问题越复杂。</li>
<li><strong>可变性：</strong> 需求可以随意变动且不能通过模型预测，即使有一套方法能够自动生成代码，也是基于模型匹配的基础上。但真实世界的需求不可能和目标模型匹配，<strong>所以软件行业还是一个劳动密集型的产业。</strong></li>
<li><strong>一致性：</strong> 因为是劳动密集型产业，团队人数多，管理开发过程就有很大挑战，挑战在于维持设计的一致性和完整性。 </li>
<li><strong>不可见性：</strong> 产品是具体的，代码是抽象的。方案是否合理？代码行数是不是太多？代码质量怎么样？监控告警是否全面？效能如何 等，缺少可视化工具呈现，存在较多盲区。就像装修一样，外面看着挺好，墙背后的各种线、水电气等 都是盲区，诸多隐患没被发现。</li>
</ul>
<h2 id="如何控制复杂性"><a href="#如何控制复杂性" class="headerlink" title="如何控制复杂性"></a>如何控制复杂性</h2><h3 id="1-问题域的复杂性"><a href="#1-问题域的复杂性" class="headerlink" title="1.问题域的复杂性"></a>1.问题域的复杂性</h3><h4 id="1-1需求的复杂性"><a href="#1-1需求的复杂性" class="headerlink" title="1.1需求的复杂性"></a>1.1需求的复杂性</h4><ul>
<li>问题：<ul>
<li>需求规则没人知道，只能靠口口相传。</li>
<li>分不清用例、步骤、规则，理解需求时揉在一起，不够清晰。</li>
<li>不知道如何拆分需求，做不到尽早交付价值。</li>
<li>没有想清楚交付什么价值，大部分情况下用例(价值)是不变的，变得是步骤和规则(实现价值的方式)</li>
</ul>
</li>
<li>解决1：使用工具沉淀需求。目前互联网公司“流行”的做法是口口相传，沉淀远远不够。沉淀需求对于在技术层面做业务监控、可用性监控等有很大意义。</li>
<li>解决2：使用面向对象方法，从业务建模开始找到用例，画出用例图。用例图很好解答了 哪个组织/系统 对谁(涉众)提供了什么价值(用例)三个问题。想清楚价值，可以帮助判断方案能否达成价值以及是否有更好的方案。</li>
</ul>
<p><img src="/img/image-20230118162528384.png" alt="image-20230118162528384"></p>
<h4 id="1-2技术的复杂性"><a href="#1-2技术的复杂性" class="headerlink" title="1.2技术的复杂性"></a>1.2技术的复杂性</h4><p>技术的复杂性在于既要完成需求，又要考虑质量要求，<strong>技术复杂性=需求复杂性X质量要求(性能、可用性、安全、扩展性、正确性等)</strong></p>
<ul>
<li>问题1：忽视质量要求。需求已经比较复杂了，设计满足需求的方案可能已经精疲力竭了，哪顾得上质量要求。</li>
<li>建议：给时间+模板+把关。</li>
</ul>
<hr>
<ul>
<li>问题2：对问题域不够了解，设计的方案偏离真实世界，导致不断“重构”。美其名曰重构，可能是迭代不下去了，怎么保证重构后的不被重构呢？</li>
<li>建议1：不急于出设计，在设计之前先 <strong>分析</strong> ，先调查研究问题。没有充分理解问题，解决方案很可能是错的。就像面试，没弄懂面试官的问题，回答大概率是错的，做对也是蒙的。</li>
<li>建议2：【设计】之前画一下【分析类图】，找出对象及之间的关系，也是可视化的过程，比在脑子里硬想要高效。设计方案以及评审时就不用死盯着内容很多且不精确的PRD了。</li>
</ul>
<hr>
<ul>
<li><p>问题3：知识爆炸。业务规则及实现要看代码及口口相传。混淆的名词及代词影响正确性和效率。混淆的各种名词，沟通时使用各种代词，“他们” “我们”，涉及的系统多了就跟不上讲的人思路了</p>
</li>
<li><p>建议：增加<strong>分析</strong>流程，输出精准的、简洁的、可以理解的现实世界的模型。最重要的是分析类图，其次是分析序列图。</p>
<ul>
<li><strong>分析类图：关注数据，从现实世界捕获对系统重要的概念及关系。</strong></li>
<li><strong>分析序列图:关注协作，分配职责，完成用例。</strong> 讲流程时就不用说他们、我们了，把这个图丢出去就够了。</li>
<li><p><strong>状态机图：关注时序，对象的生命周期及状态流转条件。</strong></p>
<p>不要觉得这个没用或者很简单，画的过程中一定会有很多疑问：</p>
</li>
</ul>
<ol>
<li>该不该画这个类？这是类还是属性？是哪个类的属性？</li>
<li>该不该连线？多重性是什么？</li>
<li>是泛化还是枚举？是泛化还是关联？</li>
<li>反映了现实世界吗？</li>
<li>这个操作该由哪个类完成？</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><p>问题4：未能区分真正的复杂还是由“随心所欲”引入的复杂。</p>
<ul>
<li><p>既然已经认识到复杂是无法避免的，就不要再引入“随心所欲”的复杂了。扪心自问，平时说的系统复杂，有多少是我们自己引入的？</p>
</li>
<li><p>追求设计出“简单”的方案。“简单”是指对用的人或者对以后简单，而不是思考过程简单。“简单”绝不是忽视复杂性，相反要付出巨大的努力，还大概率做不到。比如交互设计领域，iOS足够简单，四岁小孩都会用，为什么其他公司设计不出来更好的呢？</p>
<p>  我们做技术方案也类似：</p>
<ul>
<li>当解决方案很容易想到时，要警惕，是不是草率了，这次简单了，以后是不是麻烦了？</li>
<li>当解决方案很复杂时，不要洋洋得意，要反思，是不是有更好的没有找到？或者这样想：让一个更厉害的人来做，是不是能设计出更“简单”的方案。</li>
<li>做减法，加法导致东西越来越多，多就会带来复杂性。</li>
</ul>
</li>
<li><p>把系统做复杂不是本事，做复杂谁都可以，四岁小孩儿随意画的画也能很复杂(图1)</p>
</li>
<li><p>不要图1的复杂，要图2的复杂：结果可以是复杂的，但复杂的结果可以由“简单”的方案演化出来。像大自然、语言、围棋等，由简单的元素就能演化出复杂的结果。</p>
</li>
</ul>
</li>
</ul>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180417/1df5da33bfb54242b02899cf7beeea54.jpeg" alt="看到宝宝乱写乱画，你会上去制止吗？"></p>
<p><img src="/img/image-20230118163840124.png" alt="image-20230118163840124" style="zoom:150%;"></p>
<h3 id="2-一致性"><a href="#2-一致性" class="headerlink" title="2.一致性"></a>2.一致性</h3><ul>
<li>要专业。引入的“随心所欲”复杂性，本质是因为自身不专业，下面的例子一定不陌生：<ul>
<li>相同变量名，不同含义</li>
<li>相同含义，不同变量名</li>
<li>单位不一致</li>
<li>中英文不一致</li>
<li>工程命名方式不一致</li>
<li>迷惑的变量名</li>
<li>工程命名方式不一致</li>
<li>变量名与业务语义不一致</li>
</ul>
</li>
</ul>
<p>看上去都是很小的点，多了会不会有千疮百孔的感觉？如果觉得这些case很小，系统中是否存在更大的不一致？比如注释与实现不一致，实现与设计不一致，<strong>设计与真实世界不一致</strong>(这可能是最大的不一致)。</p>
<ul>
<li>不要重复：保持一致的有效方式是只有一个。但重复经常发生，导致不一致：</li>
</ul>
<table>
<thead>
<tr>
<th>重复的类型</th>
<th><strong>解释</strong></th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>强加的重复</td>
<td>环境似乎要求重复，别无选择</td>
<td>代码 vs 注释 vs 文档<br>周报 vs 周会<br>MySQL VS Redis VS ES</td>
</tr>
<tr>
<td>无意的重复</td>
<td>没有意识到在重复</td>
<td>派生信息，存了出生年月又存年龄<br> 类名已经表明对象了，方法名还要加上对象名：XXClass.createXX。<br></td>
</tr>
<tr>
<td>无耐心的重复</td>
<td>偷懒，因为这样可能更容易</td>
<td>重复代码<br>上面提到的不专业的例子</td>
</tr>
<tr>
<td>开发者之间的重复</td>
<td>同一团队（或不同团队）重复了同样的信息</td>
<td>重复的轮子<br>业务语义相同的常量各团队都定义了一份</td>
</tr>
</tbody>
</table>
<ul>
<li>建议：<ul>
<li>避免破窗：发现一个改一个。就怕习以为常了，没意识到是债务。</li>
<li>用业务语言设计、写码，避免出现无业务语义的产物。如果在设计前，画了【分析类图】，可以避免很多问题。</li>
<li>第一种重复要慎重，二、三、四要避免。</li>
</ul>
</li>
</ul>
<h3 id="3-可变性"><a href="#3-可变性" class="headerlink" title="3.可变性"></a>3.可变性</h3><ul>
<li>没想到好方法。人是不靠谱的，尽量用工具替代人。是个长期过程，平时多留意可以沉淀出工具的地方。</li>
</ul>
<h3 id="4-不可见性"><a href="#4-不可见性" class="headerlink" title="4.不可见性"></a><strong>4.不可见性</strong></h3><ul>
<li>提升研发效率需要配套相关的可视化工具，如各种可视化监控，各种报表统计等。方便大家了解研发过程、研发结果的各种数据。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>利润=需求-设计，设计就是成本。工作时想想是在增加成本还是【降低成本】？目标是做一个“简单”的方案，“简单”符合人性，也符合自然规律。</li>
<li>为了做出“简单”的方案，要充分理解问题。在【设计】之前先【分析】，输出【分析类图】【分析序列图】。【分析】是把思考放在前头，由【分析】驱动设计，不是问题驱动，也不是重构驱动。</li>
<li>复杂不能消除，只能被管理。避免引入“随心所欲”的复杂，“随心所欲”是不专业的表现。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>开发</tag>
        <tag>复杂性</tag>
      </tags>
  </entry>
  <entry>
    <title>产品思维</title>
    <url>/2021/05/30/%E4%BA%A7%E5%93%81%E6%80%9D%E7%BB%B4/</url>
    <content><![CDATA[<p>小龙的产品思维讲的是大原则，是他自己的经验总结。这种级别的大佬不会面面俱到的介绍各种事项。<br>小龙讲的会颠覆大部分人的想法，但内容又是大家平时经常听到的。</p>
<p>《产品思维》这本书讲的比较具体，适合没做过产品的人了解产品经理如何思考问题的。</p>
<p>书分为三部分</p>
<ul>
<li>认知用户：找到真正的需求</li>
<li>创造价值：用户的主观感受，用户认为解决了自己的问题</li>
<li>产品落地：充分认知用户后，要有供给侧的能力将产品落地</li>
</ul>
<a id="more"></a>
<h2 id="认知用户"><a href="#认知用户" class="headerlink" title="认知用户"></a>认知用户</h2><p>认知用户有两种维度：微观和宏观。</p>
<ul>
<li>微观上 用户画像描述用户，同时要关注 用户场景、用户心智，也就是<strong>外部环境和内心想法如何影响决策</strong></li>
<li>宏观上 将用户分为不同用户群体。</li>
</ul>
<h3 id="微观认识：用户画像"><a href="#微观认识：用户画像" class="headerlink" title="微观认识：用户画像"></a>微观认识：用户画像</h3><p><strong>好的用户画像</strong><br>有真实感的用户画像是好的呢？因为我们在设计产品的时候有许多判断需要经过用户检验，用户画像就是第一关。<strong>用户画像的种种特征和描述，延伸出来的是用户生活工作的环境，是他们日常的心理状态，也有他们的认知能力等。</strong>(即用户场景和用户心智)</p>
<p>了解用户最好的方法就是和他们接触或者观察。(类似需求启发几种方法，面谈和观察有几个注意事项，不展开讲了)</p>
<p>对比一下 不好的用户好像VS好的用户画像</p>
<ul>
<li>不好的用户画像:</li>
</ul>
<blockquote>
<p>美甲用户：女，31岁，北京人，服装店老板。<br>外卖用户：男，24岁，福建人，互联网公司工程师。<br>滴滴用户：男，54岁，河北人，滴滴快车司机。</p>
</blockquote>
<ul>
<li>好的用户画像：</li>
</ul>
<blockquote>
<p>媒体公司的白领小慧，女生，25岁，老家是河北，来上海读书，本科毕业后工作。毕业刚几年，还是单身，不过朋友挺多的，大都是以前的同学。有了一定的收入，对生活品质也有了一些要求，刚搬到一居室的新家，房租不便宜，占工资的一多半，还自己做了很多装饰，买了很多小家具。平时的工作朝九晚五，晚上回家会看美剧。周末跟朋友出去逛街，吃东西，偶尔会去酒吧。喜欢用黄油相机和美图秀秀来拍照，修图，也会用keep（自由运动场）和Instagram（照片墙）来发健身和吃东西的照片。购物基本都是在淘宝和京东，比较擅长研究各种信用卡和优惠券的使用技巧。</p>
<p>在杭州工作的小伙子李东，从浙江海边的农村来，23岁，高中文凭。学历虽然不高，但是愿意折腾，在工地上搬过砖，当作餐厅服务员，做过保安，也摆摊做过生意。最近刚找了一份送外卖的工作，因为勤恳又机灵，当上了组长，接下来希望能争取当上公司在西湖区的主管。他跟老乡们住在比较偏远的郊区，群租房，平时没事儿就一起打牌，或者联机玩《王者荣耀》。许多吃穿用品都是从淘宝或者拼多多买的。</p>
<p>下岗的大叔建设，北京人，中专文凭，48岁，家里有刚读大学的女儿和开小服装店的老婆。原本是工人，工厂倒闭后就自己打些零工，现在也有相对稳定的收入了。平时喜欢遛鸟逛街，跟邻居们下棋、打牌。偶尔也会在电视、手机上看一些国产剧或者球赛。女儿还没有财务独立，所以日常生活里会格外省吃俭用，极少下馆子或者去娱乐场所。周末有时候会开车载着老婆去郊区的水库玩。</p>
</blockquote>
<h3 id="宏观认识：用户群体"><a href="#宏观认识：用户群体" class="headerlink" title="宏观认识：用户群体"></a>宏观认识：用户群体</h3><p>（不知道是不是和老王讲的STP中的S相似）<br><strong>如何划分?</strong><br>要对边界内的用户有深入认知，需要深入他的心坎和生活状态，理解他的心理和场景。只有这样，才能做出好的判断，这还要借助用户画像。</p>
<p>要想对群体认识的准确，需要借助数据。每个产品都有自己获取数据的限制条件，要收集不同人群的数据，手段自然差别很大。建立客观数据与画像描述之间的关系，要基于产品的特征和我们的认知判断。</p>
<h4 id="基于产品特性寻找相关数据"><a href="#基于产品特性寻找相关数据" class="headerlink" title="基于产品特性寻找相关数据"></a>基于产品特性寻找相关数据</h4><p>先看以下这几个用户群体画像的简要描述：</p>
<ul>
<li>用户是有钱人，收入水平高；</li>
<li>用户经常出差，是商务人士；</li>
<li>用户喜欢二次元，是个宅男。</li>
</ul>
<p>如何结合自己的产品特性找到相应数据建立画像？</p>
<blockquote>
<p>如果我们做社区类产品，那么可以参照用户参加的群组以及给自己贴的标签：参加了“高端信用卡交流”或者“私立幼儿园交流”群组的用户，很有可能是收入水平高的人群；参加了“携程里程积分兑换经验”或者“各地酒店推荐”群组的用户，很有可能是经常出差的人；参加了“新番动画推荐”或者“手办海购交流”群组的用户，很有可能是二次元爱好者。</p>
</blockquote>
<p><strong>建立数据、特征、画像的关联</strong><br>通过 <strong>用户数据</strong> 分析用户特点，主观加上<strong>特征</strong>，特征聚焦的就是用户人群，得到<strong>用户群体画像</strong></p>
<blockquote>
<p>比如，我们看到有许多加入群组的行为数据，这些数据意味着什么呢？单看数据没有任何意义，我们要看有哪些群组能够赋予特征含义。对于“加入高端信用卡交流”这个行为来说，我们就可以赋予其“高收入”的特征含义。许多“高收入”特征的聚集，就能够聚焦一些用户。</p>
</blockquote>
<p>这个特征可能不是一个，可能是多个条件组合起来，如认为加入“高端信用卡交流”&amp;&amp;“私立幼儿园交流”才是“高收入”。</p>
<p><strong>根据特征划分出的群体需要验证划分的正确性，可以通过科学建模算出正确性的概率，也可以实际接触用户验证。</strong></p>
<h4 id="用户画像与用户特征的应用"><a href="#用户画像与用户特征的应用" class="headerlink" title="用户画像与用户特征的应用"></a>用户画像与用户特征的应用</h4><blockquote>
<p>我们是一个创业小团队，正在做一个P2P（个人对个人）金融产品。平台上已经有了一定量的用户，他们购买了我们的理财产品。我们正在考虑要不要增加VIP（贵宾）套餐服务，定位高价值用户，定向提供理财顾问服务。我们会请许多专家，提供很多额外的分析工具，让这些用户享受高端服务，赢利方式就是VIP年费。</p>
<p>单拿这个服务来看，肯定是没有什么问题的。“许多类似的产品都有这样的服务。”也许老板就会这么跟你说。但这不能成为我们就一定要提供VIP套餐服务的理由，我们还是要看看我们的用户是什么样的。</p>
<p>可以先统计下当前用户购买理财产品的行为数据，看看大部分买的额度有多大。其实，额度背后代表的是这些用户的收入水平和对理财的态度。假设，99%的用户都是奔着投资5万元，锁定期6个月，年化收益率5%的产品去的。这些行为代表什么呢？从生活经验判断，对年化收益率要求不高，对流动性也要求不高，对安全性要求比较高的人，应该都是普通的上班族。这些人在理财方面非常保守，而且还比较年轻，理财额度并不高。</p>
<p>具体的验证可以通过访谈和调研来完成。假如结果显示，这些用户群体基本都是毕业三年内的职场新人，理财行为非常保守，收入并不高，这时回过头来看，这个VIP套餐服务的吸引力就特别有限了。我们可以做一些试验性的调研看看大家的接受度（我们会在后文讲述如何做类似的迭代实验），但仅从用户特征来看，几乎就可以给这个创意判死刑了。</p>
</blockquote>
<p><strong>随着对用户认识的更准确，用户群体可能被划分出多个。产品也要符合不同用户群体的需求。比如理财产品，低收入群体可能喜欢风险低的，高收入群体期望有专门的理财顾问。</strong></p>
<p><strong>认识用户要宏观和微观起来。对用户群体先用群体特征进行抽象识别，再用更具体的用户画像来认知。</strong></p>
<h4 id="用户人群的划分维度"><a href="#用户人群的划分维度" class="headerlink" title="用户人群的划分维度"></a>用户人群的划分维度</h4><p>用户人群的划分有多个维度，最常见的是用户生命周期阶段的划分方法,<br>如:<br><img src="/img/16223621951610.jpg" alt="-w239"></p>
<p><strong>生命周期划分的注意事项</strong></p>
<ol>
<li>生命周期的划分不是源于数据聚类，不是源于已有的方法论，而只源于对用户的认知。对自己用户的充分认知是划分生命周期的重要前提，不要觉得所有的生命周期方法都是可复用的。</li>
<li>生命周期划分方法应该是用户视角而不是平台视角在划分出人群后，该做什么，依然要根据每类用户的需求来推断。依据生命周期划分用户之后，要根据每类群体的特征研究他们的诉求，不能舍本逐末，用简单粗暴的营销甚至砸钱的方法做转化，要更多地通过让用户需求得到满足、认可产品价值的方式做转化。</li>
</ol>
<p><strong>始终铭记，“用户生命周期是为了更好地认知用户和创造价值”比“用户生命周期是为了更好地做用户转化”更重要。</strong></p>
<h3 id="利用场景判断用户真实需求"><a href="#利用场景判断用户真实需求" class="headerlink" title="利用场景判断用户真实需求"></a>利用场景判断用户真实需求</h3><ul>
<li>用户使用产品时所在的物理环境</li>
<li>用户所在的社会场景：每个人无时无刻不在与各种人打交道。这些人会怎么看待我们，以及与他们交互对我们产生的影响，都会深刻影响我们当下对产品的诉求</li>
<li>考虑用户的心流：用户的心理状态会受这些外部因素影响而变化。用户心理状态的变化，是我们设计产品时更需要重点关注的课题，我们把用户在特定心理场景下的状态，称为心流。</li>
</ul>
<h3 id="用户心智"><a href="#用户心智" class="headerlink" title="用户心智"></a>用户心智</h3><p>探索用户心智很难，比如：“假如发生××，用户会怎么样？”。<br>影响用户心智的因素有很多：</p>
<ul>
<li>社会心智</li>
<li>生活方式</li>
<li>消费心理</li>
<li>文化程度</li>
<li>价值观<br>书中讲的我不认为和用户心智有很大关系，更多的是心理学的一些研究成果。</li>
</ul>
<p>我觉得用户心智更多的是要了解人性，马斯洛需求层次理论、《乌合之众》以及从了解自己出发更合适。这方面小龙讲的比较好。</p>
<h3 id="找到真实有效的需求点"><a href="#找到真实有效的需求点" class="headerlink" title="找到真实有效的需求点"></a>找到真实有效的需求点</h3><ul>
<li>用户的诉求不等于需求（区分want和need）</li>
<li>需求的主体是目标用户（我理解这里想说的是要先找到目标用户，考虑目标用户的需求，不是目标用的需求不用考虑）</li>
<li><strong>用户是需求的结合</strong>：要了解我们正在关注的需求，处于用户心智的什么位置，占多大比重。我们找到了目标用户，并不意味着我们完全掌握了用户。<strong>我们占据的用户时间是用户从自己的心理账户里挤出的时间，我们覆盖的需求也只是用户的一部分需求。</strong> 这个心理账户时间，或者这块需求，不是因为产品形态而变化，而是因为用户心智而变化。比如做一款游戏产品，与之竞争的不仅仅是王者荣耀等，还有抖音。</li>
<li>需求有不同层次，深层的需求持久永恒（不仅是需求，价值也是，参考业务用例）</li>
</ul>
<h2 id="创造用户价值"><a href="#创造用户价值" class="headerlink" title="创造用户价值"></a>创造用户价值</h2><h3 id="产品设计者为用户价值和产品价值负责"><a href="#产品设计者为用户价值和产品价值负责" class="headerlink" title="产品设计者为用户价值和产品价值负责"></a>产品设计者为用户价值和产品价值负责</h3><blockquote>
<p>对用户充分认知之后，就进入了创造价值阶段。只有帮到用户，或让用户认为自己被帮助了，才能创造价值，创造好的体验。是否能够帮助用户解决问题，是衡量用户价值、产品价值和产品体验的标准。</p>
</blockquote>
<p>可以用以下三方面描述：</p>
<ul>
<li>用户价值：用户使用产品时主观判断能否帮助自己解决特定问题。</li>
<li>产品价值：从产品设计的视角关注的用户价值。</li>
<li>用户体验：在实现用户价值过程中用户的主观感受。</li>
</ul>
<p><strong>用户价值</strong><br>用户价值通常有两种含义：</p>
<ul>
<li>我们能够为用户创造的价值——用户使用产品时对我们的感受是否有价值、有帮助；</li>
<li>用户对于我们的商业价值——用户是不是能提高我们的收入或者是潜在的贡献者。</li>
</ul>
<p>这里强调的是前一点。用户使用产品时主观判断能否帮助自己解决特定问题</p>
<p><strong>产品价值</strong><br>产品价值指的是从产品设计视角关注的用户价值，本质上也是用户价值：产品价值是由用户决定的；产品价值是体现在功能和服务中的。</p>
<p>从设计者的视角或企业的视角，思考产品应该怎么做才会有价值时，就要考虑以下两方面：</p>
<ul>
<li>外部环境；</li>
<li>用户并非单一用户。(面对的是群体)</li>
</ul>
<p>考虑外部环境，指的就是要知道是否存在用户在用“旧的产品”或者用户有“旧的需求满足方式”。任何产品都不可能摆脱真实的市场环境来衡量自己的产品是否有价值。</p>
<p>余军的理论：<br><strong>产品价值=（新体验－旧体验）－迁移成本</strong><br>产品价值公式揭示了许多产品决策者通常会犯的两个主要错误：</p>
<ul>
<li>忽视旧体验；</li>
<li>忽视迁移成本。</li>
</ul>
<p><strong>用户体验</strong><br>用户使用的产品体验是完整的，所以不管是交互问题，还是在交互背后的一系列餐品与图片不符的问题，买不到想吃的东西的问题，价格太贵的问题，送餐太慢的问题，食品过期的问题……这些都是用户体验。这时，单纯的交互体验反而意义不大。</p>
<h3 id="基于用户需求判断用户价值"><a href="#基于用户需求判断用户价值" class="headerlink" title="基于用户需求判断用户价值"></a>基于用户需求判断用户价值</h3><h4 id="用户价值是用户的主观感受"><a href="#用户价值是用户的主观感受" class="headerlink" title="用户价值是用户的主观感受"></a>用户价值是用户的主观感受</h4><p>注意，一定要从用户角度出发，使用户的感受，不是其他人的。比如知识付费，专业的人可能评价别人某一门课程内容专业度不够，但用户觉得好就行了。<br><strong>要时时刻刻从涉众角度看问题！！！</strong></p>
<h4 id="用户价值受社会心智和认知行为心智的影响"><a href="#用户价值受社会心智和认知行为心智的影响" class="headerlink" title="用户价值受社会心智和认知行为心智的影响"></a>用户价值受社会心智和认知行为心智的影响</h4><ul>
<li><p>受行为心智影响：“锚定效应”里，用户会跟随商家的引导形成对商品价值有一定偏误的认知。</p>
</li>
<li><p>受社会心智影响：</p>
<blockquote>
<p>2018年8月，有网友反馈自己的手机收到大量短信验证码，且支付宝绑定的网银里的余额不翼而飞。网友报警并反馈到各个相关方之后，得到的各方答复是：<br>● 警方无法确定被盗事实，也没有找到盗窃者；<br>● 保险公司认为更像是本人操作，无法确认是被盗，因此无法理赔；<br>● 支付宝决定先全额补偿，然后配合警方继续调查。</p>
<p>支付宝这么做，是因为它比较善良、公司价值观高尚吗？还是因为互联网公司在处理类似事情上比较灵活？还是什么其他特殊原因？</p>
<p>实际上做“全额赔付”这种承诺背后，考虑的就是用户心智里对支付产品的信赖首先就源于它是否安全。用户考虑使用支付宝，自然先考虑资金是不是足够安全。如果没有全额赔付，看到其他人遇到类似的问题，支付宝不管不顾，那信任度就会变得很差。就这个单一案例看，支付宝的赔付也许有点吃亏，但就在用户的心智里塑造良好的可信赖形象而言，这是非常重要的。</p>
<p>倘若支付宝解释自己的支付异常率或者账户被盗率比传统金融企业要低得多，这并没有意义，用户不会以这种量化的标准去比较，安全是个是非题，不是数学题。</p>
</blockquote>
</li>
</ul>
<h3 id="核心用户价值就是产品要实现的产品价值"><a href="#核心用户价值就是产品要实现的产品价值" class="headerlink" title="核心用户价值就是产品要实现的产品价值"></a>核心用户价值就是产品要实现的产品价值</h3><p>怎么寻找产品的核心价值呢？产品的核心价值要符合以下几个要点：<br>(这部分老王讲的 战略 及 波特三种竞争战略 更好)</p>
<ul>
<li>符合用户价值</li>
<li>对应的就体验差，有空间</li>
<li>简单明了：要考虑用户心智认知的问题，<strong>用户很难认知你的产品是混合了多个价值的，也很难在心智里存储一个复杂描述。</strong>迅雷创始人程浩讲过：“好的创业项目和好的商业模式，永远要一句话就能讲清楚。”讲不清楚的项目，通常是创业者没有想好。其实哪怕创业者真的想清楚了，也不代表用户能够认知清楚，没有深入人心的心智建设，用户很难在对应的场景下想到用你的产品解决问题。</li>
</ul>
<blockquote>
<p>优步的产品定位的宣传并非智能交通出行平台或者共享经济引领者这样抽象的概念，而是一句简单的“点击按钮，搭车就走”（Tap a button, get a ride）。同理，滴滴出行也是一句“滴滴一下，马上出发”。它们强调的都是非常核心的用户价值：在线约车，且会快速到达。</p>
</blockquote>
<ul>
<li>覆盖用户足够多</li>
<li>自己有经验或资源优势</li>
</ul>
<p><strong>在短期效果与长期价值之间做权衡</strong>，比如：</p>
<blockquote>
<p>用“小红点”这种提醒告诉用户，有重要的事情发生了，结果用户点击进去发现是一个导流广告。<br>这样带来的流量当然很可观，但实际上牺牲的是用户未来“对小红点功能的信任感”，牺牲的是这个功能再拿来正常使用的价值。<br>这样的“黑魔法”也是追求短期效果的典型，是忽视用户价值的手段。</p>
</blockquote>
<h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><p><img src="/img/16223672912561.jpg" alt="-w491"></p>
<ul>
<li>可用性是用户价值的核心：指的是让用户达成预期目的，通常也是核心用户价值的体验</li>
<li>易用性是用户达成目标的成本</li>
<li>稳定性在复杂场景中有更高的要求（有三种方法：避免异常发生；异常难以发生；异常可以快速恢复）</li>
<li>超预期体验并非用户体验的必要组成：一是比原来的体验好，二是持续获得惊喜。</li>
</ul>
<h2 id="产品落地"><a href="#产品落地" class="headerlink" title="产品落地"></a>产品落地</h2><blockquote>
<p>从创意到实现，除了足够的认知，还包括供给侧能力和迭代思维两个核心逻辑。结合贯穿整个产品生命周期的“科学思维”，这就是需要产品人熟悉和掌握的三项核心思维。</p>
<p>“现在市场上缺少一款这样的产品给用户”，代表的是产品价值逻辑成立，但并不代表“我去做这款产品就一定能够成功”。</p>
</blockquote>
<h3 id="深入场景，探索供给侧的价值"><a href="#深入场景，探索供给侧的价值" class="headerlink" title="深入场景，探索供给侧的价值"></a>深入场景，探索供给侧的价值</h3><p>供给侧通常分为两种情况：</p>
<ul>
<li>单向提供功能和服务的产品，供给侧就是如何制造产品和提供服务的团队及资源，我们可以称之为独立品牌产品；</li>
<li>多方撮合的平台型产品，供给侧就不仅包括平台本身所需的团队和资源，还包括撮合的非狭义用户之外的用户，比如商家或者服务者，我们可以称之为平台类产品。<br><strong>独立品牌更关注自己完成的“功能体验”和“服务品质”，而平台类产品更关注的是赋能给B端供给侧的用户，让他们具备足够的“功能体验”和“服务品质”。</strong><br><img src="/img/16223676516938.jpg" alt="-w363"></li>
</ul>
<p>我觉得例子举得不好。百度也可以认为是平台型，因为它聚合了各个网站的信息。</p>
<h4 id="供给侧画像是认知供给侧的起点"><a href="#供给侧画像是认知供给侧的起点" class="headerlink" title="供给侧画像是认知供给侧的起点"></a>供给侧画像是认知供给侧的起点</h4><p>由用户画像、用户价值作为先决条件的，即我们需要获取什么样的用户，需要创造什么样的价值，再考量什么样的供给侧能够完成这样的逻辑，最终获取对应的供给侧角色和资源。</p>
<blockquote>
<p>当决定供给侧画像策略时，我们还是要从需求出发去分析供给，而不是相反。<br>单纯从司机视角看，按法规规定，左下肢残疾的残疾人司机是可以驾驶自动挡汽车的。<br>但从作为服务行业的网约车平台看，残疾人司机未必可以提供我们要求的标准化服务，还可能带来乘客的警惕和恐慌，因此这类司机可能就无法成为供给侧的司机。</p>
</blockquote>
<p>供给侧的画像未必只是指第三方的供给、合作伙伴、合伙人、员工这样真实的人，也可能是人脉、资源甚至钱。</p>
<p><strong>总之，供给侧画像回答的就是一个问题：知道了用户价值，需要什么条件，要做什么才能实现它？</strong></p>
<h4 id="用供给侧场景来检验供给侧真实程度"><a href="#用供给侧场景来检验供给侧真实程度" class="headerlink" title="用供给侧场景来检验供给侧真实程度"></a>用供给侧场景来检验供给侧真实程度</h4><p>(小龙：把需求带到场景中才能做出判断)<br>我觉得这部分讲的方法不够好。<br>供给侧场景也能帮助更好地判断供给侧是否存在真实场景下的逻辑疏漏。</p>
<p>供给侧的场景的要求梳理清楚供给侧的所有角色及资源的流转过程，不要存在模棱两可和不确定的节点。这种不确定的节点在未来具体推进中势必会变成真实的灾难。</p>
<h4 id="供给侧创新：模式创新与技术创新"><a href="#供给侧创新：模式创新与技术创新" class="headerlink" title="供给侧创新：模式创新与技术创新"></a>供给侧创新：模式创新与技术创新</h4><p>这部分讲的不好，老王讲的战略中的“入场时机”更好。<br>我个人总结，就是PEST(political、economic、social、tecnology)+CC(customers、competitors)</p>
<h3 id="产品迭代"><a href="#产品迭代" class="headerlink" title="产品迭代"></a>产品迭代</h3><p>迭代思维的运转逻辑大概分为以下四个步骤，循环往复。<br><img src="/img/16223683742232.jpg" alt="-w482"></p>
<h4 id="判断最重要的体验差"><a href="#判断最重要的体验差" class="headerlink" title="判断最重要的体验差"></a>判断最重要的体验差</h4><p>在体验差最大化的核心指导思想下，我们可以找到最重要的体验差是什么以及该做什么。</p>
<blockquote>
<p>如果是一个从0到1的产品，那需要判断产品核心价值和用户核心体验（可用性），比如一些生活服务类产品，就是服务本身能够完成闭环，外卖平台可以订到外卖，出行平台可以打到车。<br>如果是一个非常成熟的产品，那要判断接下来要关注的最重要的用户体验优化方向，比如相对成熟的美团外卖或滴滴出行，就会更关注减少异常场景的发生，尽量减少送餐超时和接驾太远等情况。</p>
</blockquote>
<h4 id="新体验的最小成本尝试"><a href="#新体验的最小成本尝试" class="headerlink" title="新体验的最小成本尝试"></a>新体验的最小成本尝试</h4><p>最小成本尝试是为了验证新体验的方案和我们的判断是否奏效，需要满足以下三个要点：</p>
<ul>
<li>不能过于简陋和变形，导致无法验证判断的正误；</li>
<li>在这个基础上，成本最小化完成尝试的方案；</li>
<li>尝试前要确定预期和判断标准。<br>可以用<strong>灰度</strong>和<strong>AB Test</strong>验证效果</li>
</ul>
<h4 id="用数据观察结果，做分析识别正误"><a href="#用数据观察结果，做分析识别正误" class="headerlink" title="用数据观察结果，做分析识别正误"></a>用数据观察结果，做分析识别正误</h4><ul>
<li>需要观察的结果大致有两种：用户反馈和行为数据。</li>
<li>在判断结果时的原则是，<strong>如果有明确的行为数据，首要考虑的还是行为数据</strong>，毕竟数据是相对客观的呈现，且能够量化。</li>
</ul>
<p><strong>要再强调的是，所谓的正误或者与预期有异，是基于我们在实验之前的假设或者预期，没有什么绝对的标准。比如做到提升20%的用户活跃度就是对的，提升10%就是错的，预期是从产品决策的视角人为设定的，没有价值观上的对错之分</strong></p>
<p>我们需要做的，是当预期提升20%时，结果只提升了5%，确认到底哪里出了问题，是否有优化空间，还是这条路压根儿就走不通。或者提升到了30%，我们要确认之前的判断是否正确，还有哪些没有想到的（甚至很有可能是碰巧触动了意想不到的用户价值，也未可知）。</p>
<h4 id="分析正误的基础：数据思维"><a href="#分析正误的基础：数据思维" class="headerlink" title="分析正误的基础：数据思维"></a>分析正误的基础：数据思维</h4><p>宋世君(脸书出身的数据科学总监)总结的数据分析十条原则：<br><img src="/img/16223688237035.jpg" alt="-w480"></p>
<p>认知偏误会暗地里影响数据决策的准确性，比如：</p>
<ul>
<li>样本选择错误：指的是抽样的方法并不严格随机，</li>
<li>选择性偏误：指的是因样本选择的非随机性而导致得到的结论存在偏差。比如看我做的产品经理公众号“刘言飞语”是否能帮到新人产品经理，于是统计了公众号的粉丝和非公众号的新人产品经理之间的差异，发现前者的确有更好的工作机会和收入情况。这就意味着“刘言飞语”真的帮了大家吗？其实未必，因为关注了公众号的新人产品经理本来就有“更积极地获取有效信息”的特点，这个属性决定了他们会有更好的结果，而不是因为关注了公众号</li>
<li>幸存者偏误（survivorship bias）：指的是只看到了筛选的结果而无视筛选过程中的关键因素。</li>
<li>基本归因错误（fundamental attribution error）：指的是考察某些行为或后果的原因时高估个人因素，低估场景和环境影响的双重倾向。</li>
<li>回归谬误（regression fallacy）：指的是没有考虑随机起落的正常波动现象，造成不准确的因果推论。生活中最常见的就是许多药物的药效，大多治标不治本，而我们吃药后病情好转会认为是药效好，其实大都是自愈（比如感冒）</li>
<li>社会期望偏误（social desirability bias）是在做用户调研时经常遇到的：相较于真实的答案，被调查者更有可能选择符合社会期望的答案。最典型的例子是在一个社会文化过于传统的环境中，同性恋极少会公开自己的性取向。</li>
<li>受试者期望效应（subject-expectancy effect）是指用户会有自己的目的性和预期，所以不选择更真实的答案，社会期望偏误是其中的一种。还有的情况，可能涉及利益关系，比如我们做了一个商品，询问用户在涨价20%的情况下是否还会购买，虽然用户内心清楚涨价20%还是会买，但考虑到不希望涨价，就会表示不会购买，这样得到的结论就是错误的。</li>
</ul>
<h4 id="坚持对的，放弃错的"><a href="#坚持对的，放弃错的" class="headerlink" title="坚持对的，放弃错的"></a>坚持对的，放弃错的</h4><p>人性的弱点：我辛苦耕耘之后，还要跟别人承认我的方案不行？更难的是，假如这个方案的来源是老板和不熟悉的人，要说服他们认可你的结论，也要做许多工作。</p>
<p>常见的一种麻烦的情况是，当你否认对方或者自我否认时，大家都会想到一个点：应该不会是我的逻辑推断有问题，可能就是方案没有做好，再优化一下试试？于是就会陷入无穷无尽的优化，</p>
<p>做到“放弃错的”并非是单纯的能力和方法问题，而是心态问题。有几种方法可以避免：</p>
<ul>
<li>确保在预期时，就设置清晰的退出机制</li>
<li>塑造无压力的试错环境。错误带来的压力过大是影响我们心态的更本质原因，假如环境强压下，每个人都不怎么允许犯错，结果就是每个人拼尽全力在避免别人认为自己在犯错，于是就会拼命用数据证明自己，这就陷入了恶性循环。要提供给产品决策者足够大的试错空间，才能够让迭代往健康的方向发展。</li>
<li>由第三方来做中立的判断</li>
</ul>
]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title>别让我思考</title>
    <url>/2021/05/16/%E5%88%AB%E8%AE%A9%E6%88%91%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>作者对可用性的定义：</p>
<blockquote>
<p>让一个有着平均能力和经验的人(甚至稍低于平均水平)能明白如何使用它——不必付出过度的努力，或者遇到不必要的麻烦。</p>
</blockquote>
<p>可用性可以分解为其他几个方面：</p>
<ul>
<li>有用：分否帮助人们完成一些必须的事务？</li>
<li>可学习：人们能否明白如何使用它</li>
<li>可记忆：人们每次使用的时候，是否都需要重新学习？</li>
<li>有效：他们能完成任务吗？</li>
<li>高效：他们是否只需花费适当的时间和努力就能完成任务？</li>
<li>合乎期望：是人们想要的吗？</li>
<li>令人愉悦：人们使用的时候觉得有意思甚至很好玩吗？</li>
</ul>
<a id="more"></a>
<h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><h3 id="别让我思考"><a href="#别让我思考" class="headerlink" title="别让我思考"></a>别让我思考</h3><p><strong>实际上不需要检查清单，重要的是能快速把自己变成小白，需要思考的地方就能看出来了。</strong></p>
<p>强迫我们思考的地方</p>
<ol>
<li>命名<br>例如一个招聘网站：按钮分别命名为“jobs”、“Employment Opportunities”、“Job-o-Ramma”需要思考的程度完全不一样。</li>
<li>不要让用户花时间思考某个都系是否能点击。</li>
<li>我在什么位置？</li>
<li>我该从哪儿开始</li>
<li>它们把XX放在哪了？</li>
<li>这个页面最重要的是什么？</li>
<li>为什么它们把它叫这个？</li>
<li>这是广告还是网站的内容</li>
</ol>
<h3 id="人们是如何使用web的"><a href="#人们是如何使用web的" class="headerlink" title="人们是如何使用web的"></a>人们是如何使用web的</h3><ol>
<li>不是阅读，而是扫描</li>
<li>不做最佳选择，而是满意即可：一旦发现某个看起来似乎会跳转到想去的地方，就会点击，而不会继续寻找。</li>
<li>不是追根究底，而是勉强应付：就像没有人会阅读使用说明书一样，只要起作用了，没人会关心原理以及使用方式对不对</li>
</ol>
<h3 id="为扫描设计，不为阅读设计"><a href="#为扫描设计，不为阅读设计" class="headerlink" title="为扫描设计，不为阅读设计"></a>为扫描设计，不为阅读设计</h3><ol>
<li>尽量利用习惯用法：遵循习惯和惯例，使用已经被广为采纳或者已经标准化的设计。除非确定有一个更好的，否则和习惯保持一致。<br><strong>简洁胜过一致</strong>。如果打破一致性可以得到高度简洁清楚的效果，果断选择简洁。</li>
<li>建立有效的视觉层次<ul>
<li>越重要的部分越突出</li>
<li>逻辑上相关的部分在视觉上也要相关</li>
<li>逻辑上包含的部分在视觉上进行嵌套</li>
</ul>
</li>
<li>把页面划分成明确定义的区域：可以让用户快速决定关注哪些区域或者放心跳过哪些区域。</li>
<li>明显标识可以点击的地方：因为人们在网络上所做的大多事情是找到下一个地方点击，明确标识哪里可以点击哪里不可以很重要。</li>
<li>最小化干扰<br> 三类视觉噪声：<ul>
<li>眼花缭乱</li>
<li>组织不当</li>
<li>太过密集</li>
</ul>
</li>
<li>为文本创建清楚的格式，以便扫描<ul>
<li>充分使用标题</li>
<li>保持段落简洁</li>
<li>使用符号列表</li>
<li>突出关键词语</li>
</ul>
</li>
</ol>
<h2 id="必须正确处理的几个方面"><a href="#必须正确处理的几个方面" class="headerlink" title="必须正确处理的几个方面"></a>必须正确处理的几个方面</h2><h3 id="设计导航"><a href="#设计导航" class="headerlink" title="设计导航"></a>设计导航</h3><p>导航很重要的原因：web上缺少空间的感觉</p>
<ul>
<li>感觉不到大小</li>
<li>感觉不到方向</li>
<li>感觉不到位置<br>缺少这些会没有安全感，内心会焦虑，导致快速离开。</li>
</ul>
<p>访问网站上的内容时，不是靠一种它在哪里的物理感觉，而是记住它在概念层次上的位置，然后重新顺着以往的链接过去。<strong>这就是书签和后退按钮用的最多的原因。</strong></p>
<p>所以主页很重要，就像北极星，给了一个重新开始的机会。</p>
<ol>
<li>让导航在每一页以一致的外观出现在同样的位置</li>
<li>在每个页面上见到站点ID，通常是左上角</li>
<li>除全局导航，提供辅助导航、友好导航(实用工具)。</li>
<li>提供搜索：使用“搜索”文案；筛选选项不需要一直出现，可以在结果太多时出现。</li>
<li>每个页面都有页面名称:就像指示牌，且与点击的链接一致。</li>
<li>突出当前所在位置：告诉用户“你在这里”</li>
<li>面包屑：放在最顶层;使用&gt;对层级进行间隔;加粗最后一个元素</li>
<li>使用Tab页</li>
</ol>
<p><strong>测试导航效果的方法</strong><br>由任意链接进入网站，应能毫不犹豫回答以下问题：</p>
<ul>
<li>这是什么网站(站点ID)</li>
<li>我在哪个页面上(网页名称)</li>
<li>这个网站的主要栏目是什么(全局导航)</li>
<li>在这个层次上我有哪些选择(本页导航)</li>
<li>我在导航系统的什么位置?(“你在这里”指示器)</li>
<li>我怎么搜索</li>
</ul>
<h3 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h3><p>主页要 <strong>传达整体形象</strong>，越快越好，越清楚越好。<strong>最初的那几秒很重要</strong><br>进入一个新网站时，主页需要快速解答<strong>四个问题</strong>：</p>
<ul>
<li>这是什么网站</li>
<li>我能在这里做什么</li>
<li>网站上有些什么</li>
<li>为什么我应该在这里而不是别的地方</li>
</ul>
<p>如何传达？</p>
<ul>
<li>口号：清楚；长度合适；有个性、生动；</li>
<li>欢迎广告：网站的简要描述，显示在主业的首要位置，通常是页面上端的左边或中间，是用户第一眼就会看到的内容。不要把使命陈述当做欢迎广告。</li>
<li>了解更多：用户习惯了通过观看介绍视频来了解网站。</li>
</ul>
<p><strong>第五个问题</strong><br>快速浏览主页后，应该能准确无误地知道：</p>
<ul>
<li>如果我想搜索，可以从这里开始</li>
<li>如果我想浏览，可以从这里开始</li>
<li>如果我想看最精彩的内容，可以从这里开始。</li>
</ul>
<p>在需要一系列操作步骤的网站上，过程的起点应该很显眼。在需要注册/登录的网站，<strong>突出闲置注册和登录的位置</strong></p>
<h2 id="大的方面和外界影响"><a href="#大的方面和外界影响" class="headerlink" title="大的方面和外界影响"></a>大的方面和外界影响</h2><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p>区别在于阅读量变小，移动的更快。<br>空间不足意味着要看到同样多的内容要多点出，多滑动，因为移动网站比WEB网站层次更深。</p>
<ol>
<li>没有光标=没有悬停=没有线索</li>
<li>应用可学习。</li>
<li>应用可记忆：可记忆性可能是影响人们是否会经常使用应用的重要因素。通常刚使用一个应用时，愿意花时间研究如何使用。但如果下次也需要同样的时间学习，会导致再也不用了。</li>
</ol>
<h3 id="可用性是基本礼貌"><a href="#可用性是基本礼貌" class="headerlink" title="可用性是基本礼貌"></a>可用性是基本礼貌</h3><p>降低好感的几种方式：</p>
<ul>
<li>隐藏想看到的信息：如隐藏付费。通过一步步诱导才看到付费页面。</li>
<li>因为没有按照网站的方式使用而受到惩罚</li>
<li>咨询不必要的信息</li>
<li>敷衍、欺骗<br>-设置障碍</li>
</ul>
<p>提高好感的几种方式</p>
<ul>
<li>知道人们在网站上想做什么，并简洁易懂</li>
<li>告诉用户想知道的：如费用、暂停服务等</li>
<li>尽量减少步骤</li>
<li>知道哪些可能有疑问，并给予解答</li>
<li>容易从错误中恢复</li>
</ul>
<h3 id="需要正确实施的四件事"><a href="#需要正确实施的四件事" class="headerlink" title="需要正确实施的四件事"></a>需要正确实施的四件事</h3><ol>
<li>改正所有让人感到混淆的可用性问题</li>
<li>读一篇文章：了解如何让某样东西更好用，方法是观察人们实际如何使用。Guidelines for Accessible and Usable Web Site:Observing Users Who Work with Screen Readers（网站可访问及可用指南:屏幕阅读器用户观察）<br><a href="https://redish.net/wp-content/uploads/Theorfanos_Redish_InteractionsPaperAuthorsVer.pdf" target="_blank" rel="noopener">https://redish.net/wp-content/uploads/Theorfanos_Redish_InteractionsPaperAuthorsVer.pdf</a></li>
<li>看一本书：<ul>
<li>《A Web for Everyone: Designing Accessible Use Experiences》</li>
<li>《Web Accessibility: Web Standards and Regulatory Compliance》</li>
</ul>
</li>
<li>一些建议：<ul>
<li>为每张图片增加合适的alt文本</li>
<li>使用合适的标题</li>
<li>让表单配合屏幕阅读器</li>
<li>在每个页面最前面增加一个“跳转到主要内容”的连接。</li>
<li>让所有的内容可以通过键盘访问</li>
<li>在文本和背景之间设置明显的对比</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>用户体验要素</title>
    <url>/2021/05/12/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/</url>
    <content><![CDATA[<p><img src="/img/16213441795165.jpg" alt="-w647"></p>
<a id="more"></a>
<h2 id="为什么用户体验如此重要"><a href="#为什么用户体验如此重要" class="headerlink" title="为什么用户体验如此重要"></a>为什么用户体验如此重要</h2><p><strong>1. 用户体验并不是指一件产品本身是如何工作的，而是指“产品如何与外界发生联系并发挥作用”，也就是人们如何“接触”和“使用”它。</strong></p>
<ul>
<li><p>当人们询问某个产品或服务时，他们问的是使用体验。他用起来难不难，是不是很容易学会？</p>
</li>
<li><p>关注的是what，而不是how。决定what和how的往往是why。why需要做产品的人想清楚。</p>
</li>
</ul>
<p><strong>2. 用户体验设计通常要解决的是应用环境的综合问题。</strong></p>
<ul>
<li>视觉设计选择合适的按钮形状和材质，功能设计要保证按钮在设备上触发适当的动作。</li>
<li><p>用户体验设计要综合以上两者，兼顾视觉和功能两方面的因素，同时解决产品所面临的其他问题。比如：<br>“对于一个如此重要的功能来讲，这个按钮是不是太小了”用户体验设计同时还要保证党用户尝试去完成其他某个任务时，按钮能更好的工作。比如：“用户可能会同时使用另外的一些功能按钮，那么，与那些按钮相比这个按钮所放置的位置是否合理？”</p>
</li>
<li><p><strong>用户体验设计要保障由“视觉设计”引起的用户预期与“功能设计”保持一致。要自然。</strong></p>
</li>
</ul>
<p><strong>3. 产品越复杂，确定如何向用户提供良好的使用体验就越困难。在使用产品的过程中，每一个新增的特性、功能或步骤，都增加了导致用户体验失败的机会。</strong></p>
<ul>
<li>“决定不做什么与决定做什么同样重要”</li>
<li>“全面的东西往往是平庸的”</li>
<li>这与写代码很相似。每增加一行代码都会带来复杂性，保障系统性能、稳定性的难度也会提高。</li>
</ul>
<p><strong>4. 网站是一个自助式的产品，没有可以事先阅读的说明书，没有培训等，用户只能依靠自己的智慧和经验，独自面对这个网站。</strong></p>
<ul>
<li>与真实的物品不同，不好用可以随时退出，丢在一旁或者把弄研究。</li>
<li>但网站不行，用户没办法看到网站全貌(真实的物品可以)，会被困在某个地方甚至迷失在信息的海洋。想想网站那么多功能、分支路径，有谁能记住呢？导致用户体验十分糟糕。</li>
<li>所以导航以及随时退出的功能很重要。</li>
</ul>
<p><strong>5. 用户体验就是商机，如果你的网站很难使用，恐怕你的服务或产品也一样</strong></p>
<ul>
<li>网站的内容必须用一种能帮助人们理解和接受的方式呈现出来</li>
<li>如果用户得到一次不好的体验，他们将不再回来。（要注重口碑，不要随意发布，发布了很多平庸的东西导致口碑下降，少就是多）</li>
</ul>
<p><strong>6. 用户体验对于客户的忠诚度有很大影响</strong></p>
<ul>
<li>可以通过转化率来衡量用户体验上的投入产出比。</li>
<li>任何在用户体验上的努力，都是为了提高效率：帮助人们工作的更快和减少犯错概率。</li>
</ul>
<p><strong>7. 在乎你的用户，以用户为中心的设计</strong></p>
<ul>
<li>考虑涉众的诉求，从涉众角度看问题，优先满足“老大”的利益。</li>
<li>用户体验对你很重要一个最大的理由是：它对你的用户很重要。如果没有给他们一个积极的体验，他们不会使用你的产品。如果没有用户，你租后所得到的只是一台藏在某个角落里、布满了灰尘的网络服务器。对于那些来造访的用户，你必须为他们规划一个有粘性的、直观明了甚至还让人愉快地体验——<strong>一次“没见识都按照正确的方式在工作”的体验，而不管他们这一天的其他时间是如何度过的</strong></li>
</ul>
<h2 id="战略层"><a href="#战略层" class="headerlink" title="战略层"></a>战略层</h2><p>要满足的用户需求和公司的商业目标.<br><img src="/img/16213442096937.jpg" alt="-w656"></p>
<ol>
<li>我们要通过这个产品得到什么</li>
<li>我们的用户要通过这个产品得到什么<br>分别对应产品目标与用户需求</li>
<li><strong>战略应该是设计用户体验流程中的起点，但不意味着在项目开始之前你的战略需要完全确定下来。战略也应该是可以演变和改进的。当战略被系统地修改与校正时，这些工作就能成为贯穿整个过程的持续的灵感源泉</strong></li>
</ol>
<h3 id="产品目标"><a href="#产品目标" class="headerlink" title="产品目标"></a>产品目标</h3><ul>
<li><p>品牌识别：十分重要。<br>无法不被用户注意。在用户与产品交互的同时，企业的品牌形象就不可避免地在用户的脑海中形成了。<br><strong>必须决定品牌形象是无意之中形成的，还是已经过产品设计者有意精心安排的。</strong><br>将品牌形象具体且明确地写进目标，将会提高呈现出积极地品牌形象的机会。</p>
</li>
<li><p>成功标准：一些可追踪的指标，在产品上线以后用来显示他是否满足了我们自己的目标和用户的需求。<br>有时成功标准与网站本身和用户如何使用网站有一定的关系。用户在每一次访问网站时的平均停留时间是多少？如果想要鼓励用户随意轻松地发觉网站，那么一定希望看到单次访问时间增加。相反，如果提供的是快捷键变得信息或功能服务，那么可能希望单次访问时间减少。</p>
</li>
</ul>
<h3 id="用户需求"><a href="#用户需求" class="headerlink" title="用户需求"></a>用户需求</h3><p><strong>用户细分</strong></p>
<ol>
<li>按人口统计学的标准划分用户：性别、年龄、教育水平、婚姻状况、收入等。</li>
<li>人们使用信息的方式经常取决于他们的社会或专业角色。</li>
<li>创建细分用户群的重要原因：不同的用户群有不同的需求，有时这些需求是彼此矛盾的。要么选择单一用户设计而排除其他用户群，要么为执行相同任务的不同用户群提供不同的方法。不论哪一种，这个决策将会影响日后与用户体验相关的每一个选择。</li>
</ol>
<p><strong>用户研究</strong><br>想弄明白用户需要什么，首先知道他们是谁。用户研究的领域致力于收集必要的信息来达成共识。<br>用户研究的方法：</p>
<ol>
<li>问卷调查、用户访谈或焦点小组：适合用于收集用户的普遍观点与感知</li>
<li>用户测试或现场调查：适合用于理解具体的用户行为以及用户在和产品交互时的表现。</li>
</ol>
<p><strong>创建任务角色</strong></p>
<ul>
<li>收集各种各样的用户数据是非常有价值的，但有时候会忽略统计数字背后所代表的真正恩物。通过创建<strong>任务角色</strong>，有时也叫用户模型或用户简介，可以让用户变得更加真实。</li>
<li>人物角色是从用户研究中提取出的可称为样例的虚构人物。</li>
</ul>
<h2 id="范围层"><a href="#范围层" class="headerlink" title="范围层"></a>范围层</h2><p>产品的功能范围，就是具体要做哪些事情？<br><img src="/img/16213442344620.jpg" alt="-w657"></p>
<p>战略层讨论“我们为什么要开发这个产品”，范围层讨论“我们要开发的是什么？”<br>(感觉是用例名称+后置条件)</p>
<p>撰写功能规格说明书的几条原则：</p>
<ol>
<li><p>乐观。描述这个系统将要做什么事情去“防止”不好的情况发生，而不是描述这个系统“不应该”做什么不好的事情。</p>
<blockquote>
<p>例如：<br>原句：“这个系统不允许用户购买没有风筝线的风筝。”<br>修改后：“如果用户想买一个没有线的风筝，这个系统应该引导用户得到风筝线页面。”</p>
</blockquote>
</li>
<li><p>具体：尽可能详细的解释清楚状况。这是决定一个功能是否被实现的最佳途径。</p>
<blockquote>
<p>例如：</p>
<ol>
<li>最受欢迎的视频要重点标注</li>
<li>上一周被播放最多的视频要显示在列表的最前端。</li>
</ol>
</blockquote>
</li>
<li><p>避免主观的语气。</p>
</li>
</ol>
<h2 id="结构层"><a href="#结构层" class="headerlink" title="结构层"></a>结构层</h2><p>页面与页面之间的跳转关系，例如登录完成后，跳转至主页面，还是完善资料页面？<br><img src="/img/16213442562069.jpg" alt="-w651"></p>
<ul>
<li>需求并没有说明如何将分散的片段组成一个整体。结构层为网站创建一个概念结构。</li>
<li>功能型产品在结构层关注交互设计，信息型产品关注 信息架构，但都强调一个重点：<strong>确定各个将要呈现给用户的元素的模式(pattern)和顺序(sequence)。</strong></li>
<li>交互设计关注于将影响用户执行和完成任务的元素。信息架构则关注如何将信息表达给用户的元素</li>
<li><strong>二者都是强调去理解用户，理解用户的工作方式、行为和思考方式。</strong></li>
</ul>
<h3 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h3><p>交互设计关注描述“<strong>可能的用户行为</strong>”，同时定义“系统如何配合与响应”这些用户行为。</p>
<p>它定义了两个或多个互动的个体之间交流的结构和行为。交互设计师致力于在人与产品/服务之间建立一种有效的关系，包括电脑、移动设备、应用等等。-来自[<a href="http://ixda.org]的解释" target="_blank" rel="noopener">http://ixda.org]的解释</a></p>
<p>交互设计师负责网站/App中需要移动的元素和交互。当你在某个网站或者App上面看到某个动画的时候，你可能会说这个真酷，这就是动画设计师的设计成果。</p>
<p>谷歌对交互设计职位的描述：</p>
<p>作为一名交互设计师，你要解决复杂的任务，并且能够把复杂的任务变简单。让来自世界各国的用户（包括菜鸟和熟手）觉得你的设计直观、可用、易用。为达到这样的目标，在整个设计过程中你都要与团队设计师、调研员、工程师、产品经理进行很好的协作（从制作流程图到线框图到原型）。在每一个阶段，你都要预测用户需求，给团队提建议，最终保证产品让用户眼前一亮。</p>
<p>用一句简单粗暴的话来总结以上的名词：用户体检设计（UX）就是用户对App的主观感受；用户界面（UI）就是App里面的元素是什么，放在哪里，如何工作；信息架构（IA)就是App的整体结构；交互设计（IxD）就是用户与产品之间如何交互。</p>
<p><strong>概念模型</strong></p>
<ul>
<li>用户对于“交互组件将怎样工作”的观点称为概念模型(conceptual model)。</li>
<li><strong>软件是否把某个特性处理成用户所熟悉的某个概念？</strong> </li>
<li>规划好概念模型能帮助你做出一致的设计决定。内容元素是一个位置还是对象并不重要，重要的是网站能够将这些元素从头到尾一致地表现出来，而不是有时候将此元素当成位置，有时候有当成对象。</li>
</ul>
<blockquote>
<p>举个例子：<br>“购物车”在典型的电子商务网站概念模型中是一个容器。<strong>这个概念模型同时影响了他的视觉设计和在界面上使用的语言。</strong> 它是一个装东西的容器；作为一个容器，我们“放进东西”到“推车”中，以及从里面“拿出东西”，系统必须提供能完成这些任务的功能。</p>
<p>假设购物车的概念模型是来自现实世界中的另一个实物，譬如“分类订货单”。系统就应该使用“编辑”来代替传统购物车的“添加”与“移除”两个功能，并且用户也应该是“寄出”他们的订单，额不是使用“结账”的比喻来完成购物。</p>
</blockquote>
<ul>
<li>使用人们熟悉的概念模型，会使用户很快适应一个不熟悉的网站。</li>
<li><strong>不必将概念模型明确地告诉用户</strong>。这样做会让用户觉得很混淆，反而无法帮助他们。概念模型适用于在交互设计的开发过程中保持使用方式的一致性。用户在使用网站的时候，基本上是凭直觉的.</li>
<li>将现实世界中相应事物的比喻放入我们的概念模型中，对系统功能的设计可能有一定价值，但更重要的是，不要将比喻从现实中一字不落地照搬过来。</li>
</ul>
<p><strong>错误处理</strong><br>系统出现错误在所难免，系统的错误处理，非常必要。交互设计要处理每一个级别的错误，确保更高比例的用户能有更好的用户体验。</p>
<ol>
<li>最好的方法是防止错误的发生。</li>
<li>使错误难以发生。</li>
<li>为用户提供从错误中恢复的方式。例如，undo功能。</li>
</ol>
<h3 id="信息架构"><a href="#信息架构" class="headerlink" title="信息架构"></a>信息架构</h3><p><strong>信息架构研究的是人们如何认知信息的过程，对于产品而言，信息架构关注的就是呈现给用户的信息是否合理并具有意义。</strong></p>
<p>”信息架构（IA）包括网站、App的结构安排以及内容是如何组织的，目的是帮助用户快速找到信息并且完成操作。换句话说，信息架构就是组织好网站或者App的结构，让用户明白目前所在的位置，知道所找的信息在哪里。信息架构师的工作包括设计网站地图、层次结构、分类、导航和元数据。当内容规划师开始将内容分开并归类的时候，这就是信息架构。设计师通过菜单设计告知用户目前在网站上所处的位置，这也是信息架构“-来自[<a href="http://uxbooth.com]" target="_blank" rel="noopener">http://uxbooth.com]</a></p>
<p><strong>结构化内容</strong></p>
<ol>
<li>从上到下：由战略层驱动，即根据产品目标与用户需求直接进行结构设计。先从最广泛的、有可能满足决策目标的内容与功能开始进行分类，然后再一句逻辑细分出次级分类。这样的“主要分类”与“次级分类”的层级结构就像一个个的空槽，而内容和功能将按顺序一一填入。</li>
<li>从下到上：先从已有资料开始，把这些资料统统放到最低级别的分类中，然后再将他们分别归属到较高一级的类别，从而逐渐构建出能反映我们的产品目标和用户需求的结构。</li>
<li>这两种方法都有局限性。一个适应性强的信息架构系统，能把新内容作为左右结构的一部分纳进来，也可以把新内容当成一个完整的新部分加入。就像树状结构，可以加叶子，也可以在某一层级加完整的子树。</li>
</ol>
<p><strong>成功的用户体验，就是能提前预知用户的期望，并将其纳入到系统的设计之中。</strong></p>
<p><strong>结构方法</strong></p>
<ol>
<li>树状结构。</li>
<li>矩阵结构：允许用户在节点与节点之间沿着两个或更多的“维度”移动。由于每一个用户的需求都可以和距震中的一个“轴”联系在一起，因此<strong>矩阵结构通常能帮助那些“待着不同需求而来”的用户，使他们能在相同内容中寻找各自想要的东西。</strong> 举个例子，如果你的某些用户很想通过颜色来浏览产品，<br>而其他人偏偏希望通过尺寸来浏览，那么矩阵结构就可以同时容纳这两种不同的用户。然而，如果你期望用户把这个当成主要的导航工具，那么超过三个维度的矩阵可能就会出现问题。在四个或更多维度的空间下，人脑基本上不可能很好地可视化这些移动。</li>
<li>自然结构：不遵循任何一指的模式。节点是逐一被连接起来的，同时这种结构没有太强烈的“分类”概念。<strong>自然结构对于探索一系列关系不明确或一直在演变的主题很合适。</strong></li>
<li>线性结构：书、文章、音像和录像全部都被设计成一种现行的体验。<strong>在互联网中线性结构经常被用于小规模的结构，例如单片的文章或单个专题；</strong> 大规模的线性结构则被用于限制那些需要呈现的内容顺序对于符合用户需求非常关键的应用程序，比如教学资料。</li>
</ol>
<p><strong>组织原则</strong></p>
<ol>
<li><strong>产品最高层级使用的组织原则应该紧密地与“网站目标”和“用户需求”相关。而在结构中较低的层级，内容与功能需求将对你采取的组织原则产生重大影响。</strong></li>
</ol>
<p>例如，一个做新闻内容的网站经常以时间顺序作为它最显著的组织原则。实时性对于用户来说是一位重要的因素。</p>
<p>结构的下一个层级是其他与内容紧密相关的因素。以体育新闻网站为例，内容也许被划分为“棒球”“网球”“曲棍球”这样的类别，而更偏向于广泛兴趣的网站也许会有类似“国际新闻”“国内新闻”和“地方新闻”这样的类别。</p>
<ol start="2">
<li><p>任何一种信息收集都有一个固定的概念性结构。实际上，这种概念结构通常不止一个。<strong>我们所面临的困难不是创建一个结构，而是在创建一个能与“我们的目标”和“用户需求”相对应的、正确的结构。</strong></p>
</li>
<li><p>在创建结构时，我们要具体的识别出用户心目中那些至关重要的信息。成功的用户体验，就是能事先预知用户的期望并将其纳入设计之中。</p>
</li>
<li><p>信息架构或交互设计的主要文档是示意图，视觉化地呈现结构。</p>
</li>
</ol>
<ul>
<li>在描述信息结构时，图表应当着重于项目概念的结构和内容的组织。项目概念的结构不同于导航性的结构，设计信息结构的流程图表的目的不是为了说明详细的导航性结构。最好使用其他文档描述导航结构。</li>
<li>在描述交互设计时，需要注重于<strong>描述用户在系统定义好的任务和任务的每个过程中的行动流程</strong>，因此导航条、界面元素等详细信息将不会出现在流程图表中——如果您发现自己在绘制按钮、文字域等元素的时候，可能您已经涉足过分细节的内容了。<br>因此本图示词汇表同时包含信息构架和交互设计的简单的概念模型为基础，用来描述：</li>
<li>系统提供给用户的可行 <strong>路径</strong> ；</li>
<li>用户在所有路径中的 <strong>行为；</strong> </li>
<li>用户行为在系统产生的 <strong>结果</strong> ；<br>详细内容参见：<a href="http://www.jjg.net/ia/visvocab/chinese.html#under" target="_blank" rel="noopener">http://www.jjg.net/ia/visvocab/chinese.html#under</a></li>
</ul>
<p><img src="/img/16213443156231.jpg" alt="-w658"></p>
<h2 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h2><p>多元素布局位置，例如登录、注册按钮放哪里。</p>
<blockquote>
<p>主要解决放置的事情。界面设计考虑可交互元素的布局，导航设计考虑在产品中引导用户移动的元素的安排，信息设计考虑传达给用户的信息要素的排列</p>
</blockquote>
<p><img src="/img/16213443326371.jpg" alt="-w656"><br><img src="http://km.oa.com/files/photos/pictures/202105/1620373013_96_w2004_h956.png" alt="enter image description here"></p>
<h3 id="框架层定义"><a href="#框架层定义" class="headerlink" title="框架层定义"></a>框架层定义</h3><ul>
<li><strong>结构层充满了概念</strong>，在框架层，要更进一步提炼这些结构，确定很详细的界面外观、导航和信息设计，让晦涩的机构变得更实在。</li>
<li><strong>结构层界定了我们的产品将用什么样的方式运作，框架层则用于确定用什么样的功能和形式来实现。</strong></li>
<li><p>框架层还要处理更精确的细节问题。在结构层，我们看到一个较大的架构和交互设计；在框架层，我们的关注点几乎全部在独立的组件以及他们之间的相互关系上。</p>
</li>
<li><p>对于功能型产品，通过<strong>界面设计(interface design)</strong> 来确定框架——一个大家所熟知的、“按钮、输入框和其他界面控件”的领域。</p>
</li>
<li>对于信息型产品，要解决的是一个独一无二的问题：<strong>导航设计(navigation design)</strong>，这是专门用于呈现信息的一种界面形式。</li>
<li><strong>信息设计(information design)</strong> 是功能和信息两方面都必须要做的，它用于呈现有效的信息沟通。</li>
</ul>
<p>这是三种要素是紧密结合在一起。在面对“导航设计”时，首先要考虑“信息设计”是否太过模糊，或者遇到的“信息设计”问题最后变成“界面设计”的问题。</p>
<p><strong>界面设计</strong><br>提供给用户<strong>做某些事</strong>的能力。界面的意思是说，通过它，用户能真正接触到那些“在结构层的交互设计中”确定的“具体功能”。</p>
<p><strong>导航设计</strong><br>提供给用户<strong>去某个地方</strong>的能力。信息架构把一个结构应用到我们设计定好的“内容需求列表”之中；而导航设计则是一个用户能看到那个结构的镜头，通过它，用户可以“在结构中自由穿行”。</p>
<p><strong>信息设计</strong><br><strong>传达想法</strong>给用户。信息设计是这个层面中范围最广的一个要素，所涉及的事情几乎是到目前为止我们在功能型和信息型产品两者都看到过的全部内容。信息设计跨越了“以任务为导向”的功能型产品和“以信息为导向”的信息型产品的边界。因为无论是界面设计还是导航设计，都不可能在没有“一个良好的信息设计的支持”的前提下取得成功。</p>
<h3 id="习惯和比喻"><a href="#习惯和比喻" class="headerlink" title="习惯和比喻"></a>习惯和比喻</h3><p><strong>习惯</strong></p>
<ul>
<li>界面与用户早已养成的习惯保持一致。</li>
<li>更重要的是，界面要与自身保持一致。网站特性的概念模型有助于保持内部一致性。</li>
</ul>
<p><strong>比喻</strong></p>
<ul>
<li>抑制在产品四周建立比喻的冲动。</li>
<li>将产品特性和真实世界曾有的经历建立联想，往往不能解释特性的本质，反而会更加混淆。因为用户不会按照你的联想方式去理解。</li>
<li>网站应该提供一定程度的上下文帮助用户更好的猜测比喻试图代表的特性。但提供的内容和功能越多，猜测就越不可靠。</li>
<li>更好且更简单的做法就是完全去除猜测的成分。</li>
<li>有效地使用比喻，就是要减少用户在“理解和使用你的产品功能”时对猜测的要求。比如，用电话簿图标表示真是的电话号码簿也行行得通，但用一个咖啡店图片代表聊天区域可能就有问题。</li>
</ul>
<h3 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h3><ul>
<li><strong>界面设计要做的全部事情就是选择正确的界面元素。</strong> 这些界面元素要能帮助用户完成他们的任务，还要通过适当的方式让他们容易被理解和使用。</li>
<li><strong>哪个功能要在界面上完成是结构层的交互设计决定的，而这些功能在界面上如何被用户认知到，则属于界面设计的范畴。</strong></li>
<li>成功的界面设计要让用户一眼就看到<strong>最重要的东西</strong>，不重要的东西不应该被注意到。</li>
<li>设计复杂系统的界面的最大挑战之一，是弄清楚用户不需要知道哪些东西，并减少他们的可发现性(甚至完全排除)。<blockquote>
<p>并不是说每一个界面问题的解决办法都是把用户最有可能点击的按钮设计成最大的那个。<br>一个简单的技巧，就是在界面第一次呈现给用户的时候，仔细考虑每一个选项的默认值。<br>另一个更好的做法是能自动记住某个用户最后一次选择状态的系统。</p>
</blockquote>
</li>
</ul>
<h3 id="导航设计"><a href="#导航设计" class="headerlink" title="导航设计"></a>导航设计</h3><p>任何一个导航设计都必须同时完成以下三个目标：</p>
<ol>
<li>必须提供给用户一种在网站间跳转的方法。</li>
<li>导航设计必须传达出这些元素和他们所包含内容之间的关系。（即导航元素之间的关系）<blockquote>
<p>仅仅提供一个链接列表是不够的。这些链接相互之间有什么关系？是否其中一些比别的更重要？他们之间相关的差异在哪？这些传达出来的信息对于用户理解”哪些选择对他们是有效的“是非常必要的。</p>
</blockquote>
</li>
<li>导航设计必须传达出它的内容和用户当前浏览页面之间的关系。其他的那些内容对于我正在浏览的这个页面有什么影响？这些传达出来的信息帮助用户理解“哪个有效的选择会最好的支持他们的任务或他们想要达到的目标”</li>
</ol>
<blockquote>
<p>在物理空间中，人们可以在某种程度上依靠天生的方向感来给自己定位，在信息空间中根本起不到作用。这就是在网站中清晰地告诉用户“他们在哪儿”以及“他们能去哪儿”非常重要的原因</p>
</blockquote>
<p><strong>几种常见的导航系统</strong></p>
<ol>
<li><p>全局导航：全局并不是暗示导航会出现在网站的每一个页面(即使这不算是个坏主意。使用“固定”一词来表示贯穿着整个网站的导航；再次提醒，固定的元素不一定就是全局的)。<strong>全局导航提供的是用户最有可能需要从网站的最终页面到其他什么地方的一组关键点。全局导航的一个经典应用，就是在导航栏放上能到网站所有主要栏目的链接。</strong><br><img src="/img/16213443654855.jpg" alt="-w632"></p>
</li>
<li><p>局部导航：提供给用户在这个架构中到“附近地点”的通路。在一个严格的层次结构中，局部导航可能只提供一个页面的父级、兄弟级和子级通路。如果你的架构反映了用户对这个网站的内容结构的思路，那么局部导航通常比其他导航更有用。<br><img src="/img/16213443824588.jpg" alt="-w628"></p>
</li>
<li><p>辅助导航：提供了全局导航或局部导航不能快速达到的相关内容的快捷途径。允许用户转移浏览时的方向，而不需要从头开始。<br><img src="/img/16213443966660.jpg" alt="-w605"></p>
</li>
<li><p>上下文导航：嵌入页面自身内容的一种导航。这种导航常常没有得到充分利用或应用不当。（类似markdown文章里的导航。）用户需要额外信息的时候，一般是在他们读文本的时候。与其强迫用户扫描右侧的导航元素，还不如放一些相关链接在他正在读的地方。<br><img src="/img/16213444113224.jpg" alt="-w609"></p>
</li>
<li><p>友好导航：提供给用户他们通常不会需要的链接，但他们是作为一种便利的途径来使用的。一些必要信息虽不常用，但很重要，联系信息、反馈表单和法律声明的链接通常放在友好导航中。<br><img src="/img/16213444266980.jpg" alt="-w623"></p>
</li>
<li><p>网站地图：给用户一个简明的、单页的网站整体结构的快捷浏览方式。网站地图通常不会显示超过两个层级的导航，更详细的内容往往超出了用户的需求。</p>
</li>
<li>索引表：按字母顺序排列的、连击刀相关页面的列表。索引表有时为网站的某个部分特别开发，而不是要覆盖整个网站的内容。</li>
</ol>
<h3 id="信息设计"><a href="#信息设计" class="headerlink" title="信息设计"></a>信息设计</h3><p>决定如何呈现信息，使人们能很容易使用或理解。</p>
<ol>
<li>有时信息设计是视觉上的。饼图更好还是柱状图更好？是“望远镜”能表达搜索概念还是“放大镜”更容易理解？</li>
<li>有时信息设计涉及“分组”或“整理”散乱的信息。最关键的是用“反映用户的思路”和“支持他们的任务和目标”的方式分类和排列信息。</li>
<li>信息设计要考虑错误提示。</li>
</ol>
<h3 id="线框图"><a href="#线框图" class="headerlink" title="线框图"></a>线框图</h3><p>线框图是整合在框架层的全部三种要素的方法：</p>
<ul>
<li>通过安排和选择界面元素来整合界面设计</li>
<li>通过识别和定义核心导航系统来整合导航设计</li>
<li>通过放置和排列信息组成部分的优先级来整合信息设计<br>把这三者放到线框图中，可以确定一个建立在基本概念结构上的架构，同时指出了表现层的设计应该前进的方向。</li>
</ul>
<h2 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h2><p>解决并弥补“产品框架层的逻辑排布”的感知呈现问题<br><img src="/img/16213444477042.jpg" alt="-w645"></p>
<p><strong>合理设计感知</strong><br>感受由五个方面组成：</p>
<ol>
<li>视觉</li>
<li>听觉</li>
<li>触觉：工业设计领域的概念</li>
<li>嗅觉</li>
<li>味觉</li>
</ol>
<p><strong>忠于眼睛</strong></p>
<ul>
<li><p>评估一个产品视觉设计的简单方法之一，是提出这样的问题：<strong>你的视线首先落在什么地方？</strong> 哪个设计要素在第一时间吸引了用户的注意力？它们是对于战略目标来讲很重要的东西吗？或者用户第一时间注意到的东西与他们的目标是背道而驰的吗？</p>
</li>
<li><p>如果你的设计是成功的，用户眼睛的移动轨迹应该有两个重要特点：</p>
</li>
</ul>
<ol>
<li>是一条流畅的路径。如果眼睛在各种各样的元素之间跳来跳去，说明设计的不对。</li>
<li>在不需要用太多细节吓倒用户的前提下，它为用户提供有效选择的、某种可能的“引导”。</li>
</ol>
<p><strong>对比一致性</strong></p>
<ul>
<li>在视觉设计中，用于吸引用户注意力的主要工具就是 <strong>对比</strong>。让“差异”必须足够清晰，用户要足够分辨出某个设计厕是特意要传达一些信息的。</li>
<li>设计中保持一致性，使设计有效地传达信息，而不会导致用户迷惑或焦虑。</li>
</ul>
<p><strong>配色方案和排版</strong><br>不要使用非常相似但又不完全一样的风格。</p>
<h2 id="要素的应用"><a href="#要素的应用" class="headerlink" title="要素的应用"></a>要素的应用</h2><ul>
<li>创建良好的用户体验最重要的工作内容是大量收集急需解决的非常细微的问题。</li>
<li><p>“成功的方法”和“注定会失败的方法”的差异归根结底就是以下两点：<br>1.了解你正在去解决的问题<br>2.了解解决办法会造成的后果</p>
</li>
<li><p>与用户体验有关的第一个问题恐怕是问你自己的（这也是你应该回答的第一个问题）：<strong>你为什么要这么做？</strong></p>
</li>
<li>不要以“节省项目时间或金钱”的名义对用户体验的问题敷衍了事。</li>
<li>用户体验测试，不能放到产品开发完成以后，那样已经太晚了。</li>
<li>不管创建什么样的用户体验，其最大的挑战是<strong>“比用户自己更准确地去理解他们的需求”。</strong></li>
<li>用户体验的开发过程，是一场马拉松，而不是短跑，是一个持续改进的过程。</li>
<li>局外人的身份看产品时很容易把关注点放在五层模型中靠近顶部的更显而易见的要素上。但那些最难被感知的要素（战略层、范围层和结构层）在决定用户体验的最终成功或失败方面扮演了必不可少的角色。</li>
<li><strong>上一级层面中的错误有可能会削弱更低层级的正确角色</strong>。在视觉设计上的问题会让用户很快离开，从而永远不会意识到你的导航或交互设计做了很多聪明的选择。</li>
<li><strong>上一级层面上做出的正确决定是建立在第一层级层面的错误决策基础上，那些决定就没有任何意义</strong></li>
</ul>
]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title>王慧文清华产品课</title>
    <url>/2021/03/21/%E7%8E%8B%E6%85%A7%E6%96%87%E6%B8%85%E5%8D%8E%E4%BA%A7%E5%93%81%E8%AF%BE/</url>
    <content><![CDATA[<h2 id="战略"><a href="#战略" class="headerlink" title="战略"></a>战略</h2><h3 id="市场体量"><a href="#市场体量" class="headerlink" title="市场体量"></a>市场体量</h3><ul>
<li>最重要的因素</li>
<li>对市场体量的估算影响投入。<br><strong>投入的合理性取决于对市场体量的判断</strong>。<br>如果判断对了且尽早投入，就获得了战略先机;但判断错了，在一个不够大的市场里投入太多钱，比如共享单车，或者在一个足够大的市场里投入不足，就会掉到坑里。</li>
</ul>
<p>比如外卖，美团一共烧了20亿美金。如果当时按照美国外卖公司GrubHub市值30亿美金估算，就不会投入20亿美金。实际上美团外卖占美团市值1000亿美金。</p>
<a id="more"></a>
<h3 id="规模效应"><a href="#规模效应" class="headerlink" title="规模效应"></a>规模效应</h3><ul>
<li>规模效应是商业世界里的万有引力</li>
<li>哪些生意能做大哪些生意本质上就是做不大是一个非常重要的问题，一个非常重要的要素是规模效应。</li>
<li>规模效应就像万有引力，万有引力足够大的话就会把其他物质吸过来围绕自己转，万有引力小的话有些物质就会越绕越远。</li>
<li>现代生意的规模效应指随着规模增大，成本降低或体验更好</li>
<li>规模效应好，应该是规模越大，竞争对手越少。比如微信；反之，淘宝、外卖并不是，即使做得很大，仍然有竞对。</li>
<li>总的来说，和人的个体的创意关系很大、和人的个体主观能动性关系很大的就没什么规模效应</li>
</ul>
<h4 id="规模效应的形状"><a href="#规模效应的形状" class="headerlink" title="规模效应的形状"></a>规模效应的形状</h4><p><img src="/img/16213445213419.jpg" alt="-w624"></p>
<ol>
<li>A曲线最典型的是网络效应，有网络效应的一个例子是互联网本身，公式是互联网的价值和节点数的平方成正比。有网络效应的生意最典型的例子是社交网络，微信是一个非常典型的网状结构，</li>
<li>B这条线是淘宝，每多一个用户淘宝都能接纳，淘宝就增加一点价值，但用户和用户之间 没啥竞争，所以淘宝的价值是随着规模线性上升的。这解释了很多问题，淘宝做到今天它 的竞争对手是在变多的，淘宝2003年起家，2010年京东发展得很快，现在拼多多发展得很快，你已经做的这么大了还有竞争对手不断进来这就说明了你的规模效应不够强。</li>
<li>C曲线，随着规模的上升，规模到了一个水平后规模效应的增长变缓了，常常是有一些副作用出现了，哪些生意有C曲线的规模效应?有这样曲线的生意一般具有“双边网络且同边负效应”，外卖和淘宝是比较典型的双边网络，它不是完全节点的网络，但不见得所有的双边网络都存在同边负向效应，例如淘宝的供给非常充分接近无限供给，一个用户买一 个商品不会影响另一个用户的购买，但你打个车对旁边的人就是有影响的，司机端也是一 样，单子被抢走了就没了，所以打车就是双边的同边负向竞争。外卖的规模效应比打车稍 好一些，毕竟外卖的同边负效应比较低，商家的服务能力弹性大，配送员也有比较强的拼单能力，但是外卖跟京东比规模效应就弱些。</li>
</ol>
<h4 id="规模效应的scope"><a href="#规模效应的scope" class="headerlink" title="规模效应的scope"></a>规模效应的scope</h4><p>规模效应是在多大的scope里(多大范围内)起作用。</p>
<ul>
<li>比如说全球型的规模效应，就是在中国和在美国有一个用户都会产生正向的用户体验;</li>
<li>如果是一个城市型的规模效应，也就是说你在北京有一个商家和在上海有一个商家，一点关系都没有，这就是城市型的;</li>
<li>有些是全国型的规模效应，有些是蜂窝型的， 蜂窝型的规模效应就终于轮到外卖了。</li>
</ul>
<h4 id="要素的规模效应"><a href="#要素的规模效应" class="headerlink" title="要素的规模效应"></a>要素的规模效应</h4><p>这是做生意最难的，要区分出到底哪些要素是有规模效应的。很多要素之间是博弈的关系的，首先要知道各个 要素之间有博弈，其次你管理能力要强，再次要知道合适的点在哪里，这个点就是试出来的。</p>
<h3 id="马太效应"><a href="#马太效应" class="headerlink" title="马太效应"></a>马太效应</h3><ul>
<li>从众产生马太效应</li>
<li>几乎所有的领域，大部分决策者都没有有效的信息、知识结构和判断方法出独立判断，所 以大家只能依赖专家或者从众因此产生马太效应。所以我们要尽可能抓住有规模效应的要 素，尽可能减少􏰀规模效应，尽快形成马太效应。</li>
</ul>
<h3 id="市场集中度"><a href="#市场集中度" class="headerlink" title="市场集中度"></a>市场集中度</h3><ul>
<li>规模效应、马太效应、􏰂规模效应是 市场集中度的决定性要素</li>
<li>市场体量可以很大，如果市场集中度不够高的话，也产生不了很大的企业，典型的行业是餐饮，尤其是中国的餐饮行业。美国也出了麦当劳这样千亿美金的公司，大行业小企业的例子也是很多的。所以不要觉得这个行业很大就立即大规模投入，因为投资人也会看这个行业能不能出大公司，如果是一个大行业小企业的行业，那也会掉到坑里去。</li>
<li>市场集中度一般用CR，例如CR3表示行业里最大的3家的市占率，比如中国电信行业的CR3 就是100%，这是方法之一。另一个判断方法是去讨论最后剩下几个企业，最后剩下的企业 的数量要么是1家，要么是2家，要么是3家，要么是7家，要么是无数家。</li>
<li>大部分的行业都会剩2-3家，所以要尽快冲到领先的2-3家里，因为不仅你 知道，投资人也知道，如果你不在最前面的2-3家里，投资人就不会给你投钱了。</li>
<li>如果行业里有很多家，所以企业经营的关键战略是 差异化，如果一个行业里只有2、3家，就很难差异化，在传统行业或许还可以，在互联网就很难，除非你假定你遇到了一个很弱的同行。</li>
<li>美团当时的一个策略——我们要确保自己的体量在行业 前三，因为行业最后只会剩2、3家，投资人只会投前三家，此外要做前三里ROI最高的而 不见得体量是最大的。</li>
</ul>
<h3 id="产业链"><a href="#产业链" class="headerlink" title="产业链"></a>产业链</h3><ul>
<li>每个产业链都有链主，链主才是这个行业里生存最好的角色，也在产业变革中是更有主动权的一方。</li>
<li>微笑曲线理论：是一个台湾同胞发明的。在一个产业 里面生存最好的是处在最上游接近核心供应资源和最下游接近消费者的企业。沃尔玛和7- 11就处于最接近消费者的地位。这个理论常见于链条比较长或复杂的行业。</li>
<li>有些行业比较复杂就涉到生态企业。如亚马逊打造的kindle生态，不仅仅是卖书，还涉及到书的发行、初版等。有的行业没有生态，你硬要搞生态就会掉到坑里去，而Amazon做的事都是让整个行业的效率更高。反过来如果做生态能提高效率，那么你要么成为生态建设者，要么加入那个生态成为一员，否则就会被生态淘汰掉。</li>
<li>波特五力模型</li>
</ul>
<h3 id="先发与后发"><a href="#先发与后发" class="headerlink" title="先发与后发"></a>先发与后发</h3><p>后发优势：</p>
<ul>
<li>你不需要去说服很多人了，先发者要去说服很多人的痛 苦是很多人完全不能想象的。</li>
<li>知道这个事情一定能实现。</li>
<li>后发者通常是比较常规的商业思维，而创新者通常思维是很独特，但也因此带来了认知盲区。创新者和后发者的根本差别是创新者通常有思维盲区，而后发者思维盲区会小些。 </li>
</ul>
<h3 id="增量与存量"><a href="#增量与存量" class="headerlink" title="增量与存量"></a>增量与存量</h3><ul>
<li>衡量增量存量的一个标准就是渗透率，比如一天几百万张机票有多少是通过互联网卖出去的，当这个比值超过50%之后市场格局要变就很难了.</li>
<li>在互联网生意里，增量存量的一个影响就是获客成本的差别，不管是打广告还是补贴还是做地推。增量和存量市场的获客成本的差别起码是十倍，这导致进入存量市场单单一个用户获取成本就会导致这个生意不成立。</li>
<li>存量市场也是有机会的，这很大程度上取决于你在多大程度上和第一名做差异化。记住迈克波特三战略:成本领先、差异化、专注。</li>
</ul>
<h3 id="高频低频"><a href="#高频低频" class="headerlink" title="高频低频"></a>高频低频</h3><ul>
<li>高频更有优势</li>
<li>低频也能生存，但要做的很深入如链家、美团餐饮</li>
<li>低频可以与高频结合，如在微信里有外卖、链家的入口</li>
</ul>
<h3 id="入场时机"><a href="#入场时机" class="headerlink" title="入场时机"></a>入场时机</h3><ul>
<li>入场时间很重要，但很难把握</li>
<li>如何判断入场时机：借用马克安德森的结论，如果你相信一件事早晚会发生，你就每3年试一次；老王认为只要没有倒闭，就是早入场比晚入场好，但怎么扛住别倒闭这件事对大公司和小公司都很难。</li>
<li>所有伟大的需求都一定会用错误的方法或在错误的时间点试过很多次。如果你有一个机会是第一次出现的，那么你大概率做了一个错误的事情，如果你不是第一次，那么总有人问你，这个事情很多人做过很多次没做成啊。这就涉到这个时间窗是如何打开的，这是有很多社会、经济、科技等多个基础原因共同作用形成的，在这个宏观分析里有一个叫PEST模型(Political, Economic, Social, Technology)，基本上是这几个大 的要素变化形成了短暂的时间窗口。</li>
<li>经常是技术变化导致了成本和体验可能性的变化。如智能机让很多业务成为可能</li>
<li>从业者的认知变化，正确的认知很难获得，可能要经历多次创业。所以只要能确定公司不倒闭，越早入场越好，因为越早入场你越能积累正确认知，你越可能把握住浪潮。如果有一天创业也好还是在公司内搞个新业务也好，千万不要说兄弟们机会来了这次搞一把大的，那你多半会掉到坑里;你要想着兄弟们我们相信这个领域早晚会成，我们要一直干下去直到这个行业成功。</li>
</ul>
<h3 id="迈克波特三战略"><a href="#迈克波特三战略" class="headerlink" title="迈克波特三战略"></a>迈克波特三战略</h3><p>成本领先(Cost Leadership)、差异化(Differentiation)、聚焦(Focus)。<br>因为互联网的很多特殊性，导致迈克波特的后两个战略有效性下降了</p>
<ul>
<li>注意!迈克波特三战略虽然很经典，但是需要强调一下的是这个三战略毕竟只是“竞争” 的三战略，而竞争只是商业中的一部分，甚至是不大的一部分，所以不能把迈克波特三战 略理解为战略的全部，所以叫做“迈克波特竞争三战略”可能是更准确的。</li>
<li>Leadership理解很大程度上体现了传统商业的特征，也就是同品质商品或服务能生产出来， 只是成本不同而已;但是在互联网时代里只要做不到微信同样的规模，你就做不到微信的 用户体验，因为规模就是微信体验的本身。所以今天再来解读Cost Leadership的话，应该 更新为Cost Leadership或者规模效应导致的Experience Leadership。</li>
<li>Differentiation，在过去商品时代宝马和大众可以差异化为高端与平价的差别，而宝马和奔 驰可以差异化为驾驶与乘坐的差别，但是因为互联网平台的个性化千人千面，我们很难说某个互联网平台是高端或者大众的，所以差异化的空间被大幅挤压。所以在互联网行业要走差异 化路线，很可能需要建设在一个“你的竞争对手组织能力不太强”的假定下才能行得通。(ps：差异化可以有多种如目标用户群里，产品使用方式，全新的产品等)</li>
<li>Focus这个战略也略有这个问题。互联网行业无论是采用Focus还是Differentiation的战略， 要放大这个战略有效性的一个办法是采用竞争对手难以建设的组织能力，比如京东自营电商的组织能力阿里就一直建设不出来，但是也有同行一度企图用Focus来解读跟美团的竞 争，却没有认识到大家组织能力非常相似。</li>
</ul>
<h2 id="strategy-策略-for-product"><a href="#strategy-策略-for-product" class="headerlink" title="strategy(策略) for product"></a>strategy(策略) for product</h2><p>这部分会涉及四个概念，PMF、《创新的扩散》、STP、4P，不要把这四个概念理解的割裂了，他们之间是互相影响互相印证的关系。一个产品或者一个业务最优雅情况下，会 同时符合了这四个概念的理论。</p>
<h3 id="PMF"><a href="#PMF" class="headerlink" title="PMF"></a>PMF</h3><ul>
<li>很多早期公司成败的点就在于是否找到了PMF，不少创业团队没找到PMF却在发力，早早把钱花光了或把信心耗光了;</li>
<li>另外一种错误的行为是找到了PMF却没有发力猛搞;更多的团队是在找PMF的过程中丧失信心散掉了。</li>
<li>找PMF是很难的，后面的《创新的扩散》、STP、4P就是在帮你找到这个PMF</li>
</ul>
<h3 id="创新的扩散"><a href="#创新的扩散" class="headerlink" title="创新的扩散"></a>创新的扩散</h3><p><img src="/img/16213445491897.jpg" alt></p>
<ul>
<li>极少情况下会一个产品各阶段用户的接受速度差不多，毕竟iPhone也是做到第四代才大红大紫，一个产品不太可能在一开始就尽善尽美，有一部分用户在产品还很糙的时候就愿意用，要优先匹配这部分用户的需求，根据STP选择ROI最高的市场和产品。</li>
<li>在产品设计和市场推广的过程中能分清扩散的阶段和匹配扩散阶段设计产品会极大的提高 ROI，当资金、组织能力、研发能力都上来之后再拓展新的人群，提供更好的产品。</li>
<li>不同的人对创新的接受度不一样，有些人是Early Adopter早期接受这个创新的产品，有些人是Early Majority早期大众。这个理论非常重要，如果大家做一个新的产品或一个新的公司，你一定是在创新，你一定要先找到Early Adopter，你要用正确的Segment来找这些人， 无论你做一个多大的市场多通用的产品，你也要在最初的时候有一些Innovator或Early Adopter，否则会因为产品、资源、人力控制不住而失败。</li>
<li>那我们如何去找Innovator或Early Adopter呢?最好的情况是你自己就是Innovator或经常和 Innovator混在一起，典型的就是沃兹和乔布斯，所以他们混在那个群体里，乔布斯是销售 能力最强的人，沃兹是动手能力最强的人。那么如何确定这件事当时有商业机会呢?如果 你自己不在Innovator或Early Adopter那个圈子里，这事的难度就大幅上升了。比如说美团 做to B的餐饮软件产品但公司里没人开过餐饮店，开过餐饮店的人也不会做软件。但也并 不是完全没办法，这个时候要用正确的划分来降低自己找到Innovator或Early Adopter的成本。</li>
<li>比如小米最开始的口号“为发烧􏰃而生”，把最早的种子用户集中到了MI UI论坛里。创新 产品最开始基本上都是为了一小波人而设计的，几乎没有一开始就做所有人群的产品的。</li>
</ul>
<h3 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h3><p>S:Segmenting<br>T:Targeting<br>P:Positioning<br>S是对市场做划分，分成很多块，T是在划分完的市场里选一块作为目标市场，P是市场和产品(供给端)的认知连接。</p>
<p>这是一个很重要的PMF的方法论。</p>
<h4 id="Segmenting"><a href="#Segmenting" class="headerlink" title="Segmenting"></a>Segmenting</h4><p>首先要对市场做划分，要选择正确的坐标系来划分市场，很多事情难解决可能就是坐标系选错了。</p>
<p><strong>坐标系的划分可以有非常多的维度，把哪些要素选入坐标系中，是非常根本性的影响你对这个行业和生意和产品的看法。</strong></p>
<p><strong>做segment不是为了选定最终的市场，而是在选切入点。</strong></p>
<p>使用不重不漏(Mutually exclusive, collectively exhaustive)，来做划分。 事实上如果选对了划分要素去分析，那么很多时候结果会自己呈现。王兴经常说一句话， 如果你分析得足够好，那么决策会自己呈现的。</p>
<p>用不同的划分要素去描述不同的市场，而如果把要素选得过多市场会被分割得太细以至于无法分析了。</p>
<h4 id="Targeting"><a href="#Targeting" class="headerlink" title="Targeting"></a>Targeting</h4><p>绝对不是Segmenting搞完了再搞Targeting这样的流水线作业方式，有时候是Targeting找不到好的目标回过头来重新做Segmenting。T如果找不到可能是S的维度 没找好或者颗粒度不对。</p>
<p><strong>找T的时候，要清楚自己在找切入点还是找目标市场空间</strong>，这个差别是很大的，比如校内网的切入点是校园市场，但目标市场还是所有的人群。</p>
<p><strong>选切入点的时候你要选从长期的维度来看对自己最有利的，长期有利的意思是不存在一个市场机会，你看到了别人没看到</strong>，所以别人也在找机会.你要尽可能避免一种状况就是你选了一个市场机会，别人也选了一个市场机会，各搞了5年之后可能双方发生了交叉竞争的时候发现可能是不平等竞争。</p>
<p><strong>在Targeting的时候，不光要关注市场的大小，还要关注规模效应和速度。</strong></p>
<p>T的选择，不同的市场竞争环境不一样，尤其要警惕你的市场空间选得太大了，同行采用迈克波特竞争三战略里的专注这个战略，切掉你一块的市场就足够养活一家公司，这个时候你就面临了被人肢解的风险。</p>
<p>Targeting这件事看起来很简单，但其应用却千变万化，要考虑的要素非常复杂。所以选择T的时候脑子里要存在着产品设计、想着营销效率、想着组织能力、想着资金效率。</p>
<p>亚马逊是在第一天的时候就真正想过切入点的。亚马逊第一天的时候就要做Everything Store，但切入点选了卖书，这个切入点是非常高明的。一个产品最开始的时候用户一定是畏惧的，行业的基础设施也是不完备的，企业的经营方法和系统 一定是不成形的。书这个品类就很好：</p>
<ol>
<li>SKU足够多，无论你在什么城市总有买不到的书，即便有你可能也不知道在哪</li>
<li>美国的书是非常标准化的</li>
<li>在物流仓储上书这个品类不怕压不过期不怕摔</li>
<li>早期电商购物很怕买到假货，但盗版书里的知识也 是真的</li>
<li>书的客单价不算太高</li>
<li>互联网早期用户大多教育水平比较高，跟买书用户的匹配率很高。<br>从这个选择里就看出了，亚马逊是很高明的。</li>
</ol>
<h4 id="Positioning"><a href="#Positioning" class="headerlink" title="Positioning"></a>Positioning</h4><p>Positioning是对于用户来说，你的产品是什么，用户为什么要选你的产品。有本书叫《定位》，还有本书叫《二十二条商规》，这里面不需要讲太多。</p>
<p>T更偏需求和客户而P更偏供给和产品，高效的营销是能快速把T和P 关联起来的营销。一个to C的产品经理如果不懂营销那么说明这个产品经理还没入门，要 用最低的成本去建立用户认知。</p>
<p>延伸到产品上来讲，做产品非常重要的一件事是为什么要搞产品，这节课花了很多时间在讲战略之类的，没怎么讲如何做产品就是这个原因。只有知道为什么搞这个产品，才能把需求(Needs)解决地犀利，只有知道战略是什么，才能让产品匹配战略。</p>
<h3 id="4P"><a href="#4P" class="headerlink" title="4P"></a>4P</h3><p>Price、Product、Place、Promotion(价格、产品、渠道、推广)。这4P理论有人认为有顺序，有人认为没有，老王倾向于认为有顺序，第一是Price，第二是Product，第三是Place， 第四是Promotion。</p>
<p>对于Place，最好的情况是你的STP和渠道产生了共振，比如开发一款二次元游戏，游戏题材和最后的推广渠道都在Bilibili，那么你的目标用户、游戏题材、推广渠道都高度集中于B站，你的成功率就会大幅上升。</p>
<p>STP对产品、设计、推广有很大的影响。要注意<strong>STP和4P的匹配关系，用STP做完选择之后再分别应用4P。</strong></p>
<p>今天最厉害的一些商业模式是将4P中的某一个挤压为0 进而获得强大的优势，然后在另一个P里赚钱，而互联网的存在大幅地提升了这种可能性。</p>
<p>互联网的常用单位是比特，现实世界常用单位是原子。互联网那些大部分让人难以理解的事情都和比特与原子的差别有关系。比特和原子有很多根本性区别：</p>
<ol>
<li>比特的传输速度比原子快，当前比特的传输速度接近光速，原子要慢很多，把一个原子从美国运到中国 即便是飞机运输也需要12小时。</li>
<li>比特的复制成本比原子低很多，比如我们把1G的片 子复制一次接近0成本，但原子的复制成本就高很多了，比如每多造一辆宝马车成本得几十万吧，在有些领域甚至是否可以原样复制都成问题;</li>
<li>比特是可编程的，原子是不可编程的。</li>
</ol>
<h2 id="strategy-for-Operation"><a href="#strategy-for-Operation" class="headerlink" title="strategy for Operation"></a>strategy for Operation</h2><p>运营和经营相关的Strategy非常复杂，时间原因，只讲分层经营和分类经营。</p>
<h3 id="分层经营"><a href="#分层经营" class="headerlink" title="分层经营"></a>分层经营</h3><h3 id="分类经营"><a href="#分类经营" class="headerlink" title="分类经营"></a>分类经营</h3><h2 id="需求-needs"><a href="#需求-needs" class="headerlink" title="需求(needs)"></a>需求(needs)</h2><ol>
<li>需求不可满足性，不是所有需求都能被满足，且不被满足的需求远大于能被满足的</li>
<li><h2 id="供需关系"><a href="#供需关系" class="headerlink" title="供需关系"></a>供需关系</h2></li>
</ol>
]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title>UML和模式应用</title>
    <url>/2021/03/16/UML%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>书的主要内容：</p>
<ul>
<li>UML和对象思想</li>
<li>OOD的原则和模式：应该如何为对象分配职责？对象之间如何协作？针对这些问题，经过反复验证的解决方案已经被表示成为些最佳实践的原则、启示或模式，即问题-解决方案公示，这些公示是系统化的、典范的设计原则。</li>
<li>案例研究</li>
<li>用例：OOD与需求分析(requirements analysis)具有紧密联系，而在需求分析中通常包含用例的编写。</li>
<li>迭代开发、敏捷建模和敏捷UP</li>
</ul>
<a id="more"></a>
<h2 id="面向对象分析和设计"><a href="#面向对象分析和设计" class="headerlink" title="面向对象分析和设计"></a>面向对象分析和设计</h2><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>OO开发中，至关重要的能力是为软件对象分配职责。掌握对象设计和职责分配的9项基本原则：GRASP</p>
<h3 id="什么是分析和设计"><a href="#什么是分析和设计" class="headerlink" title="什么是分析和设计"></a>什么是分析和设计</h3><p>分析和设计可以概括为：<br><strong>做正确的事(分析)和正确的做事(设计)</strong></p>
<ul>
<li>分析：强调的是对问题和需求的调查研究，而不是解决方案。例如，如果需要一个在线交易系统，那么应该如何使用它？它应该具有哪些功能？<br><strong>“分析”一词含义广泛，最好加以限制，如需求分析(对需求的调查研究)或面向对象分析(对领域对象的调查研究)。</strong></li>
<li>设计：强调的是满足需求的概念上的解决方案(软件方面和硬件方面)，而不是其实现。例如，对数据库方案和软件对象的描述。设计思想通常排斥底层或“显而易见”的细节。最终，设计可以实现，而实现(如代码)则表达了真实和完整的设计。<br>与“分析”相同，“设计”一词也最好加以限制，如面向对象涉及或数据库设计。</li>
</ul>
<h3 id="什么是面向对象分析和设计"><a href="#什么是面向对象分析和设计" class="headerlink" title="什么是面向对象分析和设计"></a>什么是面向对象分析和设计</h3><ul>
<li>面向对象分析(OOA):强调的是在问题领域内发现和描述对象(概念)。例如，在航班信息系统里包含飞机(Plane)、航班(Flight)和飞行员(Pilot)等概念。</li>
<li>面向对象设计(OOD):强调的是定义软件对象以及他们如何协作以实现需求。例如软件对象Plane可以有tailNumber属性和getFlightHistory方法。<br>最后，会实现出来设计的对象，如Java中的Plane类。</li>
</ul>
<h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><p>OOA关注从对象的角度创建领域描述。面向对象分析需要鉴别重要的概念、属性和关联。<br>面向对象分析的结果可以表示为领域模型(domain model)，在领域模型中展示重要的概念或对象。</p>
<p>需要注意：<br><strong>领域模型并不是对软件对象的描述，它使真实世界汇总的概念和想象可视化。因此也被称为概念对象模型(Conceptual Object Model).</strong></p>
<h3 id="分配对象职责"><a href="#分配对象职责" class="headerlink" title="分配对象职责"></a>分配对象职责</h3><p>OOD关注软件对象的定义——对象的协作和职责。序列图(sequence diagram)是描述协作的常见表示法。它展示出软件对象之间的消息流和有消息引起的方法调用。<br>序列图十分重要，消息的指向就是在进行职责分配，通过序列图可以很方便看出对象的职责。</p>
<p>序列图以动态的方式显示对象协作，还可以用 <em>设计类图</em>（design class diagram）来表示类定义的静态视图。这样可以描述类的属性和方法。</p>
<p><strong>领域模型表示的是真实世界的类，设计类图表示的是软件类。</strong><br>尽管设计类图不同于领域模型，但是其中的某些类名和内容还是相似的。从这一方面讲，OO设计和语言能够缩小软件构建和我们所设想的领域模型之间的差距，即实现 <em>低表示差距</em>(lower representiational gap) </p>
<h2 id="迭代、进化和敏捷"><a href="#迭代、进化和敏捷" class="headerlink" title="迭代、进化和敏捷"></a>迭代、进化和敏捷</h2><h3 id="敏捷建模"><a href="#敏捷建模" class="headerlink" title="敏捷建模"></a>敏捷建模</h3><blockquote>
<p>建模的目的主要是为理解，而非文档。</p>
</blockquote>
<p>建模能够对理解问题或解决方案提供更好的方式。实行OOA/D的目的并不是让设计者创建大量详细的UML图交给编程者,而是为良好的OOD快速探索可选的方案和途径。</p>
<h3 id="什么是UP阶段"><a href="#什么是UP阶段" class="headerlink" title="什么是UP阶段"></a>什么是UP阶段</h3><blockquote>
<p>up倡导的核心思想：短时间定量迭代、进化和可适应性开发。</p>
</blockquote>
<ol>
<li>初始(Inception)：大体上的构想、业务案例、范围和模糊评估</li>
<li>细化(Elaboration)：已精化的构想、和新架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估</li>
<li>构造(Construction)：对遗留下来的风险较低和比较简单的元素进行迭代实现，准备部署。</li>
<li>移交(Transition)：进行beta测试和部署<h3 id="UP科目"><a href="#UP科目" class="headerlink" title="UP科目"></a>UP科目</h3></li>
</ol>
<ul>
<li>业务建模：领域模型制品，使应用领域中的重要概念的可视化。</li>
<li>需求：用以补货功能需求和非功能需求的用例模型机器补充性的规格说明制品。</li>
<li>设计：设计模型制品，用于对软件对象进行设计。<br><img src="/img/16213446274566.jpg" alt></li>
</ul>
<p><img src="/img/16213446351071.jpg" alt></p>
<h2 id="OOA-领域模型"><a href="#OOA-领域模型" class="headerlink" title="OOA:领域模型"></a>OOA:领域模型</h2><p>领域模型是OOA最重要的模型，阐述领域中的重要概念。<br>领域模型可以作为设计某些软件对象的灵感来源，也作为其他产出物的输入：<br><img src="/img/16213446468416.jpg" alt></p>
<blockquote>
<p>领域模型是对领域内的概念类或现实世界中对象的可视化表示[MO95,Fowler96].领域模型也成为概念模型、领域对象模型和分析对象模型。</p>
</blockquote>
<p>在UP中，领域模型指的是对现实世界概念类的表示，而非软件对象的表示。该术语并不是指用来描述软件类、软件架构领域层或职责软件对象的一组图。</p>
<h3 id="领域模型和数据模型是一回事吗？"><a href="#领域模型和数据模型是一回事吗？" class="headerlink" title="领域模型和数据模型是一回事吗？"></a>领域模型和数据模型是一回事吗？</h3><p>领域模型不是数据模型。<br>在领域模型里，即使需求没要求记录相关信息的类 也可能出现在领域模型中。</p>
<h3 id="为什么要创建领域模型"><a href="#为什么要创建领域模型" class="headerlink" title="为什么要创建领域模型"></a>为什么要创建领域模型</h3><ol>
<li>面向对象的关键思想：领域层软件类的名称要源于领域模型中的名称，使对象具有源于领域的信息和职责。有助于减小人的思维与软件模型之间的差异。<br><img src="/img/16213446617898.jpg" alt></li>
</ol>
<ol start="2">
<li>方便变更与扩展</li>
<li>管理和隐藏复杂性</li>
</ol>
<h3 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h3><h4 id="准则：如何创建领域模型"><a href="#准则：如何创建领域模型" class="headerlink" title="准则：如何创建领域模型"></a>准则：如何创建领域模型</h4><ol>
<li>寻找概念类</li>
<li>将其绘制为UML类图中的类</li>
<li>添加关联和属性</li>
</ol>
<h4 id="准则：如何寻找概念类"><a href="#准则：如何寻找概念类" class="headerlink" title="准则：如何寻找概念类"></a>准则：如何寻找概念类</h4><ol>
<li>复用和修改已有的领域模型(最好的做法)</li>
<li>使用分类列表：先分类，然后往对应的分类中添加名词。</li>
<li>确定名词短语：从对领域的文本性描述(如用例、专业书籍、专家的想法等)中识别名次和名词短语，将其作为候选的概念类或属性。缺点在于自然语言不精确性，不同名词短语可能表示统一概念类或属性，还可能有歧义。建议与分类列表一起使用</li>
</ol>
<h4 id="准则：使用领域术语"><a href="#准则：使用领域术语" class="headerlink" title="准则：使用领域术语"></a>准则：使用领域术语</h4><ol>
<li>以地图绘制者的思维创建领域模型，使用地域中现有名称。如图书馆模型，将顾客命名为“借书者”。</li>
<li>排出无关或超出范围的特性。当前迭代没有的特性可以不在模型中表示。</li>
<li>不要凭空增加事物</li>
</ol>
<h4 id="准则：属性与类的常见错误"><a href="#准则：属性与类的常见错误" class="headerlink" title="准则：属性与类的常见错误"></a>准则：属性与类的常见错误</h4><p>创建领域模型时最常见的错误是把应该是概念类的事物表示为属性。<br>避免这类错误的方法：<br><strong>如果我们认为某概念类X不是现实世界中的数字或文本,那么X可能是概念类而不是属性。</strong></p>
<h4 id="准则：何时使用“描述”类建模"><a href="#准则：何时使用“描述”类建模" class="headerlink" title="准则：何时使用“描述”类建模"></a>准则：何时使用“描述”类建模</h4><p>描述类(description class) 包含描述其他事物的信息，如ProductDescription记录item的价格、图片和文字描述。</p>
<ol>
<li>需要有关商品或服务的描述，对于任何商品或服务的现有实例。</li>
<li>删除其所有事物的实例后，导致信息丢失，而这些信息是需要维护的。</li>
<li>减少冗余或重复信息</li>
</ol>
<h4 id="准则：有下列情况时创建子类；"><a href="#准则：有下列情况时创建子类；" class="headerlink" title="准则：有下列情况时创建子类；"></a>准则：有下列情况时创建子类；</h4><ol>
<li>子类具有我们感兴趣的额外属性</li>
<li>子类具有我们感兴趣的额外关联</li>
<li>对子类的影响、处理、反应和操作与超类或其他子类有显著差异。</li>
<li>子类概念表示了一个活动体(如动物、机器人等),其行为与超类或者其他子类不同，而这些行为是我们所关注的。</li>
</ol>
<h4 id="准则：何时定义超类"><a href="#准则：何时定义超类" class="headerlink" title="准则：何时定义超类"></a>准则：何时定义超类</h4><ol>
<li>潜在的概念子类表示的是相似概念的不同变体。</li>
<li>子类满足100%和Is-a规则。</li>
<li>所有子类都具有相同的属性，可以放在超类中表达。</li>
<li>所有子类都具有相同的关联，可以剑气解析出来与超类关联。</li>
</ol>
<h4 id="准则：不要讲概念X的状态建模为X的子类"><a href="#准则：不要讲概念X的状态建模为X的子类" class="headerlink" title="准则：不要讲概念X的状态建模为X的子类"></a>准则：不要讲概念X的状态建模为X的子类</h4><p>有两种可选方案：</p>
<ol>
<li>新建 状态类，并与X关联</li>
<li>领域模型中忽略状态的概念，在状态图中显示。<br><img src="/img/16213447211081.jpg" alt></li>
</ol>
<h4 id="准则：在领域模型中增加关联类的可能线索"><a href="#准则：在领域模型中增加关联类的可能线索" class="headerlink" title="准则：在领域模型中增加关联类的可能线索"></a>准则：在领域模型中增加关联类的可能线索</h4><ol>
<li>有某个属性与关联相关</li>
<li>关联类的实例具有依赖于关联的生命周期</li>
<li>两个概念之间有多对多关联，并且存在与关联自身相关的信息。</li>
</ol>
<h4 id="准则：下列情形可以使用组合关系"><a href="#准则：下列情形可以使用组合关系" class="headerlink" title="准则：下列情形可以使用组合关系"></a>准则：下列情形可以使用组合关系</h4><ol>
<li>部分的生命期在组合的生命期界限之内，部分的创建和删除依赖于整理。</li>
<li>在屋里或者逻辑组装上，整体-部分关系和明确。</li>
<li>组合的某些属性(如位置)会传递给部分。</li>
<li>对组合的操作(如销毁，移动和记录等)可能传递给部分。</li>
</ol>
<p>组合关系意味着：</p>
<ul>
<li>在某一时刻，部分的实例只属于某一个组合实例</li>
<li>部分必须总是属于组合。</li>
<li>组合要负责创建和删除其部分。</li>
</ul>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>关联(association)是类之间的关系，表示有意义和指的关注的连接。</p>
<h4 id="准则：何时表示关联"><a href="#准则：何时表示关联" class="headerlink" title="准则：何时表示关联"></a>准则：何时表示关联</h4><p>关联表示了需要持续一旦时间的关系，根据语境，可能是毫秒或数年。需要记录哪些对象之间的关系？<br>领域模型是从概念角度出发的，所以是否需要记录关联，要基于现实世界的需要而不是软件的需要。</p>
<h4 id="准则：为什么应该避免加入大量关联"><a href="#准则：为什么应该避免加入大量关联" class="headerlink" title="准则：为什么应该避免加入大量关联"></a>准则：为什么应该避免加入大量关联</h4><p>关联太多会产生“视觉干扰”，使图变得混乱。重点关注“需要记住”的关联</p>
<h4 id="观点：关联是否会在软件中实现"><a href="#观点：关联是否会在软件中实现" class="headerlink" title="观点：关联是否会在软件中实现"></a>观点：关联是否会在软件中实现</h4><p>关联不是关于数据流、数据库外键联系、实例变量或软件方案中的对象连接的语句；关联声明的是针对现实，领域从纯概念角度看有意义的关系。<br>这些关系大部分将作为设计模型和数据模型中的导航和可见性路径在软件中实现。但是领域模型不是数据模型，添加关联是为了突出我们对重要关系的大致理解，而非记录对象或数据的结构。</p>
<h3 id="多重性"><a href="#多重性" class="headerlink" title="多重性"></a>多重性</h3><p>多重性(multiplicity)定义了类A有多少个实例可以和类B的一个实例关联。<br>两个类可能有多重关联，应当分别表示。如航班和机场的关系，一个机场有多个航班，但可以继续区分为飞来的航班，和离开的航班<br><img src="/img/16213447369902.jpg" alt></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性(attribute)是对象的逻辑数据值</p>
<h4 id="准则：何时展示属性"><a href="#准则：何时展示属性" class="headerlink" title="准则：何时展示属性"></a>准则：何时展示属性</h4><p>当需求建议或暗示需要记住信息时，引入属性。</p>
<h4 id="准则：什么样的属性是适当的"><a href="#准则：什么样的属性是适当的" class="headerlink" title="准则：什么样的属性是适当的"></a>准则：什么样的属性是适当的</h4><ol>
<li>关注领域模型中的数据类型属性：大部分应该是“简单”数据类型，如数字、布尔等。通常，属性的类型不应该是复杂的领域概念。</li>
<li>通过关联而不是属性表达概念之间的关系</li>
<li>领域模型中建议属性主要是基本数据类型，并不意味着java对象中的属性也是基本数据类型。因为领域模型是概念透视图，不是软件透视图。在设计模型中，属性可以是任何类型。</li>
</ol>
<h4 id="准则：何时定义新的数据类型"><a href="#准则：何时定义新的数据类型" class="headerlink" title="准则：何时定义新的数据类型"></a>准则：何时定义新的数据类型</h4><p>需要把最初认为是数字或字符串的数据类型表示为新的数据类型类：</p>
<ul>
<li>有不同的小节组成，如电话号码、人名</li>
<li>具有与之相关的操作，例如解析或校验。如社会安全号</li>
<li>具有其他属性。如促销价格有开始日期和结束日期</li>
<li>单位的数量。如支付金额有货币单位</li>
<li>具有以上性质的一个或多个类型的抽象。</li>
</ul>
<h4 id="准则：任何属性都不表示外键"><a href="#准则：任何属性都不表示外键" class="headerlink" title="准则：任何属性都不表示外键"></a>准则：任何属性都不表示外键</h4><ul>
<li>领域模型中的属性不应该用于表示概念类的关系。</li>
<li>使用关联而不是属性将类型关联起来。</li>
</ul>
<h4 id="准则：对数量和单位建模"><a href="#准则：对数量和单位建模" class="headerlink" title="准则：对数量和单位建模"></a>准则：对数量和单位建模</h4><p>大部分用数字表示的数量不应该表示为纯数字。比如价格是13，重量是37，并不能说明是元还是千克。<br>应当给这些数量加上单位，并且还需要知道单位之间的转换关系。</p>
<h3 id="结论：领域模型是否正确"><a href="#结论：领域模型是否正确" class="headerlink" title="结论：领域模型是否正确"></a>结论：领域模型是否正确</h3><p>没有所谓唯一正确的领域模型。所有模型都是对试图要理解的领域的近似。领域模型主要是在特定群体中用于理解和沟通的工具。<br><strong>有效的领域模型捕获了当前需求语境下的本质抽象和理解领域所需要的信息，并且可以帮助人们理解领域的概念、术语和关系。</strong></p>
<h2 id="OOD"><a href="#OOD" class="headerlink" title="OOD"></a>OOD</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul>
<li>逻辑架构(logical architecture):软件类的宏观组织结构，将软件类组织为包(或命名为空间)、子系统和层等。之所以称其为逻辑架构，是因为并未决定如何在不同的操作系统进程或网络中物理的计算机上对这些元素进行部署。</li>
<li>软件架构：架构是一组重要决策，其中设计软件系统的组织，对结构元素及其组成系统所籍接口的选择，这些元素特定于其相互协作的行为，这些结构和行为元素到规模更大的子系统的组成，以及指导该组织结构(这些元素及其接口、协作和组织)的架构风格。</li>
</ul>
<p>不管是哪种定义，所有软件架构定义的共同主题是，必须与宏观事物有关——动机、约束、组织、模式、职责和系统指连接(或系统之系统)的重要思想。</p>
<ul>
<li>层(layer)：对类、包或子系统的粗粒度分组，具有对系统主要方面加以内聚的职责。”较高”层可以调用”较低”层，反之不能。OO系统中常见的分层：<ul>
<li>用户界面</li>
<li>应用逻辑和软件对象</li>
<li>技术服务：提供支持性技术服务的常用对象和子系统，例如蜀葵恶寇或错误日志。这些服务通常是独立于应用的，也可在多个系统复用。<br><img src="/img/16213447510519.jpg" alt></li>
</ul>
</li>
</ul>
<ul>
<li>分层架构解决的问题：<ul>
<li>大部分系统是高度耦合的，代码变更会波及整个系统</li>
<li>应用逻辑与用户界面耦合，应用逻辑部分无法复用</li>
<li>一般性技术服务与应用逻辑耦合，不能复用</li>
<li>不同关注领域之间的耦合，难以为不同开发人员清晰地界定和分配任务</li>
</ul>
</li>
</ul>
<h3 id="设计对象"><a href="#设计对象" class="headerlink" title="设计对象"></a>设计对象</h3><p>对象模型有两种类型：动态和静态。</p>
<ul>
<li>动态建模有助于设计逻辑、代码行为或方法体，使用顺序图。</li>
<li>静态建模有助于设计包、类名、属性和方法特征标记的定义，使用类图。</li>
<li>两者的关系：并行进行，花费较短的时间创建顺序图，然后转到对应的类图，交替进行。</li>
<li>应当把时间花在序列图上，而不仅是类图。</li>
</ul>
<h3 id="序列图"><a href="#序列图" class="headerlink" title="序列图"></a>序列图</h3><p>不展开讲</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><strong>依赖</strong><br>UML中的普通依赖表示：客户(client)元素（任何种类，包括类、包、用例等）了解其他的提供者元素（supplier）,并且表示党提供者有所改变时会对客户产生影响。<br>依赖关系比较常见的类型：</p>
<ol>
<li>拥有提供者类型的属性</li>
<li>向提供者发送消息</li>
<li>接收提供者类型的参数</li>
<li>提供者是超类或接口<br>所有这些类型在UML中都可以用依赖线表示。但其中有些类型已经有了暗示依赖的特殊线条表示法。如表示超类的特殊UML线、表示接口实现的线、表示属性的线。所以这些情形不需要使用依赖线。</li>
</ol>
<p>何时表示依赖？<br><strong>在类图中，使用依赖线描述对象之间的全局变量、参数变量、局部变量和静态方法(对其他类的静态方法加以调用)的依赖</strong></p>
<p><strong>组合优于聚合</strong><br>组合关系有几层含义：</p>
<ol>
<li>在某一时刻，部分的实例只属于一个组成实例</li>
<li>部分必须总是属于组成</li>
<li>组成要负责创建和删除其部分，既可以自己来创建/删除部分，也可以与其他对象协作来创建/删除部分。与该约束相关的是，如果组成被销毁，部分也必须被销毁，或者依附于其他组成。</li>
</ol>
<h2 id="OOA与OOD的产出物"><a href="#OOA与OOD的产出物" class="headerlink" title="OOA与OOD的产出物"></a>OOA与OOD的产出物</h2><p><strong>OOA产出物</strong></p>
<ul>
<li>领域模型</li>
<li>系统顺序图SSD(感觉是业务序列图)</li>
<li>操作契约(用例) P133</li>
<li>状态模型 P133</li>
</ul>
<p><strong>OOD产出物</strong></p>
<ul>
<li>逻辑架构（包图）</li>
<li>对象序列图</li>
<li>类图</li>
<li>UI的草图和原型</li>
<li>数据库模型</li>
<li>报表的草图和原型<br><img src="/img/16213448515627.jpg" alt></li>
</ul>
<h2 id="GRASP-基于职责设计对象"><a href="#GRASP-基于职责设计对象" class="headerlink" title="GRASP:基于职责设计对象"></a>GRASP:基于职责设计对象</h2><p>OOD之前的输入：<br><img src="/img/16213447921708.jpg" alt></p>
<ul>
<li>用例</li>
<li>序列图</li>
<li>领域模型</li>
</ul>
<p>RDD(职责驱动设计):把软件对象想象成具有某种职责的人，他要与其他人协作以完成工作。RDD使我们把OO设计看作是有职责对象进行协作的共同体。</p>
<p>GRASP对一些基本的职责分配原则进行了命名和描述，因此掌握这些原则有助于支持RDD。</p>
<p>如何给对象分配职责？绘制序列图就是在分配职责。GRASP指导分配职责时可做的选择。</p>
<p>职责分为两种：行为和认知</p>
<h3 id="行为职责"><a href="#行为职责" class="headerlink" title="行为职责"></a>行为职责</h3><ol>
<li>自身执行一些行为，如创建对象或计算</li>
<li>初始化其他对象中的动作</li>
<li>控制和协调其他对象中的活动</li>
</ol>
<h3 id="认知职责"><a href="#认知职责" class="headerlink" title="认知职责"></a>认知职责</h3><ol>
<li>对私有封装数据的认知</li>
<li>对相关对象的认知</li>
<li>对其能够导出或计算的事物的认知</li>
</ol>
<p>领域模型描述领域对象的属性和关联，通常产生与“认知”相关的职责。</p>
<h3 id="创建者"><a href="#创建者" class="headerlink" title="创建者"></a>创建者</h3><p>问题：谁创建对象A<br>方案：</p>
<ol>
<li>B“包含”或组成聚集了A</li>
<li>B记录A</li>
<li>B紧密地使用A</li>
<li>B具有A的初始化数据<br>以上条件之一为真(越多越好),将创建职责分配给B。</li>
</ol>
<h3 id="信息专家"><a href="#信息专家" class="headerlink" title="信息专家"></a>信息专家</h3><p>问题：给对象分配职责的基本原则是什么<br>方案：把职责分配给具有完成该职责所需信息的那个类。</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>问题：首先接收UI层消息、协调系统操作的对象是什么？<br>方案：把职责分配给能代表下列选择之一的对象：</p>
<ol>
<li>代表全部“系统”、“根对象”、运行软件的设备或主要的子系统（外观控制器(facade controller)的变体）</li>
<li>代表发生系统操作的用例场景<br>正常情况下，控制器应当把需要完成的工作委派给其他对象。控制器知识协调或控制这些活动，本身并不完成大量工作。</li>
</ol>
<h3 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h3><p>问题：怎样降低依赖性，减少变化带来的影响<br>方案：分配职责，是耦合性尽可能低。利用这一原则来评估可选方案。</p>
<h3 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h3><p>问题：怎样保持对象是有重点的、可理解的、可管理的，并且能够支持低耦合？<br>内聚是对元素职责的相关性和集中度的度量。如果元素具有高度相关的职责，而且没有过多工作，那么该元素具有高内聚性。<br>方案：分配职责可保持较高的内聚性，利用这点来评估候选方案。<br>内聚性低会导致的问题：</p>
<ol>
<li>难以理解</li>
<li>难以服用</li>
<li>难以维护</li>
<li>错误，经常会受到拜年话影响。<br>内聚性低的类通常表示大粒度的抽象，或承担了本应委托给其他对象的职责。</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>问题：如何处理基于类型的选择？如何创建可插拔的软件构件？<br>方案：使用多态操作为变化的行为类型分配职责。</p>
<h3 id="纯虚构"><a href="#纯虚构" class="headerlink" title="纯虚构"></a>纯虚构</h3><p>问题：不想违背高内聚和低耦合或其他目标，但是基于专家模式所提供的方案又不合适时，哪些对象应该承担这一职责？<br>方案：对人为制造的类分配一组高内聚的职责，该类并不代表问题领域的概念——虚构的事务，泳衣支持高内聚、低耦合。<br>例子：order对象存到db，按照专家模式，order对象应该负责与db的连接。但不满足高内聚、低耦合，引入虚构的dao对象负责存储。</p>
<h3 id="间接性"><a href="#间接性" class="headerlink" title="间接性"></a>间接性</h3><p>问题：为了避免两个或多个事物之间直接耦合，应该如何分配职责？如何使对象解耦合，以支持低耦合并提高复用性？<br>方案：将职责分配给中介对象，使其作为其他构件或服务之间的媒介，以避免他们直接耦合。</p>
<h3 id="防止异变"><a href="#防止异变" class="headerlink" title="防止异变"></a>防止异变</h3><p>问题：如何设计对象、子系统和系统，使其内部的变化或不稳定性不会对其他元素产生不良影响？<br>方案：识别预计变化或不稳定之处，分配职责用以在这些变化之外创建稳定接口。“接口”指的是广泛意义上的访问视图，而不仅仅是诸如Java接口等字面含义。</p>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>做产品的框架</title>
    <url>/2021/02/22/%E4%BA%A7%E5%93%81%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="产品需求从哪里来"><a href="#产品需求从哪里来" class="headerlink" title="产品需求从哪里来"></a>产品需求从哪里来</h2><ol>
<li>马斯洛需求层次</li>
<li>七宗罪：暴食、懒惰、贪婪、淫欲、愤怒、嫉妒、骄傲</li>
</ol>
<a id="more"></a>
<h3 id="关于机会的判断"><a href="#关于机会的判断" class="headerlink" title="关于机会的判断"></a>关于机会的判断</h3><ol>
<li>痛点：痛点是恐惧</li>
<li>痒点：痒点是满足虚拟自我(想象中那个理想的自己)</li>
<li>爽点：爽点是快速获得，即时满足</li>
</ol>
<h3 id="需求分析法：卡诺-KANO-模型"><a href="#需求分析法：卡诺-KANO-模型" class="headerlink" title="需求分析法：卡诺(KANO)模型"></a>需求分析法：卡诺(KANO)模型</h3><p>根据不同类型的需求与⽤户满意度之间的关系，可将需求分为五类：基本型需求、期望型需求、兴奋型需求、⽆差异需求、反向型需求。<br><img src="https://km.woa.com/files/photos/pictures/202105/1621157473_52_w972_h470.png" alt="enter image description here"></p>
<table>
<thead>
<tr>
<th>需求类型</th>
<th>备注</th>
<th>如果实现</th>
<th>如果不实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本型需求</td>
<td>MVP</td>
<td>用户满意度 提升不明显</td>
<td>用户满意度 大大下降</td>
</tr>
<tr>
<td>期望型需求</td>
<td>竞争优势</td>
<td>用户满意度 提升</td>
<td>用户满意度 下降</td>
</tr>
<tr>
<td>兴奋型需求</td>
<td>提升忠诚度</td>
<td>用户满意度 大大提升</td>
<td>用户满意度 不降低</td>
</tr>
<tr>
<td>无差异需求</td>
<td>——</td>
<td>用户满意度 不提升</td>
<td>用户满意度 不提升</td>
</tr>
<tr>
<td>反向型需求</td>
<td>——</td>
<td>用户满意度 降低</td>
<td>用户满意度 提升</td>
</tr>
</tbody>
</table>
<h3 id="需求优先级如何确定？"><a href="#需求优先级如何确定？" class="headerlink" title="需求优先级如何确定？"></a>需求优先级如何确定？</h3><ol>
<li>基础型&gt;期望型&gt;兴奋型&gt;⽆差异型</li>
<li>相同分类的需求，Better值越⼤，优先级越⾼</li>
</ol>
<h3 id="如何得到better值？"><a href="#如何得到better值？" class="headerlink" title="如何得到better值？"></a>如何得到better值？</h3><p>使⽤KANO模型可通过标准化问卷的⽅式进⾏需求调研问卷题⽬的设计，如下：</p>
<ul>
<li>问卷中的每⼀道题⽬都要设计正反两⾯。</li>
<li>关于选项的说明：<br>⾮常喜欢：让你感到满意、开⼼、惊喜<br>理应如此：你觉得是应该的，必备的功能/服务<br>⽆所谓：⽆所谓喜不喜欢，都可以接受<br>勉强接受：你不喜欢，最好是没有，有的话勉强凑合<br>很不喜欢：让你感到不开⼼甚⾄沮丧，⽆法接受。</li>
</ul>
<p><img src="https://km.woa.com/files/photos/pictures/202105/1621157566_10_w982_h459.png" alt="enter image description here"></p>
<p>下图是问卷题⽬的评分对应表：<br><img src="https://km.woa.com/files/photos/pictures/202105/1621157591_86_w981_h571.png" alt="enter image description here"><br>A: 兴奋型<br>O: 期望型<br>M: 基础型<br>I：无差异型<br>R: 反向型<br>Q: 可以结果<br>统计所有的合理数据，计算出各项的占⽐，数据最大的就是该需求的分类。<br>注：“通讯录中的拨打电话功能”这个需求的分类是：兴奋型36.6%，如果提供此功能，⽤户满意度⼤⼤提升，如果不提供此功能，⽤户满意度不降低</p>
<p><img src="https://km.woa.com/files/photos/pictures/202105/1621157609_7_w900_h703.png" alt="enter image description here"></p>
<p>如果涉及多个需求的优先级排序，需要计算better-worse系数<br>Better=(A+O)/(A+O+M+I)<br>提供某功能以后的满意系数，正值。值越⼤（接近1），对⽤户的满意度影响越⼤<br>Worse=-1*(O+M)/(A+O+M+I)<br>移除某功能以后的不满意系数，负值。值越⼤（接近-1），对⽤户的不满意度影响越⼤<br><img src="https://km.woa.com/files/photos/pictures/202105/1621157657_58_w955_h699.png" alt="enter image description here"></p>
<h2 id="为什么要实现这些需求"><a href="#为什么要实现这些需求" class="headerlink" title="为什么要实现这些需求"></a>为什么要实现这些需求</h2><p>产品的商业价值以及关于产品设计的顶层思考。<br>点：个体努⼒所能换来的回报，单点的业务突破。<br>线：将有价值的个体串联起来，注重线性优化。<br>⾯：开放的协同⽹络，对传统的供应链是典型的降维打击。打开传统供应链中的封闭结构，纳⼊更多的点。讲好⼀个平台的故事：淘宝、拼多多、滴滴、美团、携程、⽠⼦⼆⼿⻋<br>体：在“⾯”扩张的过程中衍⽣出更多的“⾯”，进⽽形成经济体。千亿美元市值公司应该考虑的问题（阿⾥）。<br>Q1思考：当你想要做⼀个新产品的时候，最好从什么⼊⼿（点/线/⾯/体）？<br>Q2思考：为什么跟谁学做O2O(2014)失败了、做B2C⽹校(2018)反⽽却成功了？</p>
<h3 id="产品设计的顶层思考：波特三种竞争战略"><a href="#产品设计的顶层思考：波特三种竞争战略" class="headerlink" title="产品设计的顶层思考：波特三种竞争战略"></a>产品设计的顶层思考：波特三种竞争战略</h3><table>
<thead>
<tr>
<th>战略</th>
<th>英文</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>成本领先战略</td>
<td>Cost Advantage</td>
<td>价格敏感型；规模经济；供应链优化；</td>
</tr>
<tr>
<td>差异化战略</td>
<td>Differentiation</td>
<td>独特的产品；忠诚的客户关系；持续创新能力；</td>
</tr>
<tr>
<td>细分市场战略</td>
<td>Segmentation</td>
<td>细分的市场；聚焦的目标客户群体；小池里的大鱼；</td>
</tr>
</tbody>
</table>
<p>思考：在你的⽇常⼯作⽣活中，有哪些场景是在不⾃觉地采⽤这三种思维模型的？</p>
<h3 id="产品设计的顶层思考：迈尔斯和斯诺分析模型"><a href="#产品设计的顶层思考：迈尔斯和斯诺分析模型" class="headerlink" title="产品设计的顶层思考：迈尔斯和斯诺分析模型"></a>产品设计的顶层思考：迈尔斯和斯诺分析模型</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>探索者</td>
<td>Prospector</td>
<td>痴迷于增长，高风险倾向，颠覆性创新</td>
</tr>
<tr>
<td>分析者</td>
<td>Analyzer</td>
<td>快速跟进者，像素级模仿与微创新，成本更低/产品更好</td>
</tr>
<tr>
<td>防御者</td>
<td>Defender</td>
<td>成熟市场，稳定的市场份额，对金品敏感，长期规划</td>
</tr>
<tr>
<td>回应者</td>
<td>Reactor</td>
<td>无法控制企业的外部环境，被动做出响应和改变</td>
</tr>
</tbody>
</table>
<h3 id="产品设计的顶层思考：波士顿矩阵-BCGMatrix-分析法"><a href="#产品设计的顶层思考：波士顿矩阵-BCGMatrix-分析法" class="headerlink" title="产品设计的顶层思考：波士顿矩阵(BCGMatrix)分析法"></a>产品设计的顶层思考：波士顿矩阵(BCGMatrix)分析法</h3><p>波⼠顿矩阵，“销售增⻓率-市场占有率”矩阵，是⼀种分析公司产品组合的⽅法，以适应市场需求的变化。</p>
<ul>
<li>销售增长率越高(速度) -&gt; 公司应该投入的资金更多</li>
<li>市场占有率越高(效益) -&gt; 产品创造利润的能力越强</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>问题产品</td>
<td>高增长、低市场占有率</td>
<td>新产品、高风险：增长战略</td>
</tr>
<tr>
<td>明星产品</td>
<td>高增长、高市场占有率</td>
<td>新兴市场、头部产品：扩展张略</td>
</tr>
<tr>
<td>现金牛产品</td>
<td>低增长、高市场占有率</td>
<td>成熟市场与产品、现金来源：稳定战略</td>
</tr>
<tr>
<td>瘦狗产品</td>
<td>低增长、低市场占有率</td>
<td>情感因素：收缩战略</td>
</tr>
</tbody>
</table>
<p><img src="https://km.woa.com/files/photos/pictures/202105/1621157887_26_w353_h363.png" alt="enter image description here"></p>
<h2 id="做好一款产品有哪些小建议"><a href="#做好一款产品有哪些小建议" class="headerlink" title="做好一款产品有哪些小建议"></a>做好一款产品有哪些小建议</h2><h3 id="任务拆解：MECE"><a href="#任务拆解：MECE" class="headerlink" title="任务拆解：MECE"></a>任务拆解：MECE</h3><h3 id="产品设计：Fogg行为模型-FBM"><a href="#产品设计：Fogg行为模型-FBM" class="headerlink" title="产品设计：Fogg行为模型(FBM)"></a>产品设计：Fogg行为模型(FBM)</h3><p>B=MAP，Behavior=Motivation+Ability+Prompt<br>⼈的⾏为是由动机，能⼒，触发条件三要素组成的。三要素同时满⾜才会产⽣⾏为。<br>通俗来说，⼀个⼈不做某件事，要么是不想做（没动机），要么是不能做或者不会做（没能⼒），要么就是忘了做（没触发）<br>⽤户的转化⾏为，发⽣在动机很强、成本很低的时候。<br>也就是下图阈值的上方，当然有的时候，动机强和成本低两者不可能完全满足，这时就要保证不能出现成本又高，用户动机又不够的设计。<br><img src="https://km.woa.com/files/photos/pictures/202105/1621157902_47_w925_h704.png" alt="enter image description here"></p>
<h4 id="动机-Motivation"><a href="#动机-Motivation" class="headerlink" title="动机 Motivation"></a>动机 Motivation</h4><p>a.感觉：追求快乐、远离痛苦<br>b.期待：拥有希望、逃避恐惧<br>c.归属感：渴望被认同、害怕被拒绝</p>
<h4 id="能力-成本-Ability-Simplicity"><a href="#能力-成本-Ability-Simplicity" class="headerlink" title="能力/成本 Ability/Simplicity"></a>能力/成本 Ability/Simplicity</h4><p>用户有能力完成转化，说白了就是成本在他可以接受的范围内。<br>Fogg 认为用户最在乎的是成本。<br> <strong>与其用更多的诱惑增加他做一件事的动机，不如思考降低他做这件事的成本。</strong><br>a. 时间<br>b. 金钱<br>c. 体力劳动: 相比走两个小时的路而言，打车就会显得更简单。<br>d. 脑力劳动: 有些人就是不喜欢动脑子，你让他答题得奖这件事就太复杂。<br>e. 社会压力: 如果要做有悖常理的事情，这个成本也会很高。<br>f. 习惯的力量: 如果要做这件事破坏了他日常的习惯，会有额外的成本。</p>
<h4 id="转化因素-Trigger"><a href="#转化因素-Trigger" class="headerlink" title="转化因素 Trigger"></a>转化因素 Trigger</h4><p>a. 刺激 Spark：当用户没有足够的动机时，需要用文字或者视频等，刺激用户产生动机。<br>b. 辅助 Facilitator：当用户已经有足够的动机了，但有的时候他不知道怎么做，⽤户有⼀定的动机但是不知道该怎么做，需要耐⼼地引导<br>c. 信号 Signal：⽤户既有动机有知道该怎么做，只是需要⼀个提醒就够了。当然，如果这时候信号过量，也会起反效果</p>
<h2 id="产品做完了，然后呢"><a href="#产品做完了，然后呢" class="headerlink" title="产品做完了，然后呢"></a>产品做完了，然后呢</h2><h3 id="评估产品能力：AARRR模型"><a href="#评估产品能力：AARRR模型" class="headerlink" title="评估产品能力：AARRR模型"></a>评估产品能力：AARRR模型</h3><p><img src="https://km.woa.com/files/photos/pictures/202105/1621157920_78_w912_h736.png" alt="enter image description here"></p>
<h3 id="量化用户价值：RFM模型"><a href="#量化用户价值：RFM模型" class="headerlink" title="量化用户价值：RFM模型"></a>量化用户价值：RFM模型</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Recency</td>
<td>最近一次“消费”时间</td>
<td>消费时间距离现在越近的用户价值越大</td>
</tr>
<tr>
<td>Frequency</td>
<td>“消费”频率</td>
<td>经常购买的用户比偶尔来一次的用户价值大</td>
</tr>
<tr>
<td>Monetary</td>
<td>“消费”金额</td>
<td>消费越多的用户价值越大</td>
</tr>
</tbody>
</table>
<p>（M的高低来区分重要程度。R+F 区分剩下的维度）</p>
<table>
<thead>
<tr>
<th>用户分群类型</th>
<th>R</th>
<th>F</th>
<th>M</th>
<th>用户等级</th>
</tr>
</thead>
<tbody>
<tr>
<td>重要价值用户</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>A</td>
</tr>
<tr>
<td>重要发展用户</td>
<td>高</td>
<td>低</td>
<td>高</td>
<td>A</td>
</tr>
<tr>
<td>重要保持用户</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>B</td>
</tr>
<tr>
<td>重要挽留用户</td>
<td>低</td>
<td>低</td>
<td>高</td>
<td>B</td>
</tr>
<tr>
<td>一般价值用户</td>
<td>高</td>
<td>高</td>
<td>低</td>
<td>B</td>
</tr>
<tr>
<td>一般发展用户</td>
<td>高</td>
<td>低</td>
<td>低</td>
<td>B</td>
</tr>
<tr>
<td>一般保持用户</td>
<td>低</td>
<td>高</td>
<td>低</td>
<td>C</td>
</tr>
<tr>
<td>一般挽留用户</td>
<td>低</td>
<td>低</td>
<td>低</td>
<td>C</td>
</tr>
</tbody>
</table>
<p>观点⼀：做⼤部分互联⽹产品，都要尽量从⾼频、低价场景着⼿。在线班课业务不⾼频，⼀对⼀业务不低价。<br>观点⼆：RFM只是⼀种思维模型，这三个⽤户价值指标可以根据具体的⾏业、产品、场景灵活变通，进⾏矩阵分析。⽐如报名期次、班次/科次等。另外，也可以只挑其中两个维度进⾏⽤户价值的⼆维分析。</p>
<h2 id="转自"><a href="#转自" class="headerlink" title="转自"></a>转自</h2><p><a href="https://www.toutiao.com/i6931591781884756492/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1&amp;timestamp=1613898142&amp;app=news_article&amp;utm_source=weixin&amp;utm_medium=toutiao_android&amp;use_new_style=1&amp;req_id=20210221170222010131075157491F816B&amp;share_token=d3dac16a-9785-4b56-8f4e-72e5b4c6bae0&amp;group_id=6931591781884756492" target="_blank" rel="noopener">https://www.toutiao.com/i6931591781884756492/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1&amp;timestamp=1613898142&amp;app=news_article&amp;utm_source=weixin&amp;utm_medium=toutiao_android&amp;use_new_style=1&amp;req_id=20210221170222010131075157491F816B&amp;share_token=d3dac16a-9785-4b56-8f4e-72e5b4c6bae0&amp;group_id=6931591781884756492</a></p>
]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统数据分布方案</title>
    <url>/2021/01/26/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="数据分布方式"><a href="#数据分布方式" class="headerlink" title="数据分布方式"></a>数据分布方式</h2><ul>
<li>顾名思义就是利用多台计算机协同解决单台计算机所不能解决的计算、存储等问题。</li>
<li>单机系统与分布式系统的最大的区别在于问题的规模，即计算、存储的数据量的区别。</li>
<li>将一个单机问题使用分布式解决，首先要解决的就是如何将问题拆解为可以使用多机分布式解决，使得 分布式系统中的每台机器负责原问题的一个子集。由于无论是计算还是存储，其问题输入对象都是 数据，所以如何拆解分布式系统的输入数据成为分布式系统的基本问题。</li>
</ul>
<a id="more"></a>
<p>几种方案可以组合使用</p>
<h3 id="普通哈希"><a href="#普通哈希" class="headerlink" title="普通哈希"></a>普通哈希</h3><p>按照数据的某一特征计算哈希值，并将哈希值与 机器中的机器建立映射关系，从而将不同哈希值的数据分布到不同的机器上</p>
<p><strong>优点:</strong><br>哈希函数的散列特性较好时数据分布均匀。<br>元信息非常简单</p>
<p><strong>缺点:</strong></p>
<ol>
<li><p>可扩展性不高:一旦集群规模需要扩展，则几乎所有的数据需要被迁移并重新分布。<br><strong>解决方案：</strong><br>维护额外的元数据：哈希值不与机器做除法取模映射，将对应关系作为元数据由专门的元数据服务器管理。<br>访问数据时：<br>1.1 计算哈希值<br>1.2. 哈希值取模个数大于机器个数，使同一台机器上负责多个哈希取模的余数<br>1.3. 查询元数据服务器，获得哈希值对应的机器。<br>1.4. 扩容时，将部分余数分配到新加入的机器并迁移对应的数据到新机器上</p>
</li>
<li><p>分布不均:一旦某数据特征值的数据严重不均，容易出现“数据倾斜”(data skew)问题<br><strong>解决方案：</strong>使用多个特征值计算哈希值，工程实践不容易落地</p>
</li>
</ol>
<p><strong>工程实践</strong><br>1.Mola(<a href="https://developer.baidu.com/platform/s60" target="_blank" rel="noopener">developer.baidu.com/platform/s6…</a>)<br>2.Armor(分布式Key-Value系统)<br>3.Big Pipe(百度的消息传输系统)分布不均：一旦某数据特征值的数据严重不均，容易出现“数据倾斜”(data skew)问题</p>
<h3 id="按范围"><a href="#按范围" class="headerlink" title="按范围"></a>按范围</h3><ul>
<li>将数据按特征值的值域范围划分为不同的区间，使得集群中每台(组)服务器处理不同区间的数据。如id、时间、区域</li>
<li>使用元数据服务器管理数据分布信息</li>
</ul>
<p><strong>优点:</strong>可以灵活的根据数据量的具体情况拆分原有数据区间， 拆分后的数据区间可以迁移到其他机器。<br><strong>缺点:</strong>当集群规模较大时，元信息的数据量也变得很大<br><strong>解决方案：</strong><br>1.利用动态划分区间的技术，使得每个区间中服务的数据量尽量的一样多。<br>2.当某个区间的数据量较大时，通过将区间“分裂”的方式拆分为两个区间，使得每个数据区间中的数据量都尽量维持在 一个较为固定的阈值之下。 </p>
<p><strong>工程实践</strong><br>1.Big Table(<a href="https://cloud.google.com/bigtable/" target="_blank" rel="noopener">cloud.google.com/bigtable/</a>)<br>2.Hbase(<a href="https://hbase.apache.org/" target="_blank" rel="noopener">hbase.apache.org/</a>)<br>3.PNUTS(<a href="https://timyang.net/architecture/yahoo-pnuts/" target="_blank" rel="noopener">timyang.net/architectur…</a>)</p>
<h3 id="按数据量"><a href="#按数据量" class="headerlink" title="按数据量"></a>按数据量</h3><ul>
<li>将数据视为一个顺序增长的文件，并将数据按照某一较为固定的大小划分为若干数据块(chunk)，不同的数据块分布到不同的服务器上</li>
<li>使用元数据服务器管理数据分布信息</li>
</ul>
<p><strong>优点:</strong>数据分布均匀<br><strong>缺点:</strong>数据分布均匀集群规模较大时，元信息的数据量很大;维护元数据逻辑复杂 </p>
<p><strong>实践中比较好的数据分布方案</strong><br>按哈希值分段<br>1.按照用户ID的哈希值分数据，如果某个用户ID的数据量特别大时，统计用户的数据量，并按某一阈值将用户的数据切分为多个均匀的数据段<br>2.将数据段分布到集群中去。大部分用户的数据量不会超过阈值<br>3.元数据中仅仅保存超过阈值的用户的数据段分布信息。</p>
<p><strong>工程实践:</strong><br>1.GFS(<a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf" target="_blank" rel="noopener">pdos.csail.mit.edu/6.824/paper…</a>)<br>2.HDFS(<a href="https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html" target="_blank" rel="noopener">hadoop.apache.org/docs/r1.0.4…</a>)</p>
<h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><ul>
<li>使用一个哈希函数计算数据或数据特征的哈希值，令哈希函数的输出值域为一个封闭的环，将节点随机分布在这个环上，每个节点负责处理从自己开始顺时针到下一个节点的全部哈希值域上的数据。</li>
<li>元数据维护虚拟节点与真实节点的映射</li>
</ul>
<p><strong>优点:</strong>可以任意动态添加、删除节点，每次仅影响一致性哈希环上相邻的节点。<br><strong>缺点:</strong>很难均匀分布<br><strong>解决方案：</strong><br>1.引入虚节点(virtual node)， 虚节点的个数远大于未来集群中机器的个数，将虚节点均匀分布到一致性哈希环上。<br>2.操作数据时，首先找到对应的虚节点，进而查找元数据找到对应的真实节点。</p>
<p><strong>工程实践</strong><br>1.Dynamo(<a href="https://aws.amazon.com/cn/dynamodb/" target="_blank" rel="noopener">aws.amazon.com/cn/dynamodb…</a>)<br>2.Cassandra(<a href="http://cassandra.apache.org/" target="_blank" rel="noopener">cassandra.apache.org/</a>)</p>
<h2 id="基本副本协议"><a href="#基本副本协议" class="headerlink" title="基本副本协议"></a>基本副本协议</h2><h3 id="中心化副本控制协议"><a href="#中心化副本控制协议" class="headerlink" title="中心化副本控制协议"></a>中心化副本控制协议</h3><p>由一个中心节点协调副本数据的更新、维护副本之间的一致性</p>
<p><strong>优点:</strong><br>1.协议相对较为简单， 所有的副本相关的控制交由中心节点完成。<br>2.并发控制将由中心节点完成，从而使得一个分布式并发 控制问题，简化为一个单机并发控制问题</p>
<p><strong>缺点:</strong>系统的可用性依赖于中心化节点</p>
<h3 id="primary-secondary协议"><a href="#primary-secondary协议" class="headerlink" title="primary-secondary协议"></a>primary-secondary协议</h3><p>1.副本分为两大类，其中有且仅有一个副本作为 primary 副本， 除 primary 以外的副本都作为 secondary 副本。<br>2.维护 primary 副本的节点作为中心节点，中心节点负 责维护数据的更新、并发控制、协调副本的一致性。 </p>
<p><strong>优点:</strong>兼顾了复杂、一致性与可用性<br><strong>缺点:</strong>牺牲一定的可用性<br><strong>工程实践:</strong><br>1.GFS<br>2.PNUTS<br>3.Niobe</p>
<h3 id="去中心化副本控制协议"><a href="#去中心化副本控制协议" class="headerlink" title="去中心化副本控制协议"></a>去中心化副本控制协议</h3><p>没有中心节点，协议中所有的节点都是完全对等的，节点之间通过平等协商 达到一致 </p>
<p><strong>优点:</strong>没有因为中心化节点异常而带来的停服务等问题<br><strong>缺点:</strong><br>1.协议过程通常比较复杂。尤其当需要实现强一致性时，协议流程变得复杂且不容易理解。<br>2.由于流程的复杂，去中心化 协议的效率或者性能一般也较中心化协议低。<br>3.一个不恰当的比方就是，中心化副本控制协议类似专 制制度，系统效率高但高度依赖于中心节点，一旦中心节点异常，系统受到的影响较大;去中心化 副本控制协议类似民主制度，节点集体协商，效率低下，但个别节点的异常不会对系统总体造成太 大影响。</p>
<p><strong>工程实践</strong><br>基于paxos协议:<br>1.Dynamo/Cassandra<br>2.Chubby/Zookeeper</p>
<h2 id="primary-secondary协议-1"><a href="#primary-secondary协议-1" class="headerlink" title="primary-secondary协议"></a>primary-secondary协议</h2><p>解决四大类问题:数据更新流程、数据读取方式、Primary 副本的确定和切换、数据同步(reconcile)</p>
<h3 id="数据更新流程"><a href="#数据更新流程" class="headerlink" title="数据更新流程"></a>数据更新流程</h3><ul>
<li>数据更新都由 primary 节点协调完成。</li>
<li>外部节点将更新操作发给 primary 节点</li>
<li>primary 节点进行并发控制即确定并发更新操作的先后顺序</li>
<li>primary 节点将更新操作发送给 secondary 节点</li>
<li>primary 根据 secondary 节点的完成情况决定更新是否成功并将结果返回外部节点<br><img src="https://km.woa.com/files/photos/pictures/202105/1621151834_80_w609_h195.png" alt="enter image description here"></li>
</ul>
<h3 id="数据读取方式"><a href="#数据读取方式" class="headerlink" title="数据读取方式"></a>数据读取方式</h3><p>保障强一致性的几种方法：</p>
<ol>
<li>始终读取primary副本</li>
<li>由 primary 控制节点 secondary 节点的可用性。当 primary 更新某个 secondary 副本不成功 时，primary 将该 secondary 副本标记为不可用，从而用户不再读取该不可用的副本。不可用的 secondary 副本可以继续尝试与 primary 同步数据，当与 primary 完成数据同步后，primary 可以副本 标记为可用。</li>
<li>Quorum方式读取<br>即 primary 成功更新 W 个副本(含 primary 本身)后向用户返回成功。读取数据时依照一致性要求的不 同可以有不同的做法:</li>
</ol>
<ul>
<li>如果需要强一致性的立刻读取到最新的成功提交的数据，则可以简单的只读 取 primary 副本上的数据即可，也可以通过强一致的方式读取;</li>
<li>如果需要会话一致性，则可以根据之前已经读到的数据版本号在各个副本上进行选择性读取;</li>
<li>如果只需要弱一致性，则可以选择任意副本读取。</li>
</ul>
<h3 id="Primary-副本的确定和切换"><a href="#Primary-副本的确定和切换" class="headerlink" title="Primary 副本的确定和切换"></a>Primary 副本的确定和切换</h3><p>primary副本的确定： 属于元信息，由专门的元数据服务器维护<br>primary的切换：<br>1.如何确定primary副本异常：lease机制<br>2.切换primary副本时如何保障数据一致性：quorum机制</p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><table>
<thead>
<tr>
<th>数据不一致原因</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>网络分化异常，secondary落后primary</td>
<td>使用日志技术，回放primary上的操作日志(通常是redo日志)，追上进度</td>
</tr>
<tr>
<td>某些协议下，secondary的数据是脏数据。（如primary没有更新，secondary更新了）</td>
<td>1. 设计协议不产生脏数据<br>2. 丢弃脏数据<br>3. 使用undo日志删除脏数据</td>
</tr>
<tr>
<td>secondary为新增副本，完全没有数据</td>
<td>1. 直接拷贝 primary 副本的数据，回放日志追更新进度的方法快很多<br>2. 但拷贝数据时 primary 副本需要能够继续提供更新服务，要求 primary 副本支持快照(snapshot)功能。即对某一刻的副本数据形成快照，然后拷贝快照，拷贝 完成后使用回放日志的方式追快照形成后的更新操作</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>技术</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Quorum机制</title>
    <url>/2021/01/16/Quorum%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="WARO机制介绍"><a href="#WARO机制介绍" class="headerlink" title="WARO机制介绍"></a>WARO机制介绍</h2><p>先看一个极端的情况：WARO(Write All Read one)是一种简单的副本控制协议，当Client请求向某副本写数据时(更新数据)，只有当所有的副本都更新成功之后，这次写操作才算成功，否则视为失败。</p>
<a id="more"></a>
<p>从这里可以看出两点：</p>
<ol>
<li>写操作很脆弱，因为只要有一个副本更新失败，此次写操作就视为失败了。</li>
<li>读操作很简单，因为，所有的副本更新成功，才视为更新成功，从而保证所有的副本一致。这样，只需要读任何一个副本上的数据即可。<br>假设有N个副本，N-1个都宕机了，剩下的那个副本仍能提供读服务；但是只要有一个副本宕机了，写服务就不会成功。</li>
</ol>
<p>从上述分析可以发现 WARO 读服务的可用性较高，但更新服务的可用性不高，甚至虽然使用副本，但更新服务的可用性等效于没有副本。</p>
<h2 id="Quorum机制介绍"><a href="#Quorum机制介绍" class="headerlink" title="Quorum机制介绍"></a>Quorum机制介绍</h2><ul>
<li>Quorum是分布式系统中用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理。</li>
<li>下面将 WARO 的条件进行松弛，从而使得可以在读写服务可用性之间做折中，得出 Quorum 机制。</li>
<li>假设有N个副本，更新操作wi 在W个副本中更新成功之后，才认为此次更新操作wi 成功。称成功提交的更新操作对应的数据为：“成功提交的数据”。对于读操作而言，至少需要读R个副本才能读到此次更新的数据。其中，W+R&gt;N ，即W和R有重叠。一般，W+R=N+1<br><img src="/img/16211552541601.jpg" alt></li>
</ul>
<p>举例：</p>
<ol>
<li>假设系统中有5个副本，W=3，R=3。初始时数据为(V1，V1，V1，V1，V1）–成功提交的版本号为1</li>
<li>当某次更新操作在3个副本上成功后，就认为此次更新操作成功。数据变成：(V2，V2，V2，V1，V1）–成功提交后，版本号变成2</li>
<li>因此，最多只需要读3个副本，一定能够读到V2(此次更新成功的数据)。而在后台，可对剩余的V1 同步到V2，而不需要让Client知道。</li>
</ol>
<p>Quorum 机制的三个系统参数 N、W、R 控制了系统的可用性，也是系统对用户的服务承诺:数 据最多有 N 个副本，但数据更新成功 W 个副本即返回用户成功。对于一致性要求较高的 Quorum 系 统，系统还应该承诺任何时候不读取未成功提交的数据，即读取到的数据都是曾经在 W 个副本上成 功的数据。</p>
<h2 id="Quorum机制分析"><a href="#Quorum机制分析" class="headerlink" title="Quorum机制分析"></a>Quorum机制分析</h2><h3 id="仅依赖Quorum机制无法保证强一致性"><a href="#仅依赖Quorum机制无法保证强一致性" class="headerlink" title="仅依赖Quorum机制无法保证强一致性"></a>仅依赖Quorum机制无法保证强一致性</h3><ul>
<li>所谓强一致性就是：任何时刻任何用户或节点都可以读到最近一次成功提交的副本数据。强一致性是程度最高的一致性要求，也是实践中最难以实现的一致性。</li>
<li>因为，仅仅通过Quorum机制无法确定最新已经成功提交的版本号(除非将最新已提交的版本号作为元数据由特定的元数据服务器或元数 据集群管理)。</li>
<li>比如，上面的V2 成功提交后（已经写入W=3份），尽管读取3个副本时一定能读到V2，如果刚好读到的是(V2，V2，V2），则此次读取的数据是最新成功提交的数据，因为W=3，而此时刚好读到了3份V2。</li>
<li>如果读到的是（V2，V1，V1），则无法确定是一个成功提交的版本，还需要继续再读，直到读到V2的达到3份为止，这时才能确定V2 就是已经成功提交的最新的数据。<br><img src="/img/16211553483856.jpg" alt></li>
</ul>
<h3 id="如何通过quorum达到强一致性"><a href="#如何通过quorum达到强一致性" class="headerlink" title="如何通过quorum达到强一致性"></a>如何通过quorum达到强一致性</h3><ol>
<li>限制提交的更新操作必须严格递增，即只有在前一个更新操作成功提交后才可以提交后一 个更新操作，保证成功提交的数据版本号必须是连续增加的</li>
<li>如何读取最新的数据？—最多读R个副本就可以读到最新的数据了。</li>
<li>如何确定最高版本号的数据是一个成功提交的数据？—继续读其他的副本，直到读到的 最高版本号副本 出现了W次。</li>
<li>若不满足，则R中版本号第二大的为最新成功提交的副本</li>
</ol>
<p>实际工程中，应该尽量通过其他技术手段，回避通过 Quorum 机制读取最新的成功提交的版本。例如，当 quorum 机制与 primary-secondary 控制协议结合使用时，可以通过读取 primary 的方式读取到 最新的已提交的数据。</p>
<h3 id="基于-Quorum-机制选择-primary"><a href="#基于-Quorum-机制选择-primary" class="headerlink" title="基于 Quorum 机制选择 primary"></a>基于 Quorum 机制选择 primary</h3><p>选择新的 primary 的工作是由某一额外的中心节点完成。</p>
<p>中心节点读取 R 个副本，选择 R 个副本中版本号最高的副本作为新的 primary。新 primary 与至少 W 个副本完成数据同步后作为新 的 primary 提供读写服务。</p>
<ul>
<li>R 个副本中一定蕴含了最新的成功提交的数据（即要么是V2,要么是V1）</li>
<li>虽然不能确定最高版本号的数是一个成功提交的数据，但新的 primary 在随后与 secondary 同步数据，使得该版本的副本个数达到 W，从而使得该版本的数据成为成功提交的数据</li>
</ul>
<p>举例：</p>
<ul>
<li>在 N=5，W=3，R=3 的系统中，某时刻副本最大版本号为(v2 v2 v1 v1 v1)，此时 v1 是系统的最新的成功提交的数据，v2 是一个处于中间状态的未成功提交的数据。</li>
<li>假设此刻原 primary 副本异常，中心节点进行 primary 切换工作。这类“中间态”数据究竟作为“脏数据”被删除，还是作为新的数据被同步后成为生效的数据，完全取决于这个数据能否参与新 primary 的选举，分两种情况：<br><img src="/img/16211554996958.jpg" alt></li>
</ul>
<ol>
<li>若中心节点读取到的版本号为(v1 v1 v1)，则任 选一个副本作为 primary，新 primary 以 v1 作为最新的成功提交的版本并与其他副本同步，当与第 1、 第 2 个副本同步数据时，由于第 1、第 2 个副本版本号大于 primary，属于脏数据。<br><img src="/img/16211555196393.jpg" alt></li>
<li>若中心节点读取到的版本号为(v2 v1 v1)，则选取版本号为 v2 的副本作为新的 primary。之后，一旦新 primary 与其他 2 个副本完成数据同步，则符合 v2 的副本个数达到 W 个，成为最新的成功提交的副本，新 primary 可以提供正常的读写服务。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>quorum</tag>
      </tags>
  </entry>
  <entry>
    <title>Lease机制</title>
    <url>/2021/01/15/Lease%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>Lease 是由颁发者授予的在某一有效期内的承诺。<br>包含两方面的内容：</p>
<ol>
<li>颁发者遵守承诺：颁发者一旦发 出 lease，则无论接受方是否收到，也无论后续接收方处于何种状态，只要 lease 不过期，颁发者一定严守承诺;</li>
<li>接受者遵守承诺：接收方在 lease 的有效期内可以使用颁发者的承诺，但一旦 lease 过期，接收方一定不能继续使用颁发者的承诺。</li>
</ol>
<p>由于 lease 是一种承诺，具体的承诺内容可以非常宽泛，可以是数据的正确性;也可以是某种权限，例如当需要做并发控制时，同一时刻只给某一个节点颁发 lease，只有持有 lease 的节点才可以修改数据;也可以是某种身份。</p>
<a id="more"></a>
<h2 id="Lease机制介绍"><a href="#Lease机制介绍" class="headerlink" title="Lease机制介绍"></a>Lease机制介绍</h2><h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><p>1.判断元数据是否已经处于本地 cache 且 lease 处于有效期内<br>1.1 是:直接返回 cache 中的元数据<br>1.2 否:向中心服务器节点请求读取元数据信息<br>1.2.1 服务器收到读取请求后，返回元数据及一个对应的 lease<br>1.2.2 客户端是否成功收到服务器返回的数据<br>1.2.2.1 失败或超时:退出流程，读取失败，可重试<br>1.2.2.2 成功:将元数据与该元数据的lease记录到内存中，返回元数据</p>
<h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><p>1.节点向服务器发起修改元数据请求。<br>2.服务器收到修改请求后，阻塞所有新的读数据请求，即接收读请求，但不返回数据。<br>3.服务器等待所有与该元数据相关的 lease 超时。<br>4.服务器修改元数据并向客户端节点返回修改成功。</p>
<h2 id="问题及优化点"><a href="#问题及优化点" class="headerlink" title="问题及优化点"></a>问题及优化点</h2><table>
<thead>
<tr>
<th>问题</th>
<th>原因</th>
<th>优化</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务器在修改元数据时首先要阻塞所有新的读请求，造成没有读服务</td>
<td>为了防止发出新的 lease 从而引起 不断有新客户端节点持有 lease 并缓存着数据，形成“活锁”</td>
<td>1. 服务器在进入修 改数据流程后，一旦收到读请求则只返回数据但不颁发 lease。<br>2. 造成在修改流程执行的过程中， 客户端可以读到元数据，只是不能缓存元数据。当进入修改流程，服务器颁发的 lease 有效期限选择为已发的 lease 的最大有效期限。</td>
</tr>
<tr>
<td>服务器在修改元数据时需要等待所有的 lease 过期超时，从而造成修改元数据的操作时延大大增大</td>
<td>颁发者要遵守承诺</td>
<td>1.在等待所有的 lease 过期的过程中，服务器主动通知各个持有 lease 的节点放弃 lease 并清除 cache 中的数据，如果服务器收到客户端返回的确认放弃 lease 的消息， 则服务器不需要在等待该 lease 超时.<br>2.该过程中，如果因为异常造成服务器通知失败或者客户端节点 发送应答消息失败，服务器只需依照原本的流程等待 lease 超时即可，而不会影响协议的正确性</td>
</tr>
</tbody>
</table>
<h2 id="cache机制与多副本机制区别"><a href="#cache机制与多副本机制区别" class="headerlink" title="cache机制与多副本机制区别"></a>cache机制与多副本机制区别</h2><p>对于 cache 的数据，可以随时删除 丢弃，并命中 cache 的后果仅仅是需要访问数据源读取数据;<br>然而副本机制却不一样，副本是不能随意丢弃的，每失去一个副本，服务质量都在下降，一旦副本数下降到一定程度，则往往服务将不 再可用。</p>
<h2 id="Lease的容错能力分析"><a href="#Lease的容错能力分析" class="headerlink" title="Lease的容错能力分析"></a>Lease的容错能力分析</h2><ol>
<li>引入绝对时间作为有效期，Lease 机制能否非常好的容错网络异常。<ul>
<li>lease一旦颁发成功，网络异常也没关系。</li>
<li>lease颁发不成功，重试即可。</li>
</ul>
</li>
<li>Lease 机制能较好的容错节点宕机<ul>
<li>颁发者宕机，无法改变以前的承诺，不会导致出错。</li>
<li>颁发者恢复后，等待最大过期时间，保持正确。</li>
<li>接收方宕机，颁发者无需做处理，到期后自动收回承诺。</li>
</ul>
</li>
<li>lease 机制不依赖于存储<br>颁发者可以持久化颁发过的 lease 信息，从而在 宕机恢复后可以使得在有效期的 lease 继续有效。但这对于 lease 机制只是一个优化，如之前的分析， 即使颁发者没有持久化 lease 信息，也可以通过等待一个最大的 lease 时间的方式使得之前所有颁发 的 lease 失效，从而保证机制继续有效。</li>
</ol>
<h2 id="基于Lease机制确定节点状态"><a href="#基于Lease机制确定节点状态" class="headerlink" title="基于Lease机制确定节点状态"></a>基于Lease机制确定节点状态</h2><ol>
<li>使用心跳方式确定 主副本的问题：<br>如果有3副本A、B、C，并通过中心结点Q来管理。其中A为主副本。<br>Q在某时刻未能预期收到主节点A的心跳，Q认为A已经异常，于是从B、C中选取一个B作为主节点。但实际上A并未异常，而是由于网络瞬时阻塞、或是Q本身出现异常使A这消息暂时未收到。这时，系统中出现A、B两个都是主节点的情况，称“双主”问题，从节点C可能同时从这两个主节点同步数据，这会引发很严重的数据错误。</li>
<li>lease机制<ul>
<li>由中心节点M向其他节点发送 lease， 若某个节点持有有效的 lease，则认为该节点正常可以提供服务</li>
<li>节点 A、B、C 依然周期性的发送 heart beat 报告自身状态，节点 Q 收到 heart beat 后发送一个 lease，表示节点 Q 确认了节点 A、B、C 的状态</li>
<li>节点 Q 可以给 primary 节点一个特殊的 lease，表示节点可以作为 primary 工作。</li>
<li>一旦节点 Q 希 望切换新的 primary，则只需等前一个 primary 的 lease 过期，则就可以安全的颁发新的 lease 给新的 primary 节点，而不会出现“双主”问题。<br>风险：<br>用一个中心节点发送 lease 也有很大的风险，一旦该中心节点宕机或网络异常， 则所有的节点没有 lease。<br>实际系统总是使用多个中心节点互为副 本，成为一个小的集群，该小集群具有高可用性，对外提供颁发 lease 的功能。<br>chubby 和 zookeeper 都是基于这样的设计。</li>
</ul>
</li>
</ol>
<h2 id="Lease有效时间选择"><a href="#Lease有效时间选择" class="headerlink" title="Lease有效时间选择"></a>Lease有效时间选择</h2><p>当颁发者在发布 lease 时通常都是将当前时间加上一个固定的时长从而计算出 lease 的有效期，如何确定有效期？</p>
<ul>
<li>如果lease时长太小，例如1s，一旦出现网络抖动 lease 很容易丢失，从而造成节点失去 lease， 使得依赖 lease 的服务停止;</li>
<li>如果 lease 时长太大，例如 1 分钟，则一旦接受者异常，颁发者需要过长的时间收回 lease 承诺。<br>工程中，常选择的 lease 时长是 10 秒级别，这是一个经 过验证的经验值，实践中可以作为参考并综合选择合适的时长。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>lease</tag>
      </tags>
  </entry>
  <entry>
    <title>失败处理策略</title>
    <url>/2021/01/14/%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>常见容错机制：failover ，failsafe，failfast ，failback，forking。</p>
<a id="more"></a>
<ul>
<li>Failover 失败自动切换：当出现失败，重试其它服务器，通常用于读操作（推荐使用）。 重试会带来更长延迟。如Mysql的双Master模式，当正在使用的Master出现故障时，可以拿备Master做主使用</li>
<li>Failfast 快速失败：只发起一次调用，失败立即报错,通常用于非幂等性的写操作。 如果有机器正在重启，可能会出现调用失败 。以JAVA集合（Collection）的快速失败为例，当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常（发现错误执行设定好的错误的流程），产生fail-fast事件。</li>
<li>Failsafe 失败安全：出现异常时，直接忽略，通常用于写入审计日志等操作。 调用信息丢失 可用于生产环境 Monitor。维基百科上一个形象的例子是红绿灯的“冲突监测模块”当监测到错误或者冲突的信号时会将十字路口的红绿灯变为闪烁错误模式，而不是全部显示为绿灯。</li>
<li>Failback 失败自动恢复：后台记录失败请求，定时重发。通常用于消息通知操作 不可靠，重启丢失。 可用于生产环境 Registry。</li>
<li>Forking 并行调用多个服务器：只要一个成功即返回，通常用于实时性要求较高的读操作。 需要浪费更多服务资源 。</li>
<li>Broadcast：广播调用，所有提供逐个调用，任意一台报错则报错。通常用于更新提供方本地状态 速度慢，任意一台报错则报错 。</li>
</ul>
<table>
<thead>
<tr>
<th>策略名称</th>
<th>优点</th>
<th>缺点</th>
<th>主要应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Failover</td>
<td>对调用者屏蔽调用失败的信息</td>
<td>增加RT，额外资源开销，资源浪费</td>
<td>对调用rt不敏感的场景</td>
</tr>
<tr>
<td>Failfast</td>
<td>业务快速感知失败状态进行自主决策</td>
<td>产生较多报错的信息</td>
<td>需要快速感知失败的场景</td>
</tr>
<tr>
<td>Failsafe</td>
<td>即使失败了也不会影响核心流程</td>
<td>对于失败的信息不敏感，需要额外的监控</td>
<td>旁路系统，失败不影响核心流程正确性的场景</td>
</tr>
<tr>
<td>Failback</td>
<td>失败自动异步重试</td>
<td>重试任务可能堆积</td>
<td>对于实时性要求不高，且不需要返回值的一些异步操作</td>
</tr>
<tr>
<td>Forking</td>
<td>并行发起多个调用，降低失败概率</td>
<td>消耗额外的机器资源，需要确保操作幂等性</td>
<td>资源充足，且对于失败的容忍度较低，实时性要求高的场景</td>
</tr>
<tr>
<td>Broadcast</td>
<td>支持对所有的服务提供者进行操作</td>
<td>资源消耗很大</td>
<td>通知所有提供者更新缓存或日志等本地资源信息</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>技术</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>整洁架构</title>
    <url>/2021/01/09/%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="本书的整体思路"><a href="#本书的整体思路" class="headerlink" title="本书的整体思路"></a>本书的整体思路</h2><ol>
<li>首先说明架构十分重要。</li>
<li>为了得到良好的架构，思考软件系统最本质的组成：代码。从代码出发，一步步将代码组织成系统：代码-&gt;类-&gt;组件-&gt;系统</li>
<li>从代码开始，介绍编写代码的三种编程范式：结构化编程、面向对象编程、函数式编程。</li>
<li>接下来介绍将代码(数据+行为)组织成类的设计原则：SOLID原则。</li>
<li>类确定后，介绍将类聚合成组件的原则(REP、CCP、CRP)以及组件之间的耦合原则（ADP、SDP、SAP）。</li>
<li>软件架构的实质就是规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间互相通信的方式。第5步已经得到了组件，所以接下来介绍软件架构要遵循的一些方法，以便将这些组件组合成完整的系统。</li>
<li>最后介绍了软件架构的一些细节问题。</li>
</ol>
<a id="more"></a>
<h2 id="架构目标"><a href="#架构目标" class="headerlink" title="架构目标"></a>架构目标</h2><blockquote>
<p>软件架构设计的主要目标是支撑软件系统的全生命周期，设计良好的架构可以让系统便于理解、易于修改、方便维护，并且能轻松部署。<br>软件架构的终极目标就是最大化程序员的生产力，同时最小化系统的总运营成本。</p>
</blockquote>
<p>在质量、效率、成本这个三角形中探索平衡点。</p>
<h3 id="行为价值"><a href="#行为价值" class="headerlink" title="行为价值"></a>行为价值</h3><blockquote>
<p>软件系统的行为是其最直观的价值维度。程序员的工作就是让机器按照某种指定方式运转，给系统的使用者创造或者提高利润。程序员们为了达到这个目的，往往需要帮助系统使用者编写一个对系统功能的定义，也就是需求文档。然后，程序员们再把需求文档转化为实际的代码。</p>
</blockquote>
<p>大部分程序员认为工作是且仅是：按照需求文档编写代码，并且修复任何Bug。真是大错特错。</p>
<h3 id="架构价值"><a href="#架构价值" class="headerlink" title="架构价值"></a>架构价值</h3><p>作为技术人员，更要重视软件系统的另一价值维度：架构价值。</p>
<blockquote>
<p>软件系统必须保持灵活。软件发明的目的，就是让我们可以以一种灵活的方式来改变机器的工作行为。对机器上那些很难改变的工作行为，我们通常称之为硬件（hardware）。</p>
<p>为了达到软件的本来目的，软件系统必须够“软”——也就是说，软件应该容易被修改。当需求方改变需求的时候，随之所需的软件变更必须可以简单而方便地实现。变更实施的难度应该和变更的范畴（scope）成等比关系，而与变更的具体形状（shape）无关。</p>
</blockquote>
<h3 id="哪个价值更重要？"><a href="#哪个价值更重要？" class="headerlink" title="哪个价值更重要？"></a>哪个价值更重要？</h3><p>究竟是系统行为更重要，还是系统架构的灵活性更重要？哪个价值更大？系统正常工作更重要，还是系统易于修改更重要？</p>
<p>这两个价值并不冲突：若忽视了架构价值，行为价值也无法实现。系统迭代会变得越来越慢，问题越来越多，成本变得越来越大。只有重视架构，行为价值才能被更好的满足。</p>
<blockquote>
<p>软件开发的一个核心特点：要想跑得快，先要跑得稳。</p>
</blockquote>
<h3 id="架构师的职责"><a href="#架构师的职责" class="headerlink" title="架构师的职责"></a>架构师的职责</h3><blockquote>
<p>软件架构师必须创建出一个可以让功能实现起来更容易、修改起来更简单、扩展起来更轻松的软件架构。</p>
<p>请记住：如果忽视软件架构的价值，系统将会变得越来越难以维护，终会有一天，系统将会变得再也无法修改。</p>
<p><strong>如果系统变成了这个样子，那么说明软件开发团队没有和需求方做足够的抗争，没有完成自己应尽的职责。</strong></p>
</blockquote>
<p>需求是做正确的事，设计是正确的做事。<br>研发团队应该珍惜自己的精力，把自己看作是投资人，产品提的需求不能打动你，就不值得投入。<br>一旦决定投入，要按研发团队的方式来执行，因为其他人都是外行，没有人比你更专业。</p>
<h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><blockquote>
<p>任何软件架构的实现都离不开具体的代码，对软件架构的讨论应该从第一行被写下的代码开始。</p>
<p>编程范式指的是程序的编写模式，与具体的编程语言关系相对较小。这些范式会告诉你应该在什么时候采用什么样的代码结构。直到今天，我们也一共只有三个编程范式，而且未来几乎不可能再出现新的。</p>
</blockquote>
<p>这三个编程范式分别限制了goto语句、函数指针和赋值语句的使用。</p>
<h3 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h3><p><strong>结构化编程对程序控制权的直接转移进行了限制和规范。</strong></p>
<ul>
<li>简单一句话：禁用goto，使用if/else,do/while/until 等来代替</li>
<li>Dijkstra于1968年最先提出并推导证明。</li>
</ul>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p><strong>面向对象编程对程序控制权的间接转移进行了限制和规范。</strong></p>
<ul>
<li>比结构化编程还早提出两年。</li>
<li>1966年由OleJohan Dahl和Kriste Nygaard在论文中总结归纳出来的。这两个程序员注意到在ALGOL语言中，函数调用堆栈（call stack frame）可以被挪到堆内存区域里，这样函数定义的本地变量就可以在函数返回之后继续存在。这个函数就成为了一个类（class）的构造函数，而它所定义的本地变量就是类的成员变量，构造函数定义的嵌套函数就成为了成员方法（method）。这样一来，我们就可以利用多态（polymorphism）来限制用户对函数指针的使用。</li>
</ul>
<blockquote>
<p>面向对象编程到底是什么？业界在这个问题上存在着很多不同的说法和意见。然而对一个软件架构师来说，其含义应该是非常明确的：面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。</p>
</blockquote>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p><strong>函数式编程对程序中的赋值进行了限制和规范。</strong></p>
<ul>
<li>最早被提出</li>
<li>函数式编程概念是基于与阿兰·图灵同时代的数学家Alonzo Church在1936年发明的λ演算的直接衍生物</li>
<li>从理论上来说，函数式编程语言中应该是没有赋值语句的。大部分函数式编程语言只允许在非常严格的限制条件下，才可以更改某个变量的值。</li>
</ul>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><blockquote>
<p>SOLID原则的主要作用就是告诉我们如何将数据和函数组织成为类，以及如何将这些类链接起来成为程序</p>
</blockquote>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><blockquote>
<p>该设计原则是基于康威定律（Conway’s Law）的一个推论——一个软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构。这样，每个软件模块都有且只有一个需要被改变的理由。</p>
</blockquote>
<p>SRP是SOLID五大设计原则中最容易被误解的一个。很多程序员想当然地认为这个原则就是指：每个模块都应该只做一件事。(之前我也这么以为)<br>根据书中所讲，SRP的描述可以这样推演：<br>“任何一个软件模块都应该有且仅有一个被修改的原因。” -&gt;<br>“任何一个软件模块都应该只对一个用户（User）或系统利益相关者（Stakeholder）负责。”-&gt;<br>“<strong>任何一个软件模块都应该只对某一类行为者负责。</strong>“</p>
<blockquote>
<p>文中提到的“软件模块”究竟又是在指什么呢？大部分情况下，其最简单的定义就是指一个源代码文件。然而，有些编程语言和编程环境并不是用源代码文件来存储程序的。在这些情况下，“软件模块”指的就是一组紧密相关的函数和数据结构。</p>
</blockquote>
<p>这样推演是为了更好的与真正的软件系统结合。软件系统为了满足用户和所有者的要求，必然要经常做出修改。<br>“用户和所有者”对应“被修改的原因”，但这样用词并不准确，书中统称为 行为者(actor)。</p>
<p>单一职责最重要的是职责的划分，职责的划分才是重点。职责清楚后才能划分边界，否则其他几项原则都是空中楼阁。</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><blockquote>
<p>如果软件系统想要更容易被改变，那么其设计就必须允许新增代码来修改系统行为，而非只能靠修改原来的代码。</p>
</blockquote>
<p>一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易被扩展。</p>
<p>看过大量如下代码：<br><code>if(xxx) {
    doSth();
} else {
   doOther();
}</code></p>
<p>（这里只是举例这种代码是违反开闭的例子，并不是说不该存在。）</p>
<p>开闭原则关键是分离变与不变。对于不变的进行抽象，对于具体的、经常变化的进行扩展。</p>
<p>例如，软件系统中界面展示方式、内容经常变化，早期需要支持web端、客户端。界面属于具体的、经常变化的，不变的是界面依赖的数据。可以对数据进行抽象，具体的界面依赖数据。新增 移动端 展示方式时增加对数据的扩展，已存在的不需要改造。</p>
<p>面向对象的多态真的是个神器。</p>
<blockquote>
<p><strong>OCP是进行系统架构设计的主导原则</strong>，其主要目标是让系统易于扩展，同时限制其每次被修改所影响的范围。<br>实现方式是通过将系统划分为一系列组件，并且将这些组件间的依赖关系按层次结构进行组织，使得高阶组件不会因低阶组件被修改而受到影响。</p>
</blockquote>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><blockquote>
<p>如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换</p>
</blockquote>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><blockquote>
<p>在设计中避免不必要的依赖。</p>
</blockquote>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><blockquote>
<p>高层策略性的代码不应该依赖实现底层细节的代码，恰恰相反，那些实现底层细节的代码应该依赖高层策略性的代码。</p>
</blockquote>
<p>依赖反转原则（DIP）主要想告诉我们的是，如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。</p>
<p>注意，<strong>具体实现时不可能完全消失违反DIP的情况。通常只需要把它们集中于少部分的具体实现组件中，将其与系统的其他部分隔离即可</strong>，比如main组件。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h3><blockquote>
<p>组件是软件的部署单元，是整个软件系统在部署过程中可以独立完成部署的最小实体。例如，对于Java来说，它的组件是jar文件。而在Ruby中，它们是gem文件。在．Net中，它们则是DLL文件。总而言之，在编译运行语言中，组件是一组二进制文件的集合。而在解释运行语言中，组件则是一组源代码文件的集合。无论采用什么编程语言来开发软件，组件都是该软件在部署过程中的最小单元。</p>
</blockquote>
<p>设计良好的组件都应该永远保持可被独立部署的特性，这同时也意味着这些组件应该可以被单独开发。<br>软件系统通过组件的方式构建，每个组件具备独立部署的特性，意味着通过可插拔组件的方式提升系统的扩展性。</p>
<h3 id="组件如何聚合"><a href="#组件如何聚合" class="headerlink" title="组件如何聚合"></a>组件如何聚合</h3><ol>
<li>组件的构成安排不会一成不变，应随着项目重心的不同，以及研发性与复用性的不同而不断演化。</li>
<li>个人理解，这三个原则指导如何构建出“高内聚”的组件：<ul>
<li>有相同的修改原因</li>
<li>同时修改</li>
<li>同时被复用</li>
<li>组件内的类都是紧密关联的</li>
</ul>
</li>
</ol>
<h4 id="REP-The-Reuse-Release-Equivalence-Principle-复用-发布等同原则"><a href="#REP-The-Reuse-Release-Equivalence-Principle-复用-发布等同原则" class="headerlink" title="REP: The Reuse/Release Equivalence Principle(复用/发布等同原则)"></a>REP: The Reuse/Release Equivalence Principle(复用/发布等同原则)</h4><p>软件复用的最小粒度应等同于其发布的最小粒度。<br>复用组件时，要求被复用的组件可以独立发布并有明确版本号。<br>这项原则看起来是废话，因为复用的前提就是把相关的逻辑分离到独立的组件中。<br>但难点在于，如何确定哪些类组合成组件。<br>这个问题由CCP和CRP解答。</p>
<h4 id="CCP-The-Common-Closure-Principle-共同闭包原则"><a href="#CCP-The-Common-Closure-Principle-共同闭包原则" class="headerlink" title="CCP: The Common Closure Principle (共同闭包原则)"></a>CCP: The Common Closure Principle (共同闭包原则)</h4><p><strong>CCP的主要作用就是提示我们要将所有可能会被一起修改的类集中在一处。</strong></p>
<p>将会同时修改，并且为相同目的而修改的类放到同一个组件中，而将不会同时修改，并且不会为了相同目的而修改的那些类放到不同的组件中。</p>
<p>这其实是SRP原则在组件层面上的再度阐述。正如SRP原则中提到的“一个类不应该同时存在着多个变更原因”一样，CCP原则也认为一个组件不应该同时存在着多个变更原因。</p>
<p>SRP与CCP概括为：将由于相同原因而修改，并且需要同时修改的东西放在一起。将由于不同原因而修改，并且不同时修改的东西分开。</p>
<h4 id="CRP-The-Common-Reuse-Principle-共同复用原则"><a href="#CRP-The-Common-Reuse-Principle-共同复用原则" class="headerlink" title="CRP: The Common Reuse Principle (共同复用原则)"></a>CRP: The Common Reuse Principle (共同复用原则)</h4><p><strong>该原则建议将经常共同复用的类和模块放在同一个组件中。</strong><br>因为类很少被单独复用，更常见的是多个类同时作为某个可复用的抽象定义被共同复。<br>这个原则简答了我当年学Java的一个困惑。<br>当年想被遍历一个容器对象(比如HashMap),以为需要其他类来使用遍历器，实际是可直接通过容器对象获取遍历器。</p>
<p><strong>但CRP更重要的是告诉将哪些类分开。</strong><br>每当引用一个组件，就增加了依赖关系。被引用组件发生变更时，引用它的组件也要变更。<br>如果把关联不紧密的类放在了同一个组件，就会造成上述问题。导致给被人提供了个需要经常更新、测试、部署的组件，用的人就开骂了。</p>
<p>所以，<strong>CRP原则实际上是在指导我们：不是紧密相连的类不应该被放在同一个组件里。</strong></p>
<p>CRP实际是ISP原则的普世版，两个原则可以用一句话概括：<strong>不要依赖不需要用到的东西</strong></p>
<h4 id="组件聚合张力图"><a href="#组件聚合张力图" class="headerlink" title="组件聚合张力图"></a>组件聚合张力图</h4><ul>
<li>REP和CCP是粘合性原则，会让组件变得更大</li>
<li>CRP是排除性原则，会让组件变小<br>架构师就是在三个原则中取舍，可以用组件聚合张力图描述三者关系：<br><img src="/img/16213450263653.jpg" alt></li>
</ul>
<p>在项目早期，CCP原则会比REP原则更重要，因为这一阶段研发速度比复用性更重要。</p>
<p>一般来说，一个软件项目的重心会从该三角区域的右侧开始，先期主要牺牲的是复用性。然后，随着项目逐渐成熟，其他项目会逐渐开始对其产生依赖，项目重心就会逐渐向该三角区域的左侧滑动。</p>
<p>很好理解，因为项目一开始也不知道哪些能复用，所以不会拆分组件，通常逻辑都放在了一个组件中。随着迭代，功能越来越多，对业务理解更深刻，就会剥离出可复用的组件。</p>
<p><strong>不知道是不是Bob大叔创造的名词。ccp和crp可以简单映射为单体架构和微服务架构。造出来这些名词，让人难以理解。</strong></p>
<h3 id="组件如何耦合"><a href="#组件如何耦合" class="headerlink" title="组件如何耦合"></a>组件如何耦合</h3><p>组件依赖结构图并不是用来描述应用程序功能的，它更像是应用程序在构建性与维护性方面的一张地图。这就是组件的依赖结构图不能在项目的开始阶段被设计出来的原因——当时该项目还没有任何被构建和维护的需要，自然也就不需要一张地图来指引。</p>
<p>组件结构图的重要目标是如何隔离频繁的变更。软件架构师需要设计一套组件关系依赖图，以便将稳定的高价值组件与常变的组件隔离开。</p>
<h4 id="ADP-THE-ACYCLIC-DEPENDENCIES-PRINCIPLE（无依赖环原则）"><a href="#ADP-THE-ACYCLIC-DEPENDENCIES-PRINCIPLE（无依赖环原则）" class="headerlink" title="ADP: THE ACYCLIC DEPENDENCIES PRINCIPLE（无依赖环原则）"></a>ADP: THE ACYCLIC DEPENDENCIES PRINCIPLE（无依赖环原则）</h4><p>这个原则很好理解。<br>如何打破循环依赖？</p>
<ol>
<li>使用DIP原则</li>
<li>引入新的组件，使两个组件都依赖新的组件</li>
</ol>
<h4 id="SDP：THE-STABLE-DEPENDENCIES-PRINCIPLE（稳定依赖原则）"><a href="#SDP：THE-STABLE-DEPENDENCIES-PRINCIPLE（稳定依赖原则）" class="headerlink" title="SDP：THE STABLE DEPENDENCIES PRINCIPLE（稳定依赖原则）"></a>SDP：THE STABLE DEPENDENCIES PRINCIPLE（稳定依赖原则）</h4><p><strong>依赖关系必须指向更稳定的方向。</strong><br>那如何评估组件的稳定性？</p>
<h5 id="稳定性指标"><a href="#稳定性指标" class="headerlink" title="稳定性指标"></a>稳定性指标</h5><p>Fan-in:入向依赖，这个指标指代了组件外部类依赖于组件内部类的数量。<br>Fan-out:出向依赖，这个指标指代了组件内部类依赖于组件外部类的数量。</p>
<p>I：不稳定性，I=Fan-out/（Fan-in+Fan-out）。该指标的范围是[0,1],I=0意味着组件是最稳定的，I=1意味着组件是最不稳定的.</p>
<p><strong>稳定依赖原则（SDP）的要求是组件结构依赖图中各组件的I指标必须要按其依赖关系方向递减。</strong></p>
<p>注意，并不是所有的组件都是稳定的，都是稳定的就意味着不能改了，失去了扩展性。<br>关键是保障核心组建的稳定性，分离变与不变。</p>
<p>经常违反SDP原则的例子就是业务逻辑依赖了界面展示:<br><img src="/img/16213454348239.jpg" alt="-w425"></p>
<p>如何修复?<br>DIP是个神器。<br><img src="/img/16213453483959.jpg" alt="-w405"></p>
<h4 id="SAP：THE-STABLE-ABSTRACTIONS-PRINCIPLE（稳定抽象原则）"><a href="#SAP：THE-STABLE-ABSTRACTIONS-PRINCIPLE（稳定抽象原则）" class="headerlink" title="SAP：THE STABLE ABSTRACTIONS PRINCIPLE（稳定抽象原则）"></a>SAP：THE STABLE ABSTRACTIONS PRINCIPLE（稳定抽象原则）</h4><p>一个组件的抽象化程度应该与其稳定性保持一致。</p>
<p>如果我们将高阶策略放入稳定组件中，那么用于描述那些策略的源代码就很难被修改了。这可能会导致整个系统的架构设计难于被修改。</p>
<p>如何才能让一个无限稳定的组件（I=0）接受变更呢？开闭原则（OCP）为我们提供了答案。</p>
<p>这个原则告诉我们：创造一个足够灵活、能够被扩展，而且不需要修改的类是可能的，而这正是我们所需要的。哪一种类符合这个原则呢？答案是抽象类。</p>
<p>稳定抽象原则（SAP）为组件的稳定性与它的抽象化程度建立了一种关联。一方面，该原则要求稳定的组件同时应该是抽象的，这样它的稳定性就不会影响到扩展性。另一方面，该原则也要求一个不稳定的组件应该包含具体的实现代码，这样它的不稳定性就可以通过具体的代码被轻易修改。</p>
<p>将SAP与SDP这两个原则结合起来，就等于组件层次上的DIP。</p>
<p>然而，DIP毕竟是与类这个层次有关的原则——对类来说，设计是没有灰色地带的。一个类要么是抽象类，要么就不是。<strong>SDP与SAP这对原则是应用在组件层面上的，我们要允许一个组件部分抽象，部分稳定。</strong></p>
<h5 id="衡量抽象化程度"><a href="#衡量抽象化程度" class="headerlink" title="衡量抽象化程度"></a>衡量抽象化程度</h5><p>Nc：组件中类的数量。<br>Na：组件中抽象类和接口的数量。<br>A：抽象程度，A=Na÷Nc。</p>
<p>A指标的取值范围是从0到1，值为0代表组件中没有任何抽象类，值为1就意味着组件中只有抽象类。</p>
<h5 id="主序列图"><a href="#主序列图" class="headerlink" title="主序列图"></a>主序列图</h5><p>组件的稳定性I与其抽象化程度A之间的关系：<br>纵轴为A值，横轴为I值。<br><img src="/img/16213454936325.jpg" alt="-w325"></p>
<p>最稳定的、包含了无限抽象类的组件应该位于左上角（0,1），最不稳定的、最具体的组件应该位于右下角（1,0）。</p>
<p>不可能所有的组件都能处于这两个位置上，因为组件通常都有各自的稳定程度和抽象化程度。</p>
<p><img src="/img/16213455127357.jpg" alt="-w414"><br><img src="http://km.oa.com/files/photos/pictures/202101/1610180141_90_w1138_h1000.png" alt="enter image description here"></p>
<h5 id="痛苦区"><a href="#痛苦区" class="headerlink" title="痛苦区"></a>痛苦区</h5><p>一个不抽象的组件，但却很稳定，稳定的原因是被其他组件所依赖。<br>这样的组件在设计上是不佳的，因为它很难被修改，这意味着该组件不能被扩展。<br>这样一来，因为这个组件不是抽象的，而且它又由于稳定性的原因变得特别难以被修改，我们并不希望一个设计良好的组件贴近这个区域，因此（0,0）周围的这个区域被我们称为痛苦区（zone of pain）。</p>
<p>最好的例子就是数据库中的表了。表结构十分具体，被其他组件依赖，每次修改都痛苦万分。</p>
<p>另一个会处于这个区域的典型软件组件是工具型类库。例如String组件，虽然其中所有的类都是具体的，但由于它被使用得太过普遍，任何修改都会造成大范围的混乱，因此String组件只能是不可变的。</p>
<h5 id="无用区"><a href="#无用区" class="headerlink" title="无用区"></a>无用区</h5><p>因为这些组件通常是无限抽象的，但是没有被其他组件依赖，这样的组件往往无法使用。这类组件也不是我们想要的</p>
<h5 id="避开这两个区域"><a href="#避开这两个区域" class="headerlink" title="避开这两个区域"></a>避开这两个区域</h5><p>坐落于主序列线上的组件不会为了追求稳定性而被设计得“太过抽象”，也不会为了避免抽象化而被设计得“太过不稳定”。</p>
<p>在整条主序列线上，组件所能处于最优的位置是线的两端。一个优秀的软件架构师应该争取将自己设计的大部分组件尽可能地推向这两个位置。然而，大型系统中的组件不可能做到完全抽象，也不可能做到完全稳定。所以我们只要追求让这些组件位于主序列线上，或者贴近这条线即可。</p>
<h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><blockquote>
<p>软件架构这项工作的实质就是规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间互相通信的方式。</p>
<p>软件架构设计的主要目标是支撑软件系统的全生命周期，设计良好的架构可以让系统便于理解、易于修改、方便维护，并且能轻松部署。</p>
<p>软件架构的终极目标就是最大化程序员的生产力，同时最小化系统的总运营成本。</p>
</blockquote>
<h3 id="保留可选项"><a href="#保留可选项" class="headerlink" title="保留可选项"></a>保留可选项</h3><blockquote>
<p>优秀的架构师所设计的策略应该允许系统尽可能地推迟与实现细节相关的决策，越晚做决策越好。</p>
</blockquote>
<p>所有的软件系统都可以降解为策略与细节这两种主要元素。策略体现的是软件中所有的业务规则与操作过程，因此它是系统真正的价值所在。</p>
<p>而细节则是指那些让操作该系统的人、其他系统以及程序员们与策略进行交互，但是又不会影响到策略本身的行为。它们包括I/O设备、数据库、Web系统、服务器、框架、交互协议等。</p>
<p>如果在开发高层策略时有意地让自己摆脱具体细节的纠缠，我们就可以将与具体实现相关的细节决策推迟或延后，因为越到项目的后期，我们就拥有越多的信息来做出合理的决策。</p>
<h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><blockquote>
<p>一个设计良好的架构应该能允许一个系统从单体结构开始，以单一文件的形式部署，然后逐渐成长为一组相互独立的可部署单元，甚至是独立的服务或者微服务。最后还能随着情况的变化，允许系统逐渐回退到单体结构。</p>
</blockquote>
<h3 id="划分边界"><a href="#划分边界" class="headerlink" title="划分边界"></a>划分边界</h3><p>通过划清边界，可以推迟和延后一些细节性的决策，可以节省大量的时间、避免大量的问题。</p>
<blockquote>
<p>为了在软件架构中画边界线，我们需要先将系统分割成组件，其中一部分是系统的核心业务逻辑组件，而另一部分则是与核心业务逻辑无关但负责提供必要功能的插件。然后通过对源代码的修改，让这些非核心组件依赖于系统的核心业务逻辑组件。其实，这也是一种对依赖反转原则（DIP）和稳定抽象原则（SAP）的具体应用，依赖箭头应该由底层具体实现细节指向高层抽象的方向。</p>
</blockquote>
<p>这一节讲的有点啰嗦，重点在于如何划分边界？<br>原则就是让核心业务逻辑组件成为高层组件，界面、数据库、输入/输出等都与核心组件都应划分边界，让具体的组件依赖核心组件。</p>
<p>这样做的好处是可以构建插件式架构。核心业务逻辑不变，其他的全可以插拔式替换。<br><img src="/img/16213456311880.jpg" alt="-w521"></p>
<h3 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h3><p>业务逻辑是一个软件系统存在的意义，它们属于核心功能，是系统用来赚钱或省钱的那部分代码，是整个系统中的皇冠明珠。这些业务逻辑应该保持纯净，不要掺杂用户界面或者所使用的数据库相关的东西。<br>在理想情况下，这部分代表业务逻辑的代码应该是整个系统的核心，其他低层概念的实现应该以插件形式接入系统中。业务逻辑应该是系统中最独立、复用性最高的代码。</p>
<h3 id="整洁架构"><a href="#整洁架构" class="headerlink" title="整洁架构"></a>整洁架构</h3><p>有一条贯穿整个架构设计的依赖关系规则：源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。<br><img src="/img/16213456573309.jpg" alt="-w539"></p>
<ul>
<li>真正的架构很可能会超过四层。并没有某个规则约定一个系统的架构有且只能有四层。</li>
<li>然而，这其中的依赖关系原则是不变的。码层面的依赖关系一定要指向同心圆的内侧。</li>
<li>层次越往内，其抽象和策略的层次越高，同时软件的抽象程度就越高，其包含的高层策略就越多。</li>
<li>最内层的圆中包含的是最通用、最高层的策略，最外层的圆包含的是最具体的实现细节。</li>
</ul>
<h4 id="业务实体"><a href="#业务实体" class="headerlink" title="业务实体"></a>业务实体</h4><p>业务实体这一层中封装的是整个系统的关键业务逻辑，一个业务实体既可以是一个带有方法的对象，也可以是一组数据结构和函数的集合。</p>
<h4 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h4><p>软件的用例层中通常包含的是特定应用场景下的业务逻辑，这里面封装并实现了整个系统的所有用例。<br>这些用例引导了数据在业务实体之间的流入/流出，并指挥着业务实体利用其中的关键业务逻辑来实现用例的设计目标。</p>
<h4 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h4><p>软件的接口适配器层中通常是一组数据转换器，它们负责将数据从对用例和业务实体而言最方便操作的格式，转化成外部系统（譬如数据库以及Web）最方便操作的格式。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="/img/16213457042232.jpg" alt="-w545"></p>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>后端技术栈</title>
    <url>/2020/12/20/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    <content><![CDATA[<p>后端需要掌握的方法<br><a id="more"></a></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li>面向对象，推荐《UML和模式应用》</li>
<li>软件方法</li>
<li>整洁架构之道</li>
</ul>
<h3 id="高可用保障"><a href="#高可用保障" class="headerlink" title="高可用保障"></a>高可用保障</h3><p><strong>负载均衡</strong></p>
<ul>
<li>负载均衡策略</li>
<li>中间件：f5/openresty/nginx/ribbon</li>
<li><a href="https://mp.weixin.qq.com/s/NUFRX51D9Yf9yzRQnPeWlg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/NUFRX51D9Yf9yzRQnPeWlg</a></li>
</ul>
<p><strong>降级：</strong></p>
<ul>
<li>降级时机</li>
<li>降级组件：hystrix/resilence    </li>
</ul>
<p><strong>限流：</strong></p>
<ul>
<li>漏桶</li>
<li>令牌桶</li>
<li>滑动窗口 <a href="https://zhuanlan.zhihu.com/p/150436514" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/150436514</a>    </li>
</ul>
<p><strong>隔离：</strong></p>
<ul>
<li>租户隔离</li>
<li>线程隔离：hystrix/resilence    </li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>监控：可用性/性能/容量/业务    </li>
<li>回滚    </li>
<li>压测与预案    </li>
</ul>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ul>
<li>批量、异步    </li>
<li>分库分表</li>
<li>各级别缓存：浏览器缓存、静态化；nginx</li>
</ul>
<h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><ul>
<li>hashmap/concurrenthashmap    </li>
<li>动态代理    </li>
<li>类加载    </li>
<li>重入锁与synchronized</li>
<li>AQS</li>
<li>对象头、锁优化、volatile    </li>
<li>阻塞队列    </li>
<li><p>线程：</p>
<ul>
<li>线程通信</li>
<li>线程池</li>
<li>threadlocal</li>
<li>jvm线程状态    </li>
</ul>
</li>
<li><p>jvm：</p>
<ul>
<li>参数、命令</li>
<li>垃圾回收、GC root</li>
<li>查看线程数占用 top -Hp pid;转16进制；jstack pid|grep XX</li>
<li>线程数过多：jca</li>
<li>oom</li>
<li>死锁排查</li>
<li>jmm、MESI</li>
<li>happen before    </li>
</ul>
</li>
</ul>
<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><ul>
<li>分布式系统整体介绍</li>
<li>分布式事务：<ul>
<li>程立文章</li>
<li><a href="https://www.infoq.cn/article/8bu33kusyj6p-waaoelt" target="_blank" rel="noopener">https://www.infoq.cn/article/8bu33kusyj6p-waaoelt</a></li>
<li><a href="https://strikefreedom.top/distributed-transaction-theorems-uncovering" target="_blank" rel="noopener">https://strikefreedom.top/distributed-transaction-theorems-uncovering</a></li>
</ul>
</li>
<li>分布式锁</li>
<li>注册发现：zk/etcd/consul/eureka: <a href="https://blog.csdn.net/xinyuan_java/article/details/102608442" target="_blank" rel="noopener">https://blog.csdn.net/xinyuan_java/article/details/102608442</a></li>
<li>负载均衡：<a href="https://mp.weixin.qq.com/s/NUFRX51D9Yf9yzRQnPeWlg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/NUFRX51D9Yf9yzRQnPeWlg</a></li>
<li>一致性哈希</li>
<li>一致性：raft/强一致性/弱一致性/base</li>
<li>失败处理策略：failover/failfast/failback</li>
<li>id生成器：<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/04/21/mt-leaf.html</a><ul>
<li>uuid</li>
<li>snowflake：ntp时钟</li>
<li>号段 <a href="https://mp.weixin.qq.com/s/TgPsHnB6ukh_n9K56PVNfA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/TgPsHnB6ukh_n9K56PVNfA</a></li>
</ul>
</li>
<li>rpc协议：<ul>
<li>thrift/grpc/pb/</li>
<li>序列化反序列化    </li>
</ul>
</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>存储引擎及优缺点    </li>
<li>隔离级别 <a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/08/20/innodb-lock.html</a>    </li>
</ul>
<p><strong>事务特性及实现</strong></p>
<ul>
<li>undo log</li>
<li>redo log    undo log：事务回滚及MVCC;</li>
<li>redo log：持久化；配合check point 机制做恢复。    2021.01.18    2021.01.22    DONE</li>
</ul>
<p><strong>锁：</strong></p>
<ul>
<li>表锁/行锁/间隙锁/next-key</li>
<li>加锁方式</li>
<li>mvcc</li>
<li>死锁排查    行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。</li>
</ul>
<p><strong>索引结构：</strong></p>
<ul>
<li>左序匹配原则</li>
<li>索引选择原则</li>
<li>一级索引、二级索引    </li>
<li>读写分离    </li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li>redis：数据备份</li>
<li>缓存数据结构</li>
<li>缓存应用</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul>
<li>各mq优缺点</li>
<li>如何保障幂等<a href="https://mp.weixin.qq.com/s/8oX7u8XcLL80_nNdN-UkvQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8oX7u8XcLL80_nNdN-UkvQ</a></li>
<li>如何保障顺序</li>
<li>延迟队列 <a href="http://km.oa.com/group/25584/articles/show/440190?kmref=search&amp;from_page=1&amp;no=4" target="_blank" rel="noopener">http://km.oa.com/group/25584/articles/show/440190?kmref=search&amp;from_page=1&amp;no=4</a>    </li>
<li>如何实现事务型消息</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>防重复提交    </li>
<li>STRIDE    </li>
<li>加密算法<ul>
<li>对称加密/非对称加密</li>
<li>哈希算法</li>
<li>彩虹表</li>
<li>https：<a href="https://mp.weixin.qq.com/s/lNfsJv1zOI9wRO-1aiw2cg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/lNfsJv1zOI9wRO-1aiw2cg</a>    </li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>优先级队列：</strong></p>
<ul>
<li>栈</li>
<li>队列</li>
<li>堆    </li>
</ul>
<p><strong>符号表：</strong></p>
<ul>
<li>BST</li>
<li>红黑树</li>
<li>哈希表    </li>
</ul>
<p><strong>分治：</strong></p>
<ul>
<li>快速排序</li>
<li>归并排序    </li>
</ul>
<p><strong>图：</strong></p>
<ul>
<li>DAG</li>
<li>UAG</li>
<li>拓扑</li>
<li>最小生成树</li>
<li>最短路径    </li>
</ul>
<p><strong>大数据处理：</strong></p>
<ul>
<li>堆排序</li>
<li>布隆过滤</li>
<li>bitmap</li>
<li>搜索树</li>
<li>并查集</li>
<li>trie树    </li>
</ul>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/5PhLWZ4Z9kagZSBlhzcLAg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/5PhLWZ4Z9kagZSBlhzcLAg</a>    七层模型    </li>
<li>TCP/UDP区别    </li>
<li>TCP如何保障可靠传输 <a href="https://mp.weixin.qq.com/s/h89R86KhWiQKsBvfZpyF5Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/h89R86KhWiQKsBvfZpyF5Q</a>    </li>
<li>粘包、拆包处理    </li>
<li>HTTP/2、QUIC、HTTPS    </li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>CPU调度    </li>
<li>内存管理    </li>
<li>进程通信方式    </li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/2020/10/16/%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>设计缓存方案时需关注的问题及解决方案</p>
<a id="more"></a>
<h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><h3 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h3><p><strong>Query</strong><br><img src="/img/16211559640368.jpg" alt></p>
<ol>
<li>应用程序先从Cache取数据</li>
<li>未命中：从DB中取数据，成功后更新到Cache</li>
<li>命中：应用程序从cache中取数据，取到后返回</li>
</ol>
<p><strong>Update</strong><br><img src="/img/16211559860761.jpg" alt></p>
<ul>
<li>把数据更新到DB中，成功后，让Cache失效</li>
</ul>
<h4 id="为什么删缓存，而不是更新缓存"><a href="#为什么删缓存，而不是更新缓存" class="headerlink" title="为什么删缓存，而不是更新缓存"></a><strong>为什么删缓存，而不是更新缓存</strong></h4><ol>
<li>性能：删除 比 更新 快，在写多的场景下，减少浪费。</li>
<li>正确性：在并发场景下，在写请求中更新缓存可能会引发数据的不一致问题。线程1比线程2早到，但线程1在线程2之后更新。导致缓存中存的是线程1的旧数据。线程3读到的就是旧数据。</li>
</ol>
<p><img src="/img/image-20211229154930217.png" alt="image-20211229154930217"></p>
<h4 id="为什么先更新数据库，而不是先删缓存"><a href="#为什么先更新数据库，而不是先删缓存" class="headerlink" title="为什么先更新数据库，而不是先删缓存"></a><strong>为什么先更新数据库，而不是先删缓存</strong></h4><ol>
<li><p>防止缓存穿透：先删缓存，请求都打到DB，增大缓存穿透概率。</p>
</li>
<li><p>正确性：</p>
<ul>
<li>并发场景下，线程1写数据，先删缓存。</li>
<li>线程2读数据，缓存不存在，读DB。读完DB更新缓存。</li>
<li>线程1删完缓存，更新DB。</li>
<li><p>此时缓存中是旧数据。线程3读到的是旧数据。</p>
<p><img src="/img/image-20211229155618523.png" alt="image-20211229155618523"></p>
</li>
</ul>
</li>
</ol>
<h4 id="cache-aside存在的问题"><a href="#cache-aside存在的问题" class="headerlink" title="cache-aside存在的问题"></a><strong>cache-aside存在的问题</strong></h4><p>并发问题：</p>
<ol>
<li>线程1查询未命中缓存，到DB取数据。</li>
<li>线程2更新操作，更新了DB数据，并删除缓存</li>
<li>线程1更新缓存(3.1)晚于线程2删除(2.2)，将旧数据放到了缓存中。</li>
<li>线程3读到的是旧数据。</li>
</ol>
<p><img src="/img/image-20211229161832900.png" alt="image-20211229161832900"></p>
<p><strong>解决办法</strong></p>
<ul>
<li>分析出现概率：低</li>
<li>出现的条件:<ol>
<li>读缓存时 缓存失效，而且有并发写操作。</li>
<li>实际场景，写比读慢得多，还需要锁表。需要满足 读在写操作之前结束又晚于写。</li>
</ol>
</li>
</ul>
<p>所有条件都具备的概率不大，通过设置合理的过期时间降低问题的影响程度。<br><strong>即，即使缓存出现了脏数据，使其影响范围有限。</strong></p>
<h3 id="Read-Write-Through"><a href="#Read-Write-Through" class="headerlink" title="Read/Write Through"></a>Read/Write Through</h3><p>更新数据库的操作由缓存代理，在应用层看来，认为后端就是一个单一的存储，这个存储维护自身的Cache<br><img src="/img/16211561394861.jpg" alt><br><strong>Query</strong></p>
<ul>
<li>命中：直接返回数据</li>
<li>未命中：由缓存服务从DB取数据更新到Cache，再返回给应用方。</li>
</ul>
<p><strong>Update</strong></p>
<ul>
<li>命中：先更新Cache，再更新DB</li>
<li>未命中：更新DB后直接返回。</li>
</ul>
<h3 id="Write-Behind-Caching"><a href="#Write-Behind-Caching" class="headerlink" title="Write Behind Caching"></a>Write Behind Caching</h3><p><img src="/img/wecom-temp-50f0656639bd0f98f5655924bfffd3bc.png" alt="wecom-temp-50f0656639bd0f98f5655924bfffd3bc" style="zoom:80%;"></p>
<ul>
<li>更新数据时，只更新缓存，不更新数据库</li>
<li>缓存异步、批量更新数据库</li>
</ul>
<h2 id="Cache更新失败的应对策略"><a href="#Cache更新失败的应对策略" class="headerlink" title="Cache更新失败的应对策略"></a>Cache更新失败的应对策略</h2><ul>
<li>记录日志，补偿保障最终一致性</li>
<li>异步更新，保障最终一致性</li>
<li>设计合理的Cache过期时间</li>
</ul>
<h2 id="设计缓存时的注意事项"><a href="#设计缓存时的注意事项" class="headerlink" title="设计缓存时的注意事项"></a>设计缓存时的注意事项</h2><p><strong>如何有效缓存数据</strong></p>
<ul>
<li>适合缓存的数据<ul>
<li>很少变化的数据</li>
<li>在应用程序运行时避免重复计算</li>
</ul>
</li>
<li>缓存的时间<ul>
<li>第一次由应用程序检索时添加到缓存</li>
<li>事先在缓存中部分或完全填充数据</li>
</ul>
</li>
</ul>
<p><strong>管理缓存中的数据过期</strong></p>
<ul>
<li>为数据设置过期时间，过期时间为绝对值</li>
<li>不同对象设置不同过期时间</li>
</ul>
<p><strong>缓存填满处理策略</strong></p>
<ul>
<li>数据淘汰<ul>
<li>最近最少使用原则</li>
<li>最新使用的策略(淘汰刚被用过的数据)</li>
<li>先进先出(淘汰最近的数据)</li>
<li>根据业务上已设置的触发条件淘汰</li>
</ul>
</li>
<li>不淘汰，直接报错</li>
</ul>
<h2 id="常见问题与防范"><a href="#常见问题与防范" class="headerlink" title="常见问题与防范"></a>常见问题与防范</h2><h3 id="Cache-Penetration-缓存穿透"><a href="#Cache-Penetration-缓存穿透" class="headerlink" title="Cache Penetration(缓存穿透)"></a>Cache Penetration(缓存穿透)</h3><p>查询一条数据库不存在的数据，也就是缓存和数据库都查询不到这条数据，这样请求每次都会穿透到数据库</p>
<p><strong>解决方法</strong></p>
<ul>
<li>缓存空值，注意 设置过期时间</li>
<li>Bloom Filter,判断一个元素是否存在，不存在直接返回。</li>
</ul>
<h3 id="Cache-BreakDown-缓存击穿"><a href="#Cache-BreakDown-缓存击穿" class="headerlink" title="Cache BreakDown(缓存击穿)"></a>Cache BreakDown(缓存击穿)</h3><p>在高并发的系统中，大量的请求同时查询一个 key时，当空上key刚好失效，会导致大量的请求访问数据库，这种现象我们称为缓存击穿。</p>
<p><strong>解决方法</strong></p>
<ul>
<li>并发查询时加锁</li>
<li>提前异步更新cache，使cache不失效</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>某一时刻发生大规模的缓存失效，包括缓存服务宕机，缓存集体过期等，导致大量的请求进来访问数据库，导致雪崩</p>
<p><strong>解决办法</strong></p>
<ul>
<li>过期时间有一定的随机性</li>
<li>对DB做熔断、降级、限流</li>
</ul>
<h3 id="热点数据集中失效"><a href="#热点数据集中失效" class="headerlink" title="热点数据集中失效"></a>热点数据集中失效</h3><p>缓存数据使用相同的过期时间，如果在同一时刻同时多个热点数据过期，可能导致对数据库的访问急剧升高。</p>
<p><strong>解决办法</strong></p>
<ul>
<li>失效时间有一定的随机性</li>
<li>互斥锁<ul>
<li>需要查DB的请求先获取锁，只有获取到锁的才能查询。查询成功后更新缓存，并释放锁</li>
<li>获取到锁的线程 判断cache是否已经有数据，有数据直接返回，没有数据再请求DB</li>
<li>注意：这种方式会阻塞并发查询，系统吞吐量下降，需要结合实际业务场景考虑使用</li>
</ul>
</li>
</ul>
<h3 id="缓存脏数据"><a href="#缓存脏数据" class="headerlink" title="缓存脏数据"></a>缓存脏数据</h3><p>指更新后的缓存数据与数据库数据不一致，导致影响业务。</p>
<p><strong>解决办法</strong></p>
<ul>
<li>防御性编程：缓存更新成功后，检查cache与DB是否一致</li>
<li>限制缓存写入点</li>
<li>建立缓存数据正确性监控/告警机制</li>
<li>设置缓存失效开关。注意 需要同时配备防缓存雪崩、缓存快速重建机制</li>
</ul>
<h2 id="缓存的监控"><a href="#缓存的监控" class="headerlink" title="缓存的监控"></a>缓存的监控</h2><ul>
<li>使用的内存量</li>
<li>总读取次数</li>
<li>总写入次数</li>
<li>总命中次数</li>
<li>读失败数</li>
<li>写失败数</li>
<li>单Key读次数</li>
<li>单Key写次数</li>
<li>安全性相关监控</li>
</ul>
<h2 id="缓存失效容忍性演练"><a href="#缓存失效容忍性演练" class="headerlink" title="缓存失效容忍性演练"></a>缓存失效容忍性演练</h2><p>定期演练：</p>
<ol>
<li>具备真实流量压测能力</li>
<li>模拟缓存雪崩场景，例如使用缓存功能开关，关闭缓存</li>
<li>验证熔断机制</li>
<li>验证限流机制</li>
<li>验证降级机制</li>
<li>验证DB可用性</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>软件方法</title>
    <url>/2020/02/18/%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li>将“业务到实现” 涉及的所有流程 进行拆解、细化，提供落地标准。并有例子说明，通俗易懂。</li>
<li>自己看了收获很大，改正以前很多不规范的地方，对软件方法有了新的认识。还需要消化吸收，和以前的知识融合一下。</li>
</ul>
<p>👇一句话来自书中，算是《穷查理宝典》中“保持终生学习”的具体例子，与大家分享：</p>
<blockquote>
<p>有的开发人员的“十年工作经验”实际上是“一年工作经验用了十年”，一直在热热闹闹的民工层次徘徊，没有积累和成长。</p>
</blockquote>
<a id="more"></a>
<h2 id="建模和UML"><a href="#建模和UML" class="headerlink" title="建模和UML"></a>建模和UML</h2><h3 id="利润-需求-设计"><a href="#利润-需求-设计" class="headerlink" title="利润 = 需求 - 设计"></a>利润 = 需求 - 设计</h3><ol>
<li>“子系统”不是从需求直接映射出来的，需要设计人员的想象力</li>
<li><p>需求和设计的区别<br> <img src="/img/15821964238040.jpg" alt="-w391"></p>
</li>
<li><p>要拥有全局视角，不能从需求出发进行方案设计。作者拿”人体”系统作为例子，很形象。</p>
<blockquote>
<p>人体的功能(能做什么)是走路、跑步、跳跃、举 重、投掷、游泳……但是设计人体的结构时，不能从需求直接映射到设计，得到“走路子系统”、“跑步 子系统”、“跳跃子系统”……人体的“子系统”是“呼吸子系统”、“消化子系统”、“血液循环子系统”、 “神经子系统”、“内分泌子系统”……“子系统”不是从需求直接映射出来的，需要设计人员的想象力 ——本例子的设计人员就是造物主了。同样，也不能从设计推导出需求:因为人有心肝脾肺肾，所以 人的用例是“心管理”、“肝管理”。</p>
</blockquote>
</li>
</ol>
<h3 id="建模工作流"><a href="#建模工作流" class="headerlink" title="建模工作流"></a>建模工作流</h3><ol>
<li>业务建模：描述组织内部各系统(人脑系统、电脑系统……)如何协作，使得组织可以为其 他组织提供有价值的服务。 <strong>如果通过业务建模推导新系统的需求，而不是拍脑袋得出，假的“需求变更”会大大减少。</strong></li>
</ol>
<p>   <img src="/img/15819977056852.jpg" alt></p>
<ol start="2">
<li>需求：描述为了解决组织的问题，系统必须具有的表现——功能和性能。严防“做”污染“卖”。需求工作流的结果——需求规约是“卖”和“做”的衔接点。</li>
<li>分析：提炼、封装核心域。</li>
<li>设计：核心域如何映射到选定平台上实现。</li>
</ol>
<h3 id="建模和敏捷"><a href="#建模和敏捷" class="headerlink" title="建模和敏捷"></a>建模和敏捷</h3><ol>
<li>愿景、业务建模方法，帮助迅速定位最重要的需求;领域分析方法，帮助厘清各种概念的变和不变。</li>
<li>不要让“面向过程”、“敏捷”成为偷懒的庇护所。</li>
</ol>
<p><img src="/img/15820141120683.jpg" alt></p>
<h2 id="业务建模之愿景"><a href="#业务建模之愿景" class="headerlink" title="业务建模之愿景"></a>业务建模之愿景</h2><h3 id="什么是愿景"><a href="#什么是愿景" class="headerlink" title="什么是愿景"></a>什么是愿景</h3><p>以一个待引入系统为研究对象，其愿景的定义是:在目标组织代表(<strong>老大</strong>)看来，引进该系统应该给<strong>组织</strong>带来的改进。（ <a href="https://baike.baidu.com/item/%E6%84%BF%E6%99%AF/520147?fr=aladdin" target="_blank" rel="noopener">百度百科-愿景</a> )</p>
<h3 id="定位目标组织和老大"><a href="#定位目标组织和老大" class="headerlink" title="定位目标组织和老大"></a>定位目标组织和老大</h3><ul>
<li>目标组织：待引入系统将改进其流程的组织。它可以是一个机构，也可以是一个人群。</li>
<li>老大：目标组织的代表。</li>
</ul>
<p><img src="/img/15820171202731.jpg" alt></p>
<h4 id="【步骤】定位目标人群和老大"><a href="#【步骤】定位目标人群和老大" class="headerlink" title="【步骤】定位目标人群和老大"></a>【步骤】定位目标人群和老大</h4><ul>
<li>方法:不断追问“谁比谁更像?”、“为什么?” </li>
<li>常见错误：<ol>
<li>从功能加上“人群”二字得到目标人群</li>
<li>吃窝边草</li>
<li>虚构老大</li>
</ol>
</li>
</ul>
<h4 id="【步骤】定位机构范围和老大"><a href="#【步骤】定位机构范围和老大" class="headerlink" title="【步骤】定位机构范围和老大"></a>【步骤】定位机构范围和老大</h4><p>（个人理解为垂类领域，如erp、crm等专业系统。因为任何机构都由人组成，但既然称为“机构”，一定专注于某一特定领域，该领域有自己的规则。听上去和“目标人群”又有些一样了。）</p>
<ul>
<li>方法：最开始机构中的某个涉众(可能不是老大) 提到要做一个什么系统，还提供了一些模糊的目标，建模人员根据这些素材推敲到机构范围，再定位 老大，揣摩老大的愿景，再从愿景来判断之前的范围是否要调整。如果范围变化，老大可能也要再做 调整……循环往复，逐步逼近。</li>
</ul>
<p><img src="/img/15820176190795.jpg" alt="-w651"></p>
<ul>
<li>常见错误：<ol>
<li>目标机构的 IT 主管是老大：IT 主管不是老大，因为系统要改进的不是目标机构 IT 部门的流程，而是业务部门的流程。所以， 老大应该是业务部门主管或机构负责人，视系统改进波及的范围而定。以看病做类比。患者病情比较严重或者患者不便交流的时候，和医生频繁打交道的可能是患者的 家属，但切不可因此把患者家属架上手术台。</li>
<li>机构之上的大领导是老大。</li>
<li>谁出钱谁是老大：还是以看病做类比。患者治病的钱可能是自己出，也可能是家属出，政府出，同房病友捐赠，甚 至由医院免单。不管怎样，上手术台的还是患者。</li>
<li>把其他涉众当作老大</li>
</ol>
</li>
</ul>
<h4 id="【步骤】定位目标机构"><a href="#【步骤】定位目标机构" class="headerlink" title="【步骤】定位目标机构"></a>【步骤】定位目标机构</h4><p>系统是为某一类机构服务。那么，除了第 2 种情况中要做的工作之外，还需要插入一步:定位目标机构。（更加精确）定位目标机构的思考方法和定位目标人群的思考方法是一样的。</p>
<h3 id="提炼改进目标"><a href="#提炼改进目标" class="headerlink" title="提炼改进目标"></a>提炼改进目标</h3><ol>
<li><p>思考度量指标，可以用以下方法（这部分是系统思考方法，需要找几本书看看）：</p>
<ul>
<li>针对形容词来思考符合这个形容词和不符合这个形容词的情况。（常见的一种系统思考方法）</li>
<li>从初步设想的解决方案倒推。可以这样思考:如果没有这个解决方案，涉众要付出什么代价?</li>
<li>借鉴机构的 KPI。</li>
</ul>
</li>
<li><p>改进目标描述的是系统给目标组织带来的改进，应该从老大和目标组织的视角来定义。</p>
</li>
</ol>
<h2 id="业务建模-之-业务用例图"><a href="#业务建模-之-业务用例图" class="headerlink" title="业务建模 之 业务用例图"></a>业务建模 之 业务用例图</h2><ul>
<li><p>有了愿景，我们知道老大对他所代表的组织的现状的某些指标不满意。接下来就可以研究组织，<strong>弄清楚到底是组织的哪些环节造成了这些指标比较差，这就是业务建模(Business Modeling)的主 要内容。</strong> <strong>“业务建模”这个名字其实起得不好，应该更名为“组织建模”。</strong> 出于对过去叫法的尊重，本书依 然称为“业务建模”。</p>
</li>
<li><p>开发团队经常发现需求“容易变化”。根源之一是需求的来路不正，没有把系统当作一个零件放在组织中来看，靠拍脑袋得出需求，导致得到的系统需求是错的。系统投入使用后，发现和组织的其他零件格格不入，自然要改。“需求变化剧烈”是一个假象，真正的需求没有变，只不过一开始得到的需求是假的。如果能正确运用业务建模技能，“需求变化”就会消于无形。（这不也是正确的废话，谁能保证建模正确。）</p>
</li>
<li><p>在业务建模工作流，我们从内外两个视角来研究组织。从外部看，组织是一些价值的集合，我们可以用业务用例图表示；从内部看，组织是一些系统的集合，我们可以用业务序列图来表示。</p>
</li>
</ul>
<h3 id="【步骤】识别业务执行者"><a href="#【步骤】识别业务执行者" class="headerlink" title="【步骤】识别业务执行者"></a>【步骤】识别业务执行者</h3><h4 id="业务执行者"><a href="#业务执行者" class="headerlink" title="业务执行者"></a>业务执行者</h4><ul>
<li>以某组织为研究对象，在组织之外和组织交互的其他组织(人群或机构)就是该组织的执行者。 因为研究对象是一个组织，所以叫业务执行者。</li>
</ul>
<h4 id="业务工人和业务实体"><a href="#业务工人和业务实体" class="headerlink" title="业务工人和业务实体"></a>业务工人和业务实体</h4><ul>
<li>组织内的人称为业务工人(Business Worker)，例如某商业银行里面的营业员。业务执行者和业务工人的区别是:一个在组织外面，一个在组织里面；一个是组织不可替换的服务对象，一个是组织可以替换的零件。</li>
<li>业务工人是可以被替换的人脑零件，它可能会被其他业务工人替换，但更有可能被业务实体替换。业务实体是组织中的非人智能系统，例如银行的 ATM、点钞机、营业系统。</li>
<li>责任转移的思想对识别待引入系统的需求很有帮助。开发人员说，“我在开发一个新系统”，其实说的就是“我在开发一个新的业务实体，取代现有业务工人或业务实体的一些责任”。这样，探索需求的思路就出来了——我们画好现状的业务序列图，然后寻找改进点改进业务序列图。</li>
<li>业务工人和业务实体不在业务用例图中出现，因为它们不是组织的价值，而是成本。在识别业务执行者时，不需要画业务工人和业务实体。</li>
<li>在接下来画业务用例的实现——业务序列图的时候，将业务工人和业务实体作为类(Class)的一 个构造型，放在名为“业务对象”的包里。组织的业务工人和业务实体协作完成业务用例，系统的类协作完成系统用例。</li>
</ul>
<h4 id="识别业务执行者"><a href="#识别业务执行者" class="headerlink" title="识别业务执行者"></a>识别业务执行者</h4><p>（<strong>《金字塔原理》《重构》中都有同样观点：在同一抽象层次上描述。</strong>）</p>
<ul>
<li>直觉上观察到的不是组织之间的交互，而是组织派出的系统之间的交互，但是一定要把它理解成组织之间的 交互，因为谈论业务执行者时，研究对象是组织，所以外部对应物——业务执行者也应该是组织。</li>
</ul>
<h3 id="【步骤】识别业务用例"><a href="#【步骤】识别业务用例" class="headerlink" title="【步骤】识别业务用例"></a>【步骤】识别业务用例</h3><ul>
<li>业务用例指业务执行者希望通过和所研究组织交互获得的价值。</li>
<li>业务用例是为业务执行者服务，不是为业务工人服务。这不是什么规范问题，背后有它的道理。 </li>
<li>要从业务执行者的角度去看，才能看得清楚组织的本质价值。</li>
<li>组织里发生的一切都是为了给业务执行者提供价值。这样的思路对改进业务流程有非常大的帮助:先归纳出组织对外提供什么价值，再思考如何更好地优化组织内部流程来实现这些价值。</li>
</ul>
<h4 id="正确理解价值"><a href="#正确理解价值" class="headerlink" title="正确理解价值"></a>正确理解价值</h4><ul>
<li><p>价值是<strong>期望和承诺的平衡点、买卖的平衡点。</strong><br><img src="/img/15820957453397.jpg" alt="-w782"></p>
</li>
<li><p><strong>业务用例是组织对组织的服务</strong>，相对于系统为系统提供的服务(系统用例)来说，所需要的时间是比较长的，<strong>不能把用例实现过程中的某个交互片段当成用例。</strong></p>
</li>
<li>一个典型的执行者使用系统做了某事，达到了某个结果，然后离开系统去做别的事情，如果离开时他心里认为得到目前的结果已经不算白做，就可以把 做某事作为一个系统用例。<strong>有一些词汇带有浓浓的“系统”味道，例如新增、查看、录入、查询、修 改、配置……带有这些词汇的用例，很可能不是组织提供的价值，而是某系统提供的价值。</strong></li>
</ul>
<h4 id="边界框问题"><a href="#边界框问题" class="headerlink" title="边界框问题"></a>边界框问题</h4><ul>
<li>讨论“是不是用例”、“有哪些用例”的时候，必须先说清楚研究对象，否则讨论没有意义。</li>
<li>画用例图时，能加上边界框尽量加上。</li>
</ul>
<h4 id="识别业务用例的思路和常犯错误"><a href="#识别业务用例的思路和常犯错误" class="headerlink" title="识别业务用例的思路和常犯错误"></a>识别业务用例的思路和常犯错误</h4><p>识别业务用例有两条思路：</p>
<ul>
<li>从业务执行者开始，思考业务执行者和组织交互的目的。</li>
<li>通过观察组织的内部活动，一直问为什么，向外推导出组织外部的某个业务执行者。<br>第一条路线 是主要的，第二条路线用于补漏。</li>
</ul>
<p>识别业务用例本来应该是很简单的事情，但是，许多程序员出身的需求人员受到了以往工作经历的影响，往往把简单的事情变得复杂，常见错误：</p>
<ul>
<li><strong>把业务工人的行为当作业务用例。</strong>这里反映了建模人员常见的一个问题:<strong>分不清问题和问题的解决方案。</strong></li>
<li><strong>业务用例随待引入系统伸缩。</strong>一个组织，甚至组织的一条流程都涉及许许多多的系统。在开发不同的系统时，研究业务用例和业务流程，发现得到的结果和开发另一个系统时的研究结果差不多，这是很正常的。建模人员不必因 此感到惊慌，更不要因为“业务用例太少”、“业务用例太简单了”不自觉地改变研究对象，把待引入系统的用例搬上来。</li>
<li><strong>把害怕漏掉的扩展路径片段提升为业务用例。</strong> 可以使用扩展路径来解决。</li>
<li><strong>管理型业务用例。</strong> 从“药师盘点药品”推导出背后的好处，然后画成“管理型业务用例”。它没有特定组织的味道，哪家营利机构不是为了赚钱?另外，也很 容易和愿景、涉众利益混在一起，发展下去，就会有“顾客→希望东西更便宜”之类的“用例”。</li>
</ul>
<p><img src="/img/15820391680024.jpg" alt="-w736"></p>
<h2 id="业务建模-之-业务序列图"><a href="#业务建模-之-业务序列图" class="headerlink" title="业务建模 之 业务序列图"></a>业务建模 之 业务序列图</h2><p>描述业务用例的实现，即业务流程，然后改进它，<strong>推导出待引入系统的用例。</strong></p>
<h3 id="序列图和活动图比较"><a href="#序列图和活动图比较" class="headerlink" title="序列图和活动图比较"></a>序列图和活动图比较</h3><ol>
<li>活动图只关注人，序列图把人当作系统：活动图描述业务流程时，建模人员往往只注意人或部门的活动，忽略了非人智能系统的责任。<strong>本书选择序列图的原因是把人脑系统和电脑系统平等看待。</strong></li>
<li>活动图表示动作，序列图强迫思考动作背后的目的：使用序列图来做业务建模，“对象协作以完成用例”的思想就可以统一地贯彻业务建模和系统建模的始终。</li>
<li>活动图“灵活”，序列图不“灵活”:灵活是双刃剑。</li>
</ol>
<h3 id="业务序列图要点"><a href="#业务序列图要点" class="headerlink" title="业务序列图要点"></a>业务序列图要点</h3><h4 id="消息代表责任分配而不是数据流动"><a href="#消息代表责任分配而不是数据流动" class="headerlink" title="消息代表责任分配而不是数据流动"></a>消息代表责任分配而不是数据流动</h4><p>序列图最重要的要点是消息的含义。A 指向 B 的消息，代表“A 请求 B 做某事”，或者“A 调用 B 做某事的服务”，做某事是 B 的一个责任。</p>
<p><img src="/img/15820975332487.jpg" alt="-w918"></p>
<p>数据流仅仅作为消息的输入输出参数存在。如果不了解这一点，就容易把消息的方向当成数据流动的方向，不但消息名称没写对，还会出现成对的消息。</p>
<p><img src="/img/15820975515426.jpg" alt="-w418"></p>
<h4 id="抽象级别是系统之间的协作"><a href="#抽象级别是系统之间的协作" class="headerlink" title="抽象级别是系统之间的协作"></a>抽象级别是系统之间的协作</h4><p>业务建模的研究对象是组织，出现在业务序列图生命线上的对象，其最小颗粒是系统，包括人和 非人系统。<br>几种错误：</p>
<ol>
<li><p>表达过细，系统内部的细节也表现出来，这些是在分析、设计阶段表现。</p>
<p> <img src="/img/15820980716809.jpg" alt="-w766"></p>
</li>
<li><p>业务序列图内容和业务用例图差不多：建模人员根本不了解 组织内部有哪些岗位，各自承担什么责任。</p>
<p> <img src="/img/15820981435456.jpg" alt="-w617"></p>
</li>
<li><p>把不具备任何智能的物体放到了业务序列图的生命线上。<img src="/img/15820981891022.jpg" alt="-w759"></p>
</li>
</ol>
<p>可能有的读者纳闷，我怎么记得看过的书里经常有序列图上出现订单、申请单对象?那是分析序列图。我们用对象的思想去构思我们所开发的系统的内部结构和行为，就得到了订单、申请单等假想 的有生命的对象。</p>
<p><img src="/img/15820982873968.jpg" alt="-w556"></p>
<h4 id="只画核心域相关的系统"><a href="#只画核心域相关的系统" class="headerlink" title="只画核心域相关的系统"></a>只画核心域相关的系统</h4><p>大致的判断标准是：如果是核心域相关的系统，应该出现在业务序列图中，如果不是，可以不出现。<br>（类似《ddd》中，不同的领域内聚合根、实体、值对象是不一样的。在不同场景，核心域相关的系统也不同）</p>
<h4 id="把时间看作特殊的业务实体"><a href="#把时间看作特殊的业务实体" class="headerlink" title="把时间看作特殊的业务实体"></a>把时间看作特殊的业务实体</h4><p>时间和定时器不是一个概念。时间是外系统，定时器是其他系统用来和时间打交道的边界 类，如图 4-19 所示。世界上只有一个时间系统，但有无数的定时器。有的建模人员在识别系统用例时 说“执行者是定时器”，这样说是错的，执行者是时间。</p>
<p><img src="/img/15820986230122.jpg" alt="-w928"></p>
<h5 id="为业务对象分配合适的责任"><a href="#为业务对象分配合适的责任" class="headerlink" title="为业务对象分配合适的责任"></a>为业务对象分配合适的责任</h5><p><img src="/img/15820987785916.jpg" alt="-w1000"></p>
<h3 id="【步骤】现状业务序列图"><a href="#【步骤】现状业务序列图" class="headerlink" title="【步骤】现状业务序列图"></a>【步骤】现状业务序列图</h3><p>尽力描绘出<strong>真实</strong>的现状，说起来非常简单，做到却极其困难。为了克服困难，建模人员甚至应当在心里暗暗发誓：如果不尽力去靠近真相，天打雷劈!（😆😆）</p>
<h4 id="错误1-把想象中的改进当成现状"><a href="#错误1-把想象中的改进当成现状" class="headerlink" title="错误1:把想象中的改进当成现状"></a>错误1:把想象中的改进当成现状</h4><p>背后的原因很可能是根本没有深入到组织流程中去做观察和访谈，对现状没有认识，只好想像一 个改进后的场景来应付。</p>
<h4 id="错误2-把“现状”误解为“纯手工”"><a href="#错误2-把“现状”误解为“纯手工”" class="headerlink" title="错误2:把“现状”误解为“纯手工”"></a>错误2:把“现状”误解为“纯手工”</h4><p>简单讲就是只考虑“人”，忽略了“非人系统”。</p>
<h4 id="错误3-把“现状”误解为“本开发团队未参与之前”"><a href="#错误3-把“现状”误解为“本开发团队未参与之前”" class="headerlink" title="错误3:把“现状”误解为“本开发团队未参与之前”"></a>错误3:把“现状”误解为“本开发团队未参与之前”</h4><h4 id="错误4-把“现状”误解为“规范”"><a href="#错误4-把“现状”误解为“规范”" class="headerlink" title="错误4:把“现状”误解为“规范”"></a>错误4:把“现状”误解为“规范”</h4><p>建模人员在建模业务流程时，照搬组织制定的规范，没有去观察实际工作中人们是如何做的，或者即使观察到了人们实际没有按照规范做，却依然按照规范建模。<strong>如果视而不见，也就丧失了许多有价值的改进 机会。</strong></p>
<h4 id="错误5-“我是创新，没有现状-”"><a href="#错误5-“我是创新，没有现状-”" class="headerlink" title="错误5:“我是创新，没有现状!”"></a>错误5:“我是创新，没有现状!”</h4><h4 id="错误6-“我做产品，没有现状"><a href="#错误6-“我做产品，没有现状" class="headerlink" title="错误6:“我做产品，没有现状!"></a>错误6:“我做产品，没有现状!</h4><p>做需求时把产品当项目做”的道理，就不会困惑了。“现状”指 目标组织的现状，是具体而且有最佳答案的。</p>
<h3 id="【步骤】改进业务序列图"><a href="#【步骤】改进业务序列图" class="headerlink" title="【步骤】改进业务序列图"></a>【步骤】改进业务序列图</h3><h4 id="改进模式1-物流变成信息流"><a href="#改进模式1-物流变成信息流" class="headerlink" title="改进模式1:物流变成信息流"></a>改进模式1:物流变成信息流</h4><p><img src="/img/15821021333360.jpg" alt="-w903"></p>
<ul>
<li>注意观察各种物的流动，并<strong>提炼物背后承载的信息。</strong> 注意，不要忘了还有人的流动，人可是一个几十公斤的物。</li>
<li>目前各领域在“物流变成信息流”方面留下的改进空间已经不 多。随之而来要面对的是信息流转不通畅的问题。</li>
</ul>
<h4 id="改进模式2：改善信息流转"><a href="#改进模式2：改善信息流转" class="headerlink" title="改进模式2：改善信息流转"></a>改进模式2：改善信息流转</h4><ul>
<li>把各软件系统之间的协调工作改为由一个软件系统来完成，人只需要和单个软件系统打交道，信息的流转就改进了。</li>
<li>人和人的协作中，可能隐藏了信息流转不畅的情况。（<strong>能够自动化的不要手动化，能通过程序的不要通过人。</strong>）</li>
</ul>
<h4 id="改进模式3-封装领域逻辑"><a href="#改进模式3-封装领域逻辑" class="headerlink" title="改进模式3:封装领域逻辑"></a>改进模式3:封装领域逻辑</h4><ul>
<li>提炼人脑中封装的领域逻辑，改为封装 到软件系统中，用软件系统代替人脑，业务流程就得到了改进。<br><img src="/img/15821025768466.jpg" alt="-w939"></li>
</ul>
<h4 id="阿布思考法"><a href="#阿布思考法" class="headerlink" title="阿布思考法"></a>阿布思考法</h4><ul>
<li>假设有充足的资源去解决问题，得到一个完美的方案。（目标要定的高，最理想的情况是什么样）</li>
<li>用手上现有的资源去山寨这个完美方案。</li>
</ul>
<p>如果有一个方案，花费完美方案 1%的资源，能达到完美方案 20%效果。这个方案已经是目前最 好的方案了，因为它是在突破思维限制以后一步步往后退得来的。（是不是最好的存疑，但做事方式要朝着最好的方向努力。）</p>
<h2 id="需求-之-系统用例图"><a href="#需求-之-系统用例图" class="headerlink" title="需求 之 系统用例图"></a>需求 之 系统用例图</h2><ul>
<li>看看如何从业务序列图映射出系统用例图。</li>
<li>系统用例的定义:系统能够为执行者提供的、涉众可以接受的价值。</li>
<li>和第3章的业务用例相比较，研究对象从组织变成了系统。</li>
<li>要理解好系统用例，重点依然是之前所强调的买卖平衡点、期望和承诺平衡点。</li>
</ul>
<h3 id="系统执行者要点"><a href="#系统执行者要点" class="headerlink" title="系统执行者要点"></a>系统执行者要点</h3><p>系统执行者的定义: 在所研究系统外，与该系统发生功能性交互的其他系统。</p>
<h4 id="系统是能独立对外提供服务的整体"><a href="#系统是能独立对外提供服务的整体" class="headerlink" title="系统是能独立对外提供服务的整体"></a>系统是能独立对外提供服务的整体</h4><ul>
<li>封装了自身的数据和行为，能独立对外提供服务的东西才能称为系统。不了解这一点，建模人员 很容易把“添加一些功能”当作“研发新系统”。</li>
</ul>
<h4 id="系统边界是责任的边界"><a href="#系统边界是责任的边界" class="headerlink" title="系统边界是责任的边界"></a>系统边界是责任的边界</h4><ul>
<li>系统执行者不是所研究系统的一部分，是该系统边界外的另一个系统。<strong>这里的系统边界不是物理的边界，而是责任的边界。</strong></li>
<li>涉众根本不在意系统划分成几个组件以及组件之间如何分布和交互。建模人员如果没有学会从涉众视角看问题，只是从自己角度看问题，就会犯这样的错误。</li>
<li>边界越模糊，越需要执行者来帮助理清。</li>
</ul>
<h4 id="系统执行者和系统有交互"><a href="#系统执行者和系统有交互" class="headerlink" title="系统执行者和系统有交互"></a>系统执行者和系统有交互</h4><p><strong>换言之，没有交互就不是系统执行者</strong></p>
<ul>
<li>系统执行者和重要无关。系统执行者只关注哪个外系统和所研究系统接口。</li>
<li>用例必须在它的路径、步骤和补充约束中考虑这些涉众的利益。<br><img src="/img/15821112801334.jpg" alt="-w987"></li>
</ul>
<h4 id="交互是功能性交互"><a href="#交互是功能性交互" class="headerlink" title="交互是功能性交互"></a>交互是功能性交互</h4><ul>
<li>执行者和系统发生的交互是系统的功能需求。</li>
</ul>
<h4 id="系统执行者可以是人或非人系统"><a href="#系统执行者可以是人或非人系统" class="headerlink" title="系统执行者可以是人或非人系统"></a>系统执行者可以是人或非人系统</h4><ul>
<li>用例技术中“执行者”和“涉众”的概念，把演员和观众分开了。 演员(执行者)在台上表演，观众(涉众)在台下看，演员表演什么是由观众的口味决定的，演员可 以不是人，但观众肯定是人。</li>
<li>用例使用“执行者”和“涉众”代替了原来的“用户”，这是一个非常大的突破。“用户”这个词 混淆了演员和观众的区别。过去经常说“找用户调研需求”，这是错误的。所谓“用户”，就是上台表演的人类演员。找用户调研需求，相当于找演员问剧本应该是什么内容，岂不是很荒谬？剧本应该由编剧向观众调研编写出来，然后由各路演员在台上演绎。</li>
<li>建立“执行者和系统在台上表演，涉众在台下看表演”的概念，在执行者为非人系统时对捕获需求很有帮助。</li>
</ul>
<h3 id="【步骤】识别系统执行者"><a href="#【步骤】识别系统执行者" class="headerlink" title="【步骤】识别系统执行者"></a>【步骤】识别系统执行者</h3><h4 id="从业务序列图映射系统执行者"><a href="#从业务序列图映射系统执行者" class="headerlink" title="从业务序列图映射系统执行者"></a>从业务序列图映射系统执行者</h4><ul>
<li>业务序列图上，和所研究系统有实线相连的对象映射为所研究系统的执行者。<br><img src="/img/15821118893421.jpg" alt="-w880"><br><img src="/img/15821119047011.jpg" alt="-w653"></li>
</ul>
<p>图 5-12 中执行者不再带有斜杠，因为这时候研究对象是系统。有的执行者画在边界框左边，有的 则画在右边，是为了方便表达主执行者和辅执行者。</p>
<h3 id="系统用例要点"><a href="#系统用例要点" class="headerlink" title="系统用例要点"></a>系统用例要点</h3><h4 id="价值是买卖的平衡点"><a href="#价值是买卖的平衡点" class="headerlink" title="价值是买卖的平衡点"></a>价值是买卖的平衡点</h4><ul>
<li>用例之前的许多需求方法学，把需求定义为思考系统“做什么”，用例把需求提升到思考系统“卖什么”的高度。</li>
<li>这种思考是非常艰难的，因为它没有标准答案，只有最佳答案。</li>
<li><strong>要得到这个最佳答案，不能靠拍脑袋，必须揣摩涉众。要得到合适的用例，需要有一颗善于体察他人的心。</strong></li>
</ul>
<h4 id="价值不等于“可以这样做”"><a href="#价值不等于“可以这样做”" class="headerlink" title="价值不等于“可以这样做”"></a>价值不等于“可以这样做”</h4><ul>
<li><p>建模人员只能根据目标涉众心中对系统的期望来确定系统 应该提供什么样的服务。</p>
</li>
<li><p><strong>举得权限例子没看懂，按照书中所讲的用例，用例岂不是膨胀很多</strong></p>
</li>
<li><p>最常犯的错误是把步骤当作用例。Include 的目的是为了复用在 多个用例中重复出现的步骤集合，形状往往是多个用例 Include 一个用例。看到这种一个用例 Include许多个用例的形状，基本上可以判断它犯了把步骤当作用例的错误。<br><img src="/img/15821130593917.jpg" alt="-w628"></p>
<p>正确的做法是：把右侧的“验密 码”和“扣除金额”作为步骤写在用例规约中。</p>
</li>
</ul>
<h4 id="增删改查用例的根源是从设计映射需求"><a href="#增删改查用例的根源是从设计映射需求" class="headerlink" title="增删改查用例的根源是从设计映射需求"></a>增删改查用例的根源是从设计映射需求</h4><ul>
<li>需求工作中，我们所写的每一个字，所画的每一张图都必须对好卖有推动作用，否则还不如不做。</li>
<li><strong>即使再难，也只能从 涉众的视角来定义需求</strong>，不能贪图方便选择一个自己熟悉的视角应付了事。</li>
<li>老老实实去研究业务流程，做好业务建模，尽量从业务序列图中映射出系统用例</li>
</ul>
<h4 id="从设计映射需求错误二-“复用”用例"><a href="#从设计映射需求错误二-“复用”用例" class="headerlink" title="从设计映射需求错误二:“复用”用例"></a>从设计映射需求错误二:“复用”用例</h4><ul>
<li>用例是涉众愿意“购买”的、对系统的一种“用法”，只要涉众愿意“购买”，当然是越多越好。 </li>
<li>同样的制作材料，变出更多可卖的价值，说明您的设计能力强，制作成本低，何乐而不为?</li>
<li>可惜建模人员经常会犯傻，不自觉地合并用例，相当于告诉涉众说，你真笨，你买我这些功能，其实都是我用同样几个类作为零件灵活组装出来的。干脆，你成本价把我的零件买走，自己去组装吧!</li>
<li>需求的基本要点：<strong>需求不考虑“复用”，如果在考虑“复用”，要警惕自己是不是已经转换到了设计视角来思考问题。</strong></li>
</ul>
<p><img src="/img/15821136913874.jpg" alt="-w339"></p>
<ul>
<li>图 5-17、图 5-22 和图 5-24 的错误用例图有一个共同点：多个执行者指向同一个用例。<strong>已完工的用例图不应该出现这样的形状，如果出现，可以有两种修改方法。</strong><ol>
<li>要是我们揣摩系统的这个用例针对 这几个执行者来说并无区别，就泛化出抽象的执行者，或者不需要泛化关系，直接用单个更合适的执行者代替;</li>
<li>反之，如果对不同执行者来说有区别，就把该用例分成几个不同的用例。这种往往更常见。<br><img src="/img/15821138626719.jpg" alt="-w837"></li>
</ol>
</li>
</ul>
<h4 id="系统用例不存在层次问题"><a href="#系统用例不存在层次问题" class="headerlink" title="系统用例不存在层次问题"></a>系统用例不存在层次问题</h4><ul>
<li><p>系统用例的研究对象就是某特定系统，不是组织，也不是系统内的组件。如果存在“层次”上的 疑惑，背后的原因是研究对象不知不觉改变了。（仍然有前面的疑惑）<br>  <img src="/img/15821144368789.jpg" alt="-w671"></p>
</li>
<li><p>用例很多时可以将用例分包，但用例包是从外部对系统用例所做的分包，里面 的用例依然是系统的用例，不是用例包或“模块”的用例。<br>  <img src="/img/15821144564392.jpg" alt="-w822"><br>  <img src="/img/15821144690940.jpg" alt="-w771"></p>
</li>
</ul>
<h4 id="用例的命名是动宾结构"><a href="#用例的命名是动宾结构" class="headerlink" title="用例的命名是动宾结构"></a>用例的命名是动宾结构</h4><ul>
<li>动词前面可以加状语，宾语前面可以加定语，把一句话的主语砍掉，剩下的可以作为用例的名字。</li>
<li>给用例起名时不要使用弱动词。</li>
<li>如果“名词+动词”已经成为行业中的一个术语，也未必要严格的动宾结构。</li>
</ul>
<h3 id="【步骤】识别系统用例"><a href="#【步骤】识别系统用例" class="headerlink" title="【步骤】识别系统用例"></a>【步骤】识别系统用例</h3><p>认真做好业务建模，从业务序列图上映射系统用例，得到的结果自然就会符合上面说的这些要点。</p>
<ul>
<li><p>业务序列图中，从外部指向所研究系统的消息，可以映射为该系统的用例。<br><img src="/img/15821167977987.jpg" alt="-w832"><br><img src="/img/15821168101447.jpg" alt="-w625"></p>
<p>有的箭头是从执行者指向用例，这样的执行者称为用例的主执行者，有的箭头是从用例指向执行者，这样的执行者称为用例的辅执行者。<strong>主执行者主动发起用例的交互，辅执行 者在交互的过程中被动参与进来。</strong></p>
</li>
<li><p>辅执行者这个概念是被误用比较多的。<strong>最常见的错误是把信息的接收者或者将来可能使用信息的人当成辅执行者。箭头代表的是责任分配。</strong>  图 5-35 的意思是:线索部经理使用线索管理系统分配名单的过程中需要外呼人员的帮忙，如果外呼人员睡着了没有响应，用例的目标就受到影响。显然，这不符合事实。<br><img src="/img/15821169595191.jpg" alt="-w658"></p>
</li>
<li><p>另一种辅执行者的误用刚好反过来，把信息的来源当作辅执行者。如图 5-36，建模人员认为外呼人员要想使用线索管理系统来查看本人当天名单，“依赖于”线索部经理事先分配好名单。这同样是错误的，在用例进行过程中不需要线索部经理的参与。<br><img src="/img/15821170688791.jpg" alt="-w725"></p>
</li>
<li><p>一般来说，<strong>辅执行者是非人智能系统的情况较多，人脑系统作为辅执行者的情况比较少，所以碰到辅执行者是人的时候，要多留心。</strong></p>
</li>
<li><p>主、辅执行者是针对某个用例来说的，一个外系统可以是这个用例的辅执行者， 同时也可以是另外一个用例的主执行者。“××是系统的主(辅)执行者”的说法是错误的。</p>
</li>
</ul>
<h2 id="需求-之-系统用例规约"><a href="#需求-之-系统用例规约" class="headerlink" title="需求 之 系统用例规约"></a>需求 之 系统用例规约</h2><p>用例规约就是以用例为核心来组织需求内容的需求规约。有了用例规约，可以不需要另外写其他格式的需求规约。<br><img src="/img/15821698345468.jpg" alt="-w794"></p>
<p><img src="/img/15821887399316.jpg" alt="-w572"></p>
<h3 id="前置条件和后置条件"><a href="#前置条件和后置条件" class="headerlink" title="前置条件和后置条件"></a>前置条件和后置条件</h3><p>用例通过前置条件(precondition)、后置条件(postcondition)以契约的形式表达需求。用例相当于系统的一个承诺：<strong>在满足前置条件时开始，按照里面的路径步骤走，系统就能到达后置条件。</strong></p>
<ul>
<li>前置条件：用例开始前，系统需要满足的约束。</li>
<li>后置条件：用例成功结束后，系统需要满足的约束。</li>
</ul>
<h4 id="前置条件、后置条件必须是系统能检测的。"><a href="#前置条件、后置条件必须是系统能检测的。" class="headerlink" title="前置条件、后置条件必须是系统能检测的。"></a>前置条件、后置条件必须是系统能检测的。</h4><p><img src="/img/15821700533595.jpg" alt="-w671"></p>
<h4 id="前置条件必须是用例开始前系统能检测到的。"><a href="#前置条件必须是用例开始前系统能检测到的。" class="headerlink" title="前置条件必须是用例开始前系统能检测到的。"></a>前置条件必须是用例开始前系统能检测到的。</h4><p><img src="/img/15821701313448.jpg" alt="-w935"></p>
<h4 id="前置后置条件是状态，不是动作。"><a href="#前置后置条件是状态，不是动作。" class="headerlink" title="前置后置条件是状态，不是动作。"></a>前置后置条件是状态，不是动作。</h4><p>例如，“经理→批假”的前置条件不能写“员工提交请假单”，因为是一个动作不是状态，应改为 “存在待审批的请假单”。特别要注意的是，写成“员工已经提交请假单”很可能也是不对的，因为状 态和导致达到某个状态的行为不是一一对应的，请假单未必是员工自己提交，也可以组长负责帮本组 人员请假，也可能是从另外的系统批量导入。</p>
<h4 id="前置后置条件要用核心域词汇描述。"><a href="#前置后置条件要用核心域词汇描述。" class="headerlink" title="前置后置条件要用核心域词汇描述。"></a>前置后置条件要用核心域词汇描述。</h4><p>不要写“XX成功”、“XX正常运行”，要体现领域知识，如“订单信息已保存”。</p>
<h4 id="“已登录”不应作为前置条件。"><a href="#“已登录”不应作为前置条件。" class="headerlink" title="“已登录”不应作为前置条件。"></a>“已登录”不应作为前置条件。</h4><p>例子讲得好</p>
<h3 id="涉众利益"><a href="#涉众利益" class="headerlink" title="涉众利益"></a>涉众利益</h3><p><strong>涉众利益即针对某件事情，某类人担心什么和希望什么。</strong></p>
<ul>
<li>前置条件是起点，后置条件是终点，中间的路该怎么走?这就要由涉众利益决定了。如果只考虑目标而没有考虑到涉众利益，正确的需求是出不来的。</li>
<li>认识到需求由涉众利益的冲突和平衡来决定，我们的需求过程就会充满“人”的味道，</li>
<li>为了寻找用例的涉众，可以用“醉酒法”思考。假设台上的演员“喝醉”(“喝醉”加了引号是因 为在台上的未必是人)了在台上表演，谁看到这个场面会担心自己的直接利益受到侵害?担心的人就是这个用例的涉众。</li>
</ul>
<h4 id="涉众利益来源"><a href="#涉众利益来源" class="headerlink" title="涉众利益来源"></a>涉众利益来源</h4><ol>
<li>人类执行者：用例的执行者如果是人类，当然是用例的涉众。执行者如果不是人类，就不是涉众，因为它没有利益主张。</li>
<li>上游</li>
<li>下游</li>
<li>信息的主人</li>
</ol>
<p><strong>业务建模对于识别涉众非常有帮助。</strong>如果我们在需求之前做了业务建模，会更了解一件事情的前因后果，大多数涉众都能够从业务序列图中看出来。</p>
<h4 id="寻找涉众利益"><a href="#寻找涉众利益" class="headerlink" title="寻找涉众利益"></a>寻找涉众利益</h4><ul>
<li>要“亲兄弟，明算账”，把不同涉众各自关注的利益体现出来，而不是写成一模一样。</li>
<li>避免正确的废话，要具体。</li>
</ul>
<h4 id="善于积累涉众利益"><a href="#善于积累涉众利益" class="headerlink" title="善于积累涉众利益"></a>善于积累涉众利益</h4><ul>
<li>很多需求中的两难，都是因为信息不足导致的。</li>
<li>如果我们能善于积累涉众利益，把目标组织内部各种人的小算盘搞得一清二楚，对方稍微说句话，我们就已经知道他心里的小九九，而且还知道他的 要求对谁有利，对谁有害，从而可以自如应对。</li>
</ul>
<h3 id="基本路径"><a href="#基本路径" class="headerlink" title="基本路径"></a>基本路径</h3><p>“观众已经一排排坐好，接下来就要让演员们上台演戏了。把演戏的场景描述出来，就得到了用例 的路径和步骤。”</p>
<ul>
<li>一个用例会有多个场景，其中有一个场景描述了最成功的情况，执行者和系统的交互非常顺利， 一路绿灯直抵用例的后置条件。这个场景称为<strong>基本路径</strong>。</li>
<li>用例把基本路径分离出来先写.</li>
</ul>
<p>书写路径步骤的时候需要注意以下一些要点:</p>
<h4 id="按照交互四步曲书写"><a href="#按照交互四步曲书写" class="headerlink" title="按照交互四步曲书写"></a>按照交互四步曲书写</h4><p><img src="/img/15821864396413.jpg" alt="-w544"></p>
<ul>
<li>在一个回合中，请求是必须的，同时还需要其他三类步骤中的至少一类.</li>
<li>对于时间为主执行者的用例，回合中的请求步骤不写“时间告知时间周期到了”，而是写“当到达时间周期时”。</li>
<li>验证步骤不写“是否”。例如图 6-18 中，第 4 步写“系统验证注册信息充分”，不写“系 统验证注册信息是否充分”，目的是要表达“充分”是基本路径期望的验证结果</li>
<li>系统和辅执行者之间的交互可以看作是一种回应步骤，写成“系统请求辅执行者做某事”， 例如“系统请求邮件列表系统群发邮件”。</li>
</ul>
<h4 id="只写系统能感知和承诺的内容"><a href="#只写系统能感知和承诺的内容" class="headerlink" title="只写系统能感知和承诺的内容"></a>只写系统能感知和承诺的内容</h4><p><img src="/img/15821873849016.jpg" alt="-w971"></p>
<h4 id="使用主动语句理清责任"><a href="#使用主动语句理清责任" class="headerlink" title="使用主动语句理清责任"></a>使用主动语句理清责任</h4><ul>
<li>把动作的责任人放在主语的位置。</li>
<li>规规矩矩说话，把责任理清楚。</li>
</ul>
<table>
<thead>
<tr>
<th>错误示例</th>
<th>评价</th>
</tr>
</thead>
<tbody>
<tr>
<td>会员进入系统</td>
<td>像黑客帝国一样脑门插插头进去？</td>
</tr>
<tr>
<td>会员打开系统</td>
<td>用手撕开？</td>
</tr>
<tr>
<td>系统自动计算订单价格</td>
<td>系统当然是自动的</td>
</tr>
<tr>
<td>会员提交订单信息给系统</td>
<td>“给系统”冗余</td>
</tr>
</tbody>
</table>
<h4 id="主语只能是主执行者或系统"><a href="#主语只能是主执行者或系统" class="headerlink" title="主语只能是主执行者或系统"></a>主语只能是主执行者或系统</h4><ul>
<li>写需求，就是要把系统当作一个黑箱，描述它对外提供的功能以及功能附带的质量需求。</li>
<li>系统如何构造，不属于需求描述的范围，除非是涉众强加的设计约束。</li>
<li>系统边界是责任边界，而非物理边界。</li>
</ul>
<h4 id="使用核心域术语描述"><a href="#使用核心域术语描述" class="headerlink" title="使用核心域术语描述"></a>使用核心域术语描述</h4><h4 id="不要涉及界面细节"><a href="#不要涉及界面细节" class="headerlink" title="不要涉及界面细节"></a>不要涉及界面细节</h4><p><img src="/img/15821880419484.jpg" alt="-w595"></p>
<h4 id="不要涉及交互细节"><a href="#不要涉及交互细节" class="headerlink" title="不要涉及交互细节"></a>不要涉及交互细节</h4><ul>
<li>用例的步骤应该把焦点放在系统必须接收什么输入、系统必须输出什么信息以及系统必须做什么处理这三个重点上，加上字段列表、业务规则、可用性需求等约束，足以表达各种需求。</li>
</ul>
<h4 id="需求是“不这样不行”"><a href="#需求是“不这样不行”" class="headerlink" title="需求是“不这样不行”"></a>需求是“不这样不行”</h4><ul>
<li>需求是“不这样不行”，而不是“这样也行”。</li>
<li>在需求里大量描述设计，相当于医生没有能力去定位患者得的什么病，干脆拍脑袋开药，然后用 正楷把药的说明书抄一遍，抄到自己都感动了，以为这样就可以治好患者了。</li>
</ul>
<h3 id="扩展路径"><a href="#扩展路径" class="headerlink" title="扩展路径"></a>扩展路径</h3><p>基本路径上的每个步骤都有可能发生意外，其中某些意外是系统要负责处理的，<strong>处理意外的路径就是扩展路径。</strong></p>
<ul>
<li>和辅执行者交互的步骤很有可能会出现扩展。在系统请求辅执行者做某事时，如果辅执行者出现 故障，系统无法得到想要的结果，很有可能会导致系统行为的变化。</li>
<li><strong>主要由 ”验证“和“辅助系统”产生，如果不是这两种，要特别小心是不是需求</strong></li>
</ul>
<h4 id="能感知和要处理的意外才是扩展。"><a href="#能感知和要处理的意外才是扩展。" class="headerlink" title="能感知和要处理的意外才是扩展。"></a>能感知和要处理的意外才是扩展。</h4><h4 id="设计技能不足导致的错误不是扩展。"><a href="#设计技能不足导致的错误不是扩展。" class="headerlink" title="设计技能不足导致的错误不是扩展。"></a>设计技能不足导致的错误不是扩展。</h4><h4 id="不引起交互行为变化的选择不是扩展。"><a href="#不引起交互行为变化的选择不是扩展。" class="headerlink" title="不引起交互行为变化的选择不是扩展。"></a>不引起交互行为变化的选择不是扩展。</h4><h4 id="界面跳转不是扩展。"><a href="#界面跳转不是扩展。" class="headerlink" title="界面跳转不是扩展。"></a>界面跳转不是扩展。</h4><ul>
<li>在书写用例规约时，应该把具体的界面看作不存在，把其他用例也看作不存在，专注于典型执行 者为了达到本用例目标必须要和系统发生的交互以及不可避免要处理的意外和分支。</li>
</ul>
<h3 id="补充约束"><a href="#补充约束" class="headerlink" title="补充约束"></a>补充约束</h3><p><img src="/img/15821893030969.jpg" alt="-w598"></p>
<h4 id="字段列表"><a href="#字段列表" class="headerlink" title="字段列表"></a>字段列表</h4><ul>
<li>字段列表不同于数据模型。</li>
<li>字段列表不等于数据字典</li>
</ul>
<h4 id="业务规则"><a href="#业务规则" class="headerlink" title="业务规则"></a>业务规则</h4><ul>
<li>只要涉众能理解，行业上适用的任何方式(例如数学、物理公式)都可以用来表达业务规则。</li>
</ul>
<h4 id="质量需求"><a href="#质量需求" class="headerlink" title="质量需求"></a>质量需求</h4><h5 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h5><ul>
<li>可用性需求是对人类执行者和系统之间交互质量的度量。</li>
</ul>
<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><h5 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h5><h5 id="可支持性"><a href="#可支持性" class="headerlink" title="可支持性"></a>可支持性</h5><h4 id="设计约束"><a href="#设计约束" class="headerlink" title="设计约束"></a>设计约束</h4><ul>
<li>设计约束是在实现系统时必须要遵守的一些约束，包括界面样式、报表格式、平台、语言等。</li>
<li>设计约束既不是功能需求，也不是质量需求。</li>
<li>设计约束是需求的一种，也一样要从涉众的视角来描述。</li>
</ul>
<h2 id="需求启发"><a href="#需求启发" class="headerlink" title="需求启发"></a>需求启发</h2><p>需求模型的质量依赖于需求的素材。从涉众处获取需求素材的工作叫做需求启发。</p>
<h3 id="需求启发要点"><a href="#需求启发要点" class="headerlink" title="需求启发要点"></a>需求启发要点</h3><ul>
<li>需求的一个启发障碍是知识的诅咒(Curse of Knowledge)，意思是：一旦知道某个东西，就很难想像不知道它会是什么样子。</li>
<li>需求启发的另一个障碍是做和定义的不同。涉众会做一件事情，不代表他能够把这件事定义出来教给其他人。</li>
</ul>
<h4 id="和涉众交流的形式应该采用视图，而不是模型。"><a href="#和涉众交流的形式应该采用视图，而不是模型。" class="headerlink" title="和涉众交流的形式应该采用视图，而不是模型。"></a>和涉众交流的形式应该采用视图，而不是模型。</h4><h4 id="和涉众交流的内容应该聚焦涉众利益，而不是需求。"><a href="#和涉众交流的内容应该聚焦涉众利益，而不是需求。" class="headerlink" title="和涉众交流的内容应该聚焦涉众利益，而不是需求。"></a>和涉众交流的内容应该聚焦涉众利益，而不是需求。</h4><ul>
<li>涉众没有资格提供需求。</li>
<li>系统的需求是平衡各种涉众利益得到的，不由单一涉众决定</li>
<li>涉众没有责任提供需求。</li>
</ul>
<h3 id="需求启发手段"><a href="#需求启发手段" class="headerlink" title="需求启发手段"></a>需求启发手段</h3><h4 id="研究资料"><a href="#研究资料" class="headerlink" title="研究资料"></a>研究资料</h4><ul>
<li>研究资料往往是需求启发的第一步，目的是为了获取核心域的初步知识，为下一步的启发工作做知识准备。</li>
</ul>
<h4 id="问卷调查"><a href="#问卷调查" class="headerlink" title="问卷调查"></a>问卷调查</h4><h4 id="访谈"><a href="#访谈" class="headerlink" title="访谈"></a>访谈</h4><h5 id="涉众"><a href="#涉众" class="headerlink" title="涉众"></a>涉众</h5><ul>
<li>选择的涉众代表必须名副其实，不要把“代表”等同于“主管”。例如，要访谈车间的操作工，那就要选真正的操作工，不能用车间主任来做代表。</li>
</ul>
<h5 id="需求人员"><a href="#需求人员" class="headerlink" title="需求人员"></a>需求人员</h5><ul>
<li>需求人员的态度要让涉众觉得自己被尊重。</li>
</ul>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li>问题的内容聚焦于业务流程和涉众利益，而非直接的系统需求。</li>
<li>问题的形式和新闻记者提问一样:5W+1H。谁(Who)、什么(What)、什么时候(When)、 什么地点(Where)、为什么(Why)、怎么进行(How)。</li>
<li>提问的时候尽量采用领域词汇，不要采用涉及软件实现的专业术语。</li>
<li>问问题的时候，可以跟随涉众的阐述，不断问为什么，深入探索背后的真正需求。</li>
</ul>
<h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><ul>
<li>尽可能在涉众的工作环境里访谈。涉众在自己的工作环境中会想起许多工作中的喜怒哀乐.</li>
<li>有人嫌在涉众的工作环境里访谈经常会被打断，但那也是一种真实的工作状态。</li>
</ul>
<h5 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h5><ul>
<li>观察就是需求人员跟在涉众旁边观察他的工作，甚至亲身去体验涉众的工作。<strong>这是最直接的需求启发技术，也最费时间。</strong></li>
</ul>
<h5 id="研究竞争对手"><a href="#研究竞争对手" class="headerlink" title="研究竞争对手"></a>研究竞争对手</h5><h3 id="需求人员的素质培养"><a href="#需求人员的素质培养" class="headerlink" title="需求人员的素质培养"></a>需求人员的素质培养</h3><ul>
<li>一名优秀需求人员所需要的素质归纳成一所房屋的样子。房屋以好奇心为根基，有探索力、沟通力、表达力三根柱子，以热情作为屋顶。</li>
</ul>
<p><img src="/img/15821955145522.jpg" alt="-w312"></p>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title>乌合之众</title>
    <url>/2020/02/05/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/</url>
    <content><![CDATA[<p>最近一直在看心理学系列的书，《影响力》《谈判力》，再加上这本《乌合之众》。恰好赶上了疫情爆发，群体的表现和书上所描述的大部分吻合，真的如书名所说：乌合之众！同时我发现群体很多行为都是“系统一”在起作用，所以打算再读一遍《思考，快与慢》。</p>
<p>大部分行为表明，群体在精神上往往十分低劣。群体的无意识行为取代了个体有意识的行为，这是现时代最显著的特征之一，群体时时处处都表现出来的特征是：</p>
<ul>
<li>推理能力差，缺乏批评精神，易怒，轻信，头脑简单。</li>
<li>作决定时受领袖人物的影响，如断言、重复、声望和传染在起作用。</li>
</ul>
<a id="more"></a>
<h2 id="群体的心理"><a href="#群体的心理" class="headerlink" title="群体的心理"></a>群体的心理</h2><h3 id="群体的一般特征-群体精神统一率"><a href="#群体的一般特征-群体精神统一率" class="headerlink" title="群体的一般特征 群体精神统一率"></a>群体的一般特征 群体精神统一率</h3><p><strong>有意识的个性消失，无意识的个性得势，感情和思想通过暗示和传染，被引到某个方向，可能立即就会把所暗示的思想变成行动，这就是群体中的个人的主要特征。</strong></p>
<ul>
<li>自觉的个性消失和感情与思想朝某个既定的方向发展，这是群体正在形成的最初特征</li>
<li>在集体心理中，个人的智力差异削弱了，个性也消失了。异质淹没在同质中，无意识的特点占了上风。</li>
<li>人在智力上相差很大，却会有非常相似的本能和感情。在感情方面，宗教感情、政治感情、道德感情以及爱憎方面，最杰出的人物也不见得比最普通的人做得更好。</li>
<li>只要他属于有组织的群体中的一员，他就在文明的阶梯上倒退了好几步。</li>
<li><strong>群体在智力上总是劣于独处的个人，不过，从情感的角度以及这种情感引起的行为来看，群体会根据情况的不同表现得更好或更糟。一切都取决于群体被暗示的方式</strong></li>
</ul>
<p>原因：</p>
<ul>
<li>第一个原因是群体中的个人仅因人多势众，就会感到有种不可战胜的力量。这种力量会让他感情用事，而他单独一人时肯定会有所收敛。群体无名无姓，因此可以不负责任，当束缚个人行为的责任感完全消失时，人便会肆意妄为。</li>
<li>第二个原因是传染性，它也会影响群体，决定群体会表现出什么特点，有什么取</li>
<li>第三个原因，也是最重要的原因，它决定了群体中的个人有时会呈现出与他独处时完全相反的特性。我指的是容易接受暗示。</li>
</ul>
<h3 id="群体的感情与道德"><a href="#群体的感情与道德" class="headerlink" title="群体的感情与道德"></a>群体的感情与道德</h3><ol>
<li>群体的冲动、多变与易怒：独处的个人能控制自己的反应能力，而群体却缺乏这种能力。</li>
<li>群体易受暗示、多变和轻信：<ul>
<li>一个群体，要失去实事求是的能力，让真实的东西被跟它毫无关系的幻觉所代替，并不需要很多人。几个人聚在一起就构成了群体。那时，即使是杰出的学者，面对专业以外的东西，他们也会表现出群体的所有特征，每个人的观察能力和批评精神都消失了。</li>
<li>集体观察是错误率最高的，它往往只是某个人的幻觉，通过传染，暗示给别人。</li>
<li>说某事是成千人同时看见的，这往往意味着事实真相与人们所说的大相径庭。</li>
</ul>
</li>
<li><p>群体感情的夸大化和简单化(<strong>读到这一段，我决定重新读《思考，快与慢》</strong>)</p>
<ul>
<li>在群体中，蠢人、白痴和妒忌者不会再感到自己平庸和无能，而是产生了一种强烈、短暂却巨大的力量。</li>
<li>由于夸大自己的感情，群体只会被极端的感情所打动。演说家为了吸引众人，势必滥用词汇，斩钉截铁。夸大、断言、重复，绝不会经过理性思考之后再表明看法。众所周知，这是公共集会上的演说家所惯用的辩术。</li>
<li>同样，群体也希望夸大英雄人物的感情，总是放大他们的优点和品德。</li>
</ul>
</li>
<li><p>群体的褊狭、专横和保守</p>
<ul>
<li>群体只拥有简单和极端的感情。他们全盘接受或一概拒绝被暗示给他们的意见、主张和信仰，把它们当作是绝对正确或是完全错误的东西。通过暗示而不是通过理性而产生信仰，结果总是如此。大家都知道宗教信仰是多么褊狭，它对灵魂的统治又有多么专制。</li>
</ul>
</li>
<li><p>群体的道德</p>
<ul>
<li>如果说群体常常服从低劣的本能，有时也可以作为品德高尚和道德崇高的典范</li>
</ul>
</li>
</ol>
<h3 id="群体的观念、推理和想象力"><a href="#群体的观念、推理和想象力" class="headerlink" title="群体的观念、推理和想象力"></a>群体的观念、推理和想象力</h3><ol>
<li><p>群体的观念</p>
<ul>
<li>我们能看见群体中并存着十分矛盾的观念。不同的时期，群体会受自己所接受的各种观念的影响，做出很不相同的事情。由于完全缺乏批评精神，它们看不见这些矛盾。</li>
<li>从社会的角度来看，观念的等级价值并不重要。需要重视的，是它所造成的影响。</li>
</ul>
</li>
<li><p>群体的推理</p>
<ul>
<li>正因为群体不懂得推理，所以他们毫无批评精神，也就是说，他们分不清是非，不能对事情作出正确的判断。</li>
<li>群体的判断总是被强加的，而不是经过讨论获得的。在这方面，许多人都不比群体高明，有的观念能轻而易举地被大众所接受，就是因为大部分人都不能根据自己的推理得出个人的看法。</li>
</ul>
</li>
<li><p>群体的想象力</p>
<ul>
<li><strong>群体不会思考，不会推理，对再怎么不可思议的事情也深信不疑，或者说，最不真实的东西往往最能打动他们</strong>。</li>
<li>如何才能给群体的想象力留下深刻的印象呢？我们很快就会知道，现在，首先可以肯定的是：绝对不是通过他们的智慧或理智。（<strong>《思考，快与慢》中的观点是大部分情况是“系统一”在起作用</strong>）</li>
<li>所有能打动群体想象力的东西都具有突出和清晰的形象，没有任何多余的解释，或者，只伴以某些美好或神秘的事实：一场伟大的胜利，一个不可思议的奇迹，一桩滔天的罪行，一个巨大的希望。要笼统地概括，而不要从头道来。</li>
<li><strong>影响大众想象力的不是事实本身，而是它所扩散和传播的方式。</strong> 只有通过“浓缩”的办法——如果可以这样说的话，事实才能造成突出的形象，让人难以忘怀。谁能影响群体的想象力，谁就掌握了驾驭他们的艺术。 （<strong>比较吓人，群里会忽视事实本身，人云亦云</strong> ）</li>
</ul>
</li>
</ol>
<h3 id="群体的所有信仰都采取宗教形式"><a href="#群体的所有信仰都采取宗教形式" class="headerlink" title="群体的所有信仰都采取宗教形式"></a>群体的所有信仰都采取宗教形式</h3><ul>
<li>对群体来说，必须有个神，否则什么都谈不上。<br>这章没啥好记的</li>
</ul>
<h2 id="群体的主张和信念"><a href="#群体的主张和信念" class="headerlink" title="群体的主张和信念"></a>群体的主张和信念</h2><h3 id="群体的信念与主张的间接因素"><a href="#群体的信念与主张的间接因素" class="headerlink" title="群体的信念与主张的间接因素"></a>群体的信念与主张的间接因素</h3><ul>
<li>种族</li>
<li>传统</li>
<li>时间</li>
<li>政治与社会制度</li>
<li>智育和德育</li>
</ul>
<h3 id="群体主张的直接因素"><a href="#群体主张的直接因素" class="headerlink" title="群体主张的直接因素"></a>群体主张的直接因素</h3><ol>
<li>形象、词语和套话：词语的威力太强大了，只要好好选择，就可以给最讨厌的东西取个好名，让大家都接受</li>
<li>幻觉：群体从来不渴望真理。面对他们不喜欢的明显事实，它们会转过身去，宁可把谬论奉为神明，只要这种谬论吸引它们。谁能让他们产生幻想，谁就能轻易地主宰他们；谁试图破灭他们的幻想，谁就将永远成为他们的敌人。</li>
<li>经验</li>
<li>理性：<ul>
<li>盘点能给群众心理留下深刻印象的各种因素时，可以完全不提理性，除非是要指出它的负面价值。</li>
<li>群体不会受理性的影响，只明白粗粗地拼凑起来的观念。</li>
<li>要说服群体，首先必须察觉到他们被激起的感情，假装与之分享，然后试着去修改它</li>
<li>必要的时候要懂得半路折回，尤其要随时猜测他们所产生的感情。</li>
<li>必须根据演说的效果不断调整自己的措辞，这会大大好过事先经过思考和准备的演讲。一个演说家，如果只顾着自己的思路说话而不顾听众的感受，是绝对产生不了什么影响的。</li>
</ul>
</li>
</ol>
<h3 id="群体领袖及其说服方式"><a href="#群体领袖及其说服方式" class="headerlink" title="群体领袖及其说服方式"></a>群体领袖及其说服方式</h3><ol>
<li>群体的领袖：<ul>
<li>群体最想得到的，并不是自由，而是被奴役。他们非常渴望服从，本能地臣服于自称为他们领袖的人</li>
<li>我们可以把领导阶级作一个明确的划分。第一类是强有力的人，意志坚强，但持续的时间很短；第二类比第一类少很多，他们的意志坚强而又持久</li>
</ul>
</li>
<li>领袖起作用方式：断言、重复和传染<ul>
<li>如果要迅速带领一帮人，让他们下决心去做某件事：抢劫宫殿、为保护要塞或街垒而牺牲自己，必须通过迅速的暗示来影响他们，最管用的还是榜样的力量。</li>
<li>断言得越干脆，越没有拖拖拉拉的证明和解释，便越有权威。</li>
<li>断言只有不断重复才能产生真正的影响。</li>
<li>来自重复的这种力量，最后会铭刻在人们的无意识深处，产生行动的动机。人们很快就会忘记这种不断重复的论断是谁下的，都对它深信不疑</li>
<li>断言重复到一定的次数，就得到了大家的一致认可，强大的传染机制就开始起作用了。（<strong>一旦得到大家的认可，社会认同的威力就开始显现出来</strong>）</li>
</ul>
</li>
<li>声望：被断言、重复和传染所推广的思想之所以强大，是因为它最后总会获得被叫做“声望”的神秘力量。（<strong>在影响力中，可能被称之为“权威”</strong>）</li>
</ol>
<h3 id="群体信念与主张的变化范围"><a href="#群体信念与主张的变化范围" class="headerlink" title="群体信念与主张的变化范围"></a>群体信念与主张的变化范围</h3><ol>
<li>牢固的信念<ul>
<li>群体的信念和主张分两个非常明显的层次。一方面是恒久、强烈的信念，能持续几个世纪，整个文明都可以建立在它上面，比如过去的封建意识、基督教思想和宗教改革思想；又如现在的民族主义原则、民主和社会观念；</li>
<li>另一方面，是暂时的、多变的主张，它们往往来自普遍的观念，每个时期都有生有灭，指导某一时期艺术和文学的理论就是这类主张，如产生了浪漫主义、自然主义和神秘主义的理论等等。它们往往跟时尚一样表面而多变。那是一些小小的涟漪，不断地在深深的湖水表面泛起和消失</li>
</ul>
</li>
<li>群体多变的主张</li>
</ol>
<h2 id="不同群体的分类及特点"><a href="#不同群体的分类及特点" class="headerlink" title="不同群体的分类及特点"></a>不同群体的分类及特点</h2><h3 id="群体的分类"><a href="#群体的分类" class="headerlink" title="群体的分类"></a>群体的分类</h3><ol>
<li><p>异质性群体：它们可以由任何人组成，不管其职业或文化程度如何</p>
<ul>
<li>无名称（比如街头人群）</li>
<li>有名称（陪审团、议会等）</li>
</ul>
</li>
<li><p>同质性群体</p>
<ul>
<li>派别（政治派别、宗教派别等）</li>
<li>身份团体（军人、僧侣、工人等）</li>
<li>阶级（资产阶级、农民阶级等）</li>
</ul>
</li>
</ol>
<p>剩下的几章没什么重点，只做目录梳理，需要的时候再看书    </p>
<h3 id="犯罪群体"><a href="#犯罪群体" class="headerlink" title="犯罪群体"></a>犯罪群体</h3><h3 id="重罪法庭的陪审团"><a href="#重罪法庭的陪审团" class="headerlink" title="重罪法庭的陪审团"></a>重罪法庭的陪审团</h3><h3 id="选民群体"><a href="#选民群体" class="headerlink" title="选民群体"></a>选民群体</h3><h3 id="议会群体"><a href="#议会群体" class="headerlink" title="议会群体"></a>议会群体</h3>]]></content>
      <categories>
        <category>通用能力</category>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>影响力</title>
    <url>/2020/01/19/%E5%BD%B1%E5%93%8D%E5%8A%9B/</url>
    <content><![CDATA[<p>动物可能会因为看到某种颜色的羽毛而变得具有攻击性，或是听到某种叫声就对自己的天敌呵护有加。动物这种愚蠢可笑的机械反应在人类身上也有，当某一个触发特征出现时，我们会不假思索地作出相应的反应。之所以会这样，就是因为我们被难以察觉的影响力武器摆布了。</p>
<p>一是这类武器有能力激活一种近乎机械化的过程；二是只要掌握了触发这种过程的能力，人们就能从中渔利。而第三点则是，使用者能借助这些自动影响力武器的威力，这种武器就好像一根沉甸甸的大棒，只要用了它，就能让另一个人乖乖就范。</p>
<p><strong>我们要采取一切合理的方法——抵制、威胁、对峙、谴责、抗议来报复以刺激我们的捷径反应为目的的虚假信号。</strong><br><a id="more"></a></p>
<h2 id="互惠"><a href="#互惠" class="headerlink" title="互惠"></a>互惠</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>著名考古学家理查德·李基（RichardLeakey）认为：正是因为有了互惠体系，人类才成为人类。<br>原理确立起来，是为了推动个人之间互惠关系的发展，如此一来，首先发起这种关系、头一个表示善意的人就不必担心会有损失</li>
<li>互惠原理认为，我们应该尽量以类似的方式报答他人为我们所做的一切。<strong>简单地说，就是对他人的某种行为，我们要以一种类似的行为去加以回报。</strong>如果人家施恩于你，你就应该以恩情报之，而不能对此不理不睬，更不能以怨报德。于是，我们身边这一最有效的影响力武器，就被某些人利用谋取利益了。</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>互惠原理的威力大到了这样的地步：其他人，不管有多奇怪、讨厌、不受欢迎，只要先给我们点小恩小惠，就能提高我们照着其要求做的概率。然而，除了威力大，该原理还有另一个方面，<strong>它居然允许这种情况的发生：一个人靠着硬塞给我们一些好处，就能触发我们的亏欠感。</strong></li>
<li>尽管偿还义务构成了互惠原理的实质，可使原理那么容易遭到利用的，则在于接受的义务。有了接受的义务，欠谁的人情就不归我们选择了，反过来还落到了对方的手里。</li>
<li>亏欠感让人觉得很不舒服。违背互惠原理，接受而不试图回报他人善举的人，是不受社会群体欢迎的。</li>
</ul>
<p><strong>互惠原理和知觉对比原理能产生一种令人望而生畏的强大力量。拒绝—后撤手法便是把它们捏在一起，发挥出惊人效用的</strong></p>
<h3 id="如何拒绝"><a href="#如何拒绝" class="headerlink" title="如何拒绝"></a>如何拒绝</h3><ul>
<li>拒绝请求者最初的善意或让步，大概可以让我们成功回避这一问题</li>
<li>倘若别人的提议我们确实赞同，那就不妨接受它；倘若这一提议别有所图，那我们就置之不理</li>
<li>善意自然应当以善意回报，可对销售策略却没这个必要。互惠原理公正的做法是，以牙还牙，以眼还眼，不必为拒绝别人内疚。</li>
</ul>
<h2 id="承诺和一致"><a href="#承诺和一致" class="headerlink" title="承诺和一致"></a>承诺和一致</h2><p>承诺和一致原理认为，一旦作出了一个选择或采取了某种立场，我们就会立刻碰到来自内心和外部的压力迫使我们的言行与它保持一致。在这样的压力之下，我们想方设法地以行动证明自己先前的决定是正确的。（人类误判心理学也有一种说法：避免不一致）</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li>信仰、言语和行为前后不一的人，会被看成是脑筋混乱、表里不一，甚至精神有毛病的。另一方面，言行高度一致大多跟个性坚强、智力出众挂钩，它是逻辑性、稳定性和诚实感的核心</li>
<li>和大多数其他自动响应方式一样，它为穿越复杂的现代生活提供了一条捷径</li>
<li><strong>承诺是关键。哪怕在作出最终决定之前已经有了一个初步的倾向，它也会让我们在这之后偏爱与之一致的选择。</strong></li>
<li>要想让承诺达到这样的效果，必须满足一定的条件：它们得是当事人积极地、公开地、经过一番努力后自由选择的</li>
<li><strong>行为是确定一个人自身信仰、价值观和态度的主要信息源</strong>（我现在能理解为什么类似传销的组织都要求喊口号，做各种仪式性很强的活动了。想改变一个人的思想，或许可以从改变行为开始。）</li>
<li>一方面人们内心里有压力要把自我形象调整得与行为一致；另一方面，外部还存在一种更为鬼祟的压力，<strong>人们会按照他人对自己的感知来调整形象。</strong></li>
<li>为一个承诺付出的努力越多，它对承诺者的影响也就越大。</li>
<li><strong>只有当我们认为外界不存在强大的压力时，我们才会为自己的行为发自内心地负起责任。</strong>优厚的奖品就属于此类外部压力，它可以让我们去执行某一行动，但并不足以让我们自觉自愿地对此行动负起责任。顺理成章地，我们也不会觉得该对它有什么承诺。强大的威胁也一样：它能叫人当场顺从，但却不大可能带来长期的承诺感。</li>
</ul>
<h3 id="如何拒绝-1"><a href="#如何拒绝-1" class="headerlink" title="如何拒绝"></a>如何拒绝</h3><ul>
<li>尽管保持一致一般而言是好的，甚至十分关键，我们也必须避免愚蠢的死脑筋。</li>
</ul>
<h2 id="社会认同"><a href="#社会认同" class="headerlink" title="社会认同"></a>社会认同</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><ul>
<li>社会认同原理认为，在判断何为正确时，我们会根据别人的意见行事。这一原理尤其适用于我们对正确行为的判断，特定情形下在判断某一行为是否正确时，我们的看法取决于其他人是怎么做的。</li>
<li>举了一个城市中被匪徒捅了刀子却没人救的例子。旁观者群体没能帮忙，不是因为他们无情，而是因为他们不能确定。他们不帮忙，因为他们无法确定紧急情况真的存在，也无法确定此时是否需要自己采取行动。只要他们明确地意识到自己有责任插手干预紧急事件，他们是一定会作出反应的。</li>
</ul>
<p><strong>一般而言，在需要紧急救助的时候，你的最佳策略就是减少不确定性，让周围人注意到你的状况，搞清楚自己的责任。</strong></p>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ul>
<li>社会认同原理发挥作用的一个重要条件：我们会根据他人的行为来判断自己怎么做才合适，尤其是在我们觉得这些人跟自己相似的时候。比如小孩不会认同大人，只会认同同龄人。</li>
<li>社会认同原理的一个病态例证：这些人根据其他陷入困境的人如何行动，决定自己该怎么做。（陷入困境的人自杀了，有相同情况的人也自杀）</li>
<li>影响力最强的领导者是那些知道怎样安排群体内部条件、让社会认同原理朝对自己有利方向发挥作用的人。</li>
</ul>
<h3 id="如何拒绝-2"><a href="#如何拒绝-2" class="headerlink" title="如何拒绝"></a>如何拒绝</h3><ul>
<li>首先，我们似乎持有这样的假设：要是很多人在做相同的事情，他们必然知道一些我们不知道的事情。尤其在我们并不确定的时候，我们很乐意对这种集体智慧投入极大的信任。</li>
<li>其次，人群很多时候都是错的，<strong>因为群体的成员并不是根据优势信息才采取行动，而只是基于社会认同原理在做反应。</strong></li>
<li>人绝对不应该完全信任类似社会认同这种自动导航装置，哪怕没有坏分子故意往里面添加错误信息，它自己有时候也会发生故障。</li>
</ul>
<h2 id="喜好"><a href="#喜好" class="headerlink" title="喜好"></a>喜好</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><ul>
<li>外表魅力</li>
<li><strong>相似性：请求者还有另一种利用相似点提高好感、增加顺从概率的办法：他们假装跟我们有着相似的背景和兴趣。</strong></li>
<li>恭维：人性中的一个重要事实，我们特别喜欢听人恭维奉承</li>
<li>接触与合作：大多数时候，我们都喜欢自己熟悉的东西。</li>
<li><strong>条件反射和关联：糟糕的消息会让报信人也染上不祥。人总是自然而然地讨厌带来坏消息的人，哪怕报信人跟坏消息一点关系也没有。</strong>光是两者之间存在联系，就足以引发我们的厌恶了。不管是好事还是坏事，只要跟我们偶然联系在了一起，就都会影响人们对我们的感觉。（如粉丝就是把自己和偶像、球队关联在了一起）</li>
</ul>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><ul>
<li>在决定是否购买该产品时，社会纽带的影响要比消费者对产品本身的好恶强两倍</li>
<li><strong>人们深明关联原理的奥妙，并努力把自己跟积极的事情联系起来，跟消极的事情保持距离——哪怕他们并非事情的起因</strong></li>
<li>我们展示积极的联系，隐藏消极的联系，努力让旁观者觉得我们更高大，更值得喜欢。</li>
<li>在我们以个人成就为傲的时候，我们不会沾别人的光。只有当我们在公在私的威望都很低的时候，我们才会想借助他人成功来恢复自我形象。（自我意识太差。他们内心深处的个人价值感过低，没办法靠推动或实现自身成就来追求荣誉，只能靠着吹嘘自己与他人成就的关系来找回尊严）</li>
</ul>
<h3 id="如何拒绝-3"><a href="#如何拒绝-3" class="headerlink" title="如何拒绝"></a>如何拒绝</h3><ul>
<li>用来诱使我们产生好感的东西，不必提防，只要当心它们带来的过度好感就行。一旦我们觉得自己对顺从专家的好感超出了该场合下的正常程度，就是唤出防御机制的时机了。</li>
<li>不去压抑好感因素产生的影响力，听凭这些因素发挥力量，然后用这股力量反过来对付那些想从中获利的人。这股力量越大，其反作用也就越明显，对我们的戒备防御也就越有帮助。</li>
<li>在我们作出顺从决定时，把提出请求的人和请求本身从感性上分开，这是很明智的。意识到这种好感，能提醒我们把交易者和交易分开，只根据生意本身的好坏作决定。</li>
</ul>
<h2 id="权威"><a href="#权威" class="headerlink" title="权威"></a>权威</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><ul>
<li>服从权威人物的命令，总是能给我们带来一些实际的好处。（如家长、老师、老板等）</li>
<li>头衔：头衔比当事人的本质更能影响他人的行为</li>
<li>衣着</li>
<li>身份标志</li>
</ul>
<h3 id="如何拒绝-4"><a href="#如何拒绝-4" class="headerlink" title="如何拒绝"></a>如何拒绝</h3><ul>
<li>碰到貌似权威的人物在试图发挥影响力的时候，我们要问的第一个问题是：“这个权威是真正的专家吗？”这个问题能让我们把焦点放在两点关键信息上：权威的资格，以及这些资格是否跟眼前的主题相关。</li>
</ul>
<h2 id="稀缺"><a href="#稀缺" class="headerlink" title="稀缺"></a>稀缺</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><ul>
<li><strong>对失去某种东西的恐惧，似乎要比对获得同一物品的渴望，更能激发人们的行动力。</strong></li>
<li>逆反心理：机会越来越少的话，我们的自由也会随之丧失。而我们又痛恨失去本来拥有的自由。<strong>保住既得利益的愿望，是心理逆反理论的核心。</strong>根据这个理论，只要选择自由受到限制或威胁，保护自由的需求就会使我们想要它们（以及与其相关的商品和服务）的愿望愈发强烈。因此，一旦短缺——或其他因素妨碍我们获取某物，我们就会比从前更想得到它，更努力地想要占有它，跟这种妨碍对着干。</li>
</ul>
<h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><ul>
<li>每当有东西获取起来比从前难，我们拥有它的自由受了限制，我们就越发地想要得到它。不过，我们很少意识到是逆反心理带来了这种想要的迫切感，而只知道自己就是想要。</li>
<li>到了手的自由，不经一战是没人会放弃的。这个道理不光适用于国家政治，家庭也是一样。父母随随便便地许诺权利、设定规矩，有可能在无意之间给了孩子一些自由，之后再想夺走这些自由的话，孩子们必然会反抗不休</li>
<li>渴望拥有一件众人争抢的东西，几乎是出于本能的身体反应。</li>
</ul>
<h3 id="如何拒绝-5"><a href="#如何拒绝-5" class="headerlink" title="如何拒绝"></a>如何拒绝</h3><ul>
<li>一旦在顺从环境下体验到高涨的情绪，我们就可以提醒自己：说不定有人在玩弄稀缺手法，必须谨慎行事。</li>
<li>我们务必记住：稀缺的东西并不因为难以弄到手，就变得更好吃、更好听、更好看、更好用了。</li>
<li>一旦我们觉得自己在短缺影响下产生了高度的情绪波动，我们就应该把这种波动当成暂停的信号。要作出明智的决定，恐慌、狂热的反应是不合适的。我们需要冷静下来，重拾理性的眼光。只要做到了这一点，我们就可以转入第二个阶段：问问自己，为什么我们想要那件东西。如果答案是我们想要它主要是因为想拥有它，那么我们应当利用它的稀缺性来判断该为它出多少钱。倘若答案是我们想要它主要是为了它的功能（也即想要驾驶它、喝它或吃它），那么我们必须牢记一点：该物品不管是稀缺还是充足，其功能都是一样的。简而言之，稀缺的饼干并没有变得更好吃。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>它们之所以最为常用，完全是因为它们的可靠性高，一般都能指引我们作出正确决定。这就是为什么我们会这么频繁地利用互惠、承诺和一致、社会认同、喜好、权威和稀缺等方面的因素自动作出顺从决定。究其本源，上述每一方面的因素都是极为可靠的线索，都能提示我们在何时说“是”要比说“不”更恰当。</li>
<li>靠着成熟而精密的大脑，我们建立了一个信息繁多的快节奏复杂世界，使得我们不得不越发依赖类似动物（我们早就超越了的动物！）的原始反应方式来应对它。</li>
<li>倘若顺从业者公平公正地利用我们的捷径响应方式，我们就不应该把他们看成是敌人，事实上，他们是我们的盟友，有了他们，我们能更方便地开展高效率、高适应度的生意往来。只有那些通过弄虚作假、伪造或歪曲证据误导我们快捷响应的人才是正确的还击目标。</li>
</ul>
]]></content>
      <categories>
        <category>通用能力</category>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计方法概述</title>
    <url>/2019/12/25/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>尝试用“说人话”的方式讲清楚架构设计方法。<br>如果你之前看过其他架构文章，emmm…..先忘了它</p>
<h2 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h2><p>对架构是否有以下疑问：</p>
<ul>
<li>成天说的架构是在说什么？</li>
<li>面试让画架构图该画什么？</li>
<li>我知道这个东西很重要，但就是不知道怎么存在？</li>
<li>什么是好的架构？</li>
<li>如何做架构设计？</li>
<li>知道有架构师岗位，他们在做什么？</li>
<li>看到过一些文章，XXX高可用架构，XXX高性能实践，XXX架构演进，怎么说的都不一样？</li>
<li>。。。欢迎补充</li>
</ul>
<a id="more"></a>
<p>“架构”这个东西不仅存在于软件领域，日常生活中随处可见！软件系统中的“架构”可能抽象了些产生上述各种疑问。</p>
<p>在谈论什么是架构之前，先看下架构如何产生的会更合适，网上有篇文章说的比较好，我摘下：</p>
<blockquote>
<p><a href="https://www.infoq.cn/article/an-informal-discussion-on-architecture-part01" target="_blank" rel="noopener">https://www.infoq.cn/article/an-informal-discussion-on-architecture-part01</a><br>总结一下，什么是架构，就是：</p>
<ol>
<li>根据要解决的问题，对目标系统的边界进行界定。</li>
<li>并对目标系统按某个原则的进行切分。切分的原则，要便于不同的角色，对切分出来的部分，并行或串行开展工作，一般并行才能减少时间。</li>
<li>并对这些切分出来的部分，设立沟通机制。</li>
<li>根据 3，使得这些部分之间能够进行有机的联系，合并组装成为一个整体，完成目标系统的所有工作。</li>
</ol>
</blockquote>
<p><strong>说人话：解决问题的方式就是架构！！</strong></p>
<p>生活中的例子：</p>
<ul>
<li>公司层面：组织架构 -&gt; 解决字节跳动整个公司的问题</li>
<li>国家层面：政府机构 -&gt; 解决整个国家面临的问题</li>
<li>学科层面：生物分类 -&gt; 解决XXX问题</li>
</ul>
<p>回到软件领域，看看我们用了哪些东西解决问题。这些“东西”组成了架构，可能包括了 服务、存储、机器、协议 等。这就是架构，它看起来可能长下面👇这个样子：<br><img src="/img/15772630513056.jpg" alt></p>
<p>画的简单了些，但基本描述了我们解决问题的方式：<br>客户端：解决用户触达问题<br>api层：解决与客户端通信问题<br>服务层：解决数据读写问题<br>存储层：解决数据存储问题<br>基础组件：解决可用性、性能、统计 等问题。</p>
<h2 id="架构挑战"><a href="#架构挑战" class="headerlink" title="架构挑战"></a>架构挑战</h2><h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><ul>
<li>初期：探索阶段，业务策略不明确，需求变化快</li>
<li>中期：快速增长阶段，功能多，越来越复杂</li>
</ul>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ul>
<li>可用性</li>
<li>性能</li>
<li>扩展性</li>
<li>安全</li>
<li>正确性（幂等、一致性、业务逻辑等）<br>上面列的每一个点，都足以展开专项讲解。网上的一些架构文章通常离不开这几个方面：怎么达到4个9，怎么做故障恢复，监控怎么做，性能怎么保障，安全策略 等等等。</li>
</ul>
<p>技术架构可以通过架构五视图(架构五视图就不展开说明了)表达：</p>
<ul>
<li>逻辑架构</li>
<li>数据架构</li>
<li>运行架构</li>
<li>部署架构</li>
<li>开发架构</li>
</ul>
<p>技术维度的好坏可以评估：可用性几个9，性能多少，吞吐量多少，是否有安全问题等。</p>
<h3 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h3><ul>
<li>组织结构：团队职责划分、职责边界以及 及时调整组织结构。</li>
<li>人员分工：人员技能、兴趣、发展空间。</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>降低复杂度、快速响应(应对变化)、风险可控</p>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p><strong>说人话：将大的问题拆成小的问题，逐个解决。</strong></p>
<p>拿前面管理国家例子作说明：<br>管理国家的问题域，将问题分解，建立相应政府机构：<br><img src="/img/15772632135617.jpg" alt></p>
<ul>
<li>每个政府机构解决自己领域擅长内的问题 -&gt; 复杂度降低；专业人做专业事情 -&gt; 高效。</li>
<li>需要办事、政策调整 找到相应机构即可  -&gt; 边界清晰。</li>
<li>某个机构出了问题对其他机构影响较小 -&gt; 风险可控。</li>
</ul>
<p>以上三点很好的说明了”高内聚、低耦合”系统的特点。<br>顺便提一下，耦合是必然的，因为单独模块完成不了全部功能。要做到的是尽可能降低耦合。</p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p><strong>说人话：逐级分类整理。</strong></p>
<p>分治好像已经解决了所有问题为什么还需要抽象？因为上面的例子已经做了抽象。</p>
<p>将问题拆解，得到的可能是膨胀的问题域，相应的解决方案也会膨胀。需要对问题域进行归纳总结。<br>继续拿国家举例子，问题域可能有这些：</p>
<ul>
<li>足球如何发展</li>
<li>流行歌曲发展方向</li>
<li>会计标准是否要改</li>
<li>铁矿石进口量</li>
<li>小麦增收</li>
<li>养老金和退休政策如何制定</li>
<li>要不要再建个水电站</li>
<li>药品定价</li>
<li>等等等等等等<br>如果任由问题域膨胀，不做梳理，问题域依然复杂。所以需要对问题进行抽象，统一管理，让“专业人做专业事情”。</li>
<li>足球、体操、游泳 怎么抽象? -&gt; 体育</li>
<li>国画、芭蕾、钢琴 怎么抽象? -&gt; 艺术</li>
<li>体育、艺术、音乐 怎么抽象? -&gt; 文化</li>
</ul>
<p>抽象可以很好地将问题收敛，做到“高内聚”。<br>上面国务院政府机构图已经是对所有问题域高度抽象后的表示，每个政府机构还可以拆解成很多层。</p>
<h4 id="如何抽象"><a href="#如何抽象" class="headerlink" title="如何抽象"></a>如何抽象</h4><ul>
<li>有最佳实践按照最佳实践。如政府机构设置，都发展上千年了，大的框架不会变，照着弄就行。</li>
<li>从未接触过的问题域：从下到上，将问题不重不漏列出来，做归纳总结。举个例子：生物分类，人类一开始不可能知道全部生物，随着知道的生物越多，归纳总结出一套分类方法：<br><img src="/img/15772632971263.jpg" alt></li>
</ul>
<ul>
<li>说人话：没有对错，团队讨论达成一致就行，你说这样抽象那就这样抽象。 比如图书分类，一本书既是传记又是历史，但只能把他放到一个架子上，放哪个都说得通。这种情况需要让子弹飞一会儿，对业务有了更深理解后再去看如何调整。所以业务初期的方案满足当下需求就好，预估变化做预案，不需要实现，一旦发生变化能及时调整。<h3 id="迭代演进"><a href="#迭代演进" class="headerlink" title="迭代演进"></a>迭代演进</h3><strong>说人话：不可能一次做“对”，后续可以改。</strong></li>
</ul>
<p>架构设计不可能一蹴而就，也不可能一套方案能够应对后面所有变化。<br>或许经常看到以下新闻：</p>
<ul>
<li>某某政府机构撤销、合并</li>
<li>XXX公司组织结构升级</li>
<li>养老金&amp;退休政策调整</li>
<li>XXXX的发现可能推翻现有科学体系</li>
</ul>
<p>调整原因大部分是面临的问题域发生了变化，原有的架构不能满足。<br>同样，软件架构体系也需要迭代演进。若不调整，可能出现各种各样的问题，表现可能是：</p>
<ul>
<li>业务出错变多</li>
<li>性能变差</li>
<li>可用性降低</li>
<li>迭代变慢</li>
<li>人员流失 </li>
<li>等等等等。</li>
</ul>
<p>同理，软件架构的迭代演进可能是理解上的演进，也可能是架构的演进，需要 移动、合并、分解、新增等。<br><img src="/img/15772633736611.jpg" alt><br>讲个段子：<br>员工造了轮子，兴奋地跟老板说“我造了几个轮子，可牛X了，能解决XXXX问题，给我升职加薪！”<br>老板：好。<br>过段时间。<br>员工：“我融合掉了好几个轮子，节省了很多开销，给我升职加薪！”<br>老板内心os：“你tm逗我呢”</p>
<p>这里解释下“理解上的演进”:</p>
<blockquote>
<p>冲突不在于客观事实本身，而在于人们的思考方式上。</p>
</blockquote>
<p>同一事实，看问题的角度不同，得到的结果也不同。</p>
<ul>
<li>应该都听过三个工人立墙的故事。一个人认为就是在立一面墙，一个人认为是在造一栋楼，一个人认为是在造一座城。</li>
<li>再比如“写单测”。刚毕业同学可能认为没必要，多此一举；服务负责人认为是提升代码质量；项目负责人认为是“提升服务可用性”；换一个党员来看，可能认为在建设美好社会主义😆。<h4 id="在什么时间点调整"><a href="#在什么时间点调整" class="headerlink" title="在什么时间点调整"></a>在什么时间点调整</h4>可参考《重构》里提到的代码重构时机。</li>
</ul>
<ol>
<li>当前版本调整：已经识别到此次需求需要调整架构，那么当前版本不仅要完成产品需求，还要完成技术改造。</li>
<li>发生case时：找到case的根本原因，使用长期方案解决问题。短期方案是头痛医头，脚痛医脚。长期方案若需要对架构进行调整，不要担心成本大，果断执行，长期看收益还是值得的。</li>
<li>专门的调整：某些问题已经很严重，单独的项目来做。</li>
</ol>
<h2 id="如何落地"><a href="#如何落地" class="headerlink" title="如何落地"></a>如何落地</h2><h3 id="业务-1"><a href="#业务-1" class="headerlink" title="业务"></a>业务</h3><p>DDD: 领域、限界上下文划分对服务化做了很好的指导。(不展开讲DDD,简单理解为面向对象的升级。)<br>比如供应链领域业务划分：</p>
<ul>
<li>核心域：系统的核心价值所在，承载着一个系统的重中之重。</li>
<li>支撑域：专注于业务系统某一重要业务，支撑和完善业务系统。</li>
<li>通用域：提供通用服务。<br><img src="/img/15772634271371.jpg" alt></li>
</ul>
<p>每个虚线圈是一个子领域，每个实线圈是一个限界上下文。</p>
<ul>
<li>一个服务 &lt;= 一个领域，避免服务内领域歧义</li>
<li><p>一个服务 &gt;= 一个聚合，避免分布式事务。<br>按照上图的划分，技术架构应该有订单域、商品域等，里面会有订单服务、商品服务等，通过业务就能知道一些服务，技术架构也要体现业务含义。</p>
</li>
<li><p>虚线最重要的意义在于 合理划分边界，为后面的“高内聚、低耦合”打下基础。<br>细胞之所以会存在，是细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。</p>
<ul>
<li>业务架构没有量化指标看好坏，谁也不能确定业务这样划分、这样做一定是最好的。不同人理解不一样，团队内部达成一致即可。需要注意的是，这里的“团队”不仅仅指的是技术团队，而是和业务相关的所有团队：产品、技术、运营、设计等。大家讨论得出结论即可。这个划分不是一成不变，后续随着业务调整，对业务理解加深，相应的术语、划分都需要调整。题外话，为什么招聘有时候要求“相关经验”? “相关经验”的人对问题域理解深刻，可以避免采坑，来回调整多伤。</li>
<li>这个大圈体现的是“供应链业务”，每个虚线圈还可以继续按照这种方式拆解：“供应链业务”就是从更大的圈中细化出来的。比如，“供应链业务”是在 “XX电商业务”的一个子域。想象有一个放大镜🔍，在电商业务看“供应链业务”就得到了这个圈。同样，“电商业务”可能是某个bg的子域，bg业务又是公司所有业务的一个子域。（ps:看到抽象了没）</li>
</ul>
</li>
</ul>
<h3 id="技术-1"><a href="#技术-1" class="headerlink" title="技术"></a>技术</h3><p>关注点分离。</p>
<ul>
<li>职责划分：功能维度，如优惠券场景，发券、领券等。</li>
<li>稳定通用：变&amp;不变分离，通用&amp;专用分离。分层架构：横切竖割，纵向分层，横向模块化。</li>
<li><p>技术维度</p>
<ul>
<li>读写分离</li>
<li>多少分离：大v场景</li>
<li>轻重分离：业务逻辑复杂的抽出来。</li>
<li>快慢分离：耗时久的拆分出来，如一些离线任务等。</li>
</ul>
</li>
<li><p>技术架构整体上分为 核心域、通用域、支撑域，每个领域内可以按照“关注点”分离进行服务化。类似开场的那张架构图。只不过技术架构需要体现业务架构，在逻辑上需要调整下：</p>
<ul>
<li>列出现有的所有服务，根据团队达成的结论，放到相应子域内。</li>
<li>子域内部架构按照前面说的“关注点分离”进行设计，比如当前有api层、服务层等。</li>
<li>子域内重复的服务可以废弃、合并，耦合的进行迁移，该拆分的拆分，该新增的新增。</li>
<li>领域间只能通过接口访问 功能+数据。</li>
</ul>
</li>
<li>每个子域都是有生命的“对象”，对象两大特点：行为+数据。 </li>
<li><p>与过程化、模块化 建模区别：<br><img src="/img/15772637354780.jpg" alt></p>
<ul>
<li>过程化：直观化思维，关注特定功能过程化描述，不能复用。</li>
<li>模块化：归纳性思维，数据建模，功能、数据复用，缺乏数据封装。</li>
<li>领域化：抽象性思维，功能和数据聚合抽象成实体，功能和数据同等重要，统一进行封装。</li>
</ul>
</li>
<li>功能复杂度与维护效率：<br>  <img src="/img/15772637614029.jpg" alt></li>
</ul>
<h3 id="团队-1"><a href="#团队-1" class="headerlink" title="团队"></a>团队</h3><p>大的原则：人跟事走。<br>康威定律：组织结构会通过系统设计表达出来。当架构确定之后，根据架构划分进行组织结构调整。<br>这部分就说这些，可能我理解不深，觉得没什么可以再说的了。</p>
<p>此处讲解时举架构演进栗子🌰。</p>
<p>最后，一个观点结尾：<br><strong>“能用产品解决的问题不要用服务，能用服务解决的问题不要用咨询”</strong></p>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>谈判力</title>
    <url>/2019/12/08/%E8%B0%88%E5%88%A4%E5%8A%9B/</url>
    <content><![CDATA[<p>《谈判力》读完了，感觉挺有用的，梳理下笔记。</p>
<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="好的谈判三个标准"><a href="#好的谈判三个标准" class="headerlink" title="好的谈判三个标准"></a>好的谈判三个标准</h3><ul>
<li>有效率</li>
<li>增进或至少不损害双方关系</li>
<li>明智的协议</li>
</ul>
<h3 id="立场谈判的问题"><a href="#立场谈判的问题" class="headerlink" title="立场谈判的问题"></a>立场谈判的问题</h3><ul>
<li>不能达成明智协议：把大部分价值留在了谈判桌上</li>
<li>缺乏效率：为了使结果有利于自己，双方都很极端，死守不放。</li>
<li>损害双方关系：立场上讨价还价完全是一场意志较量。每个谈判者都坚持自己的立场，本来是双方合作解决的问题，却成了一场你死我活的斗争。</li>
</ul>
<h2 id="谈判方式"><a href="#谈判方式" class="headerlink" title="谈判方式"></a>谈判方式</h2><ul>
<li>人：把人和事分开。谈判者应该是肩并肩工作，一起解决问题，而不是相互攻击</li>
<li>利益：把利益和立场分开</li>
<li>选择：为共同利益创造选择方案</li>
<li>标准：坚持使用客观标准<h3 id="把人和事分开"><a href="#把人和事分开" class="headerlink" title="把人和事分开"></a>把人和事分开</h3></li>
<li>实质利益和关系利益：不要指望靠牺牲实质利益来换取良好的人际关系</li>
<li>直接解决人际问题：目的是进行不带偏见、开放的谈判</li>
<li>人际问题从以下三方面找出路：认知、情绪、交流</li>
</ul>
<h4 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h4><ul>
<li>了解对方的想法不只是帮助解决自己的问题。他们的想法本身就是问题所在。</li>
<li><strong>冲突不在于客观现实本身，而在于人们的思考方式上。双方对于事实的不同认识才是解决问题的契机。</strong></li>
<li><strong>人们往往只看到他们想要看到的东西。</strong>在大量事实中，挑拣能验证自己最初认知的事实，而忽略或扭曲不符合他们认知的信息。（人类误判心理学：错误衡量易得性倾向）</li>
<li><strong>理解对方观点并不意味着表示赞同。</strong>缩小冲突范围，帮助实现新的自我利益。</li>
<li>保全面子：人们在谈判中坚持己见，往往不是因为建议本身不能接受，而只是不想表现得在对方面前败下阵来。要与谈判者的自我形象相协调，重要性不可低估。（人类误判心理学：避免不一致，被剥夺超级反应倾向）</li>
</ul>
<h4 id="情绪"><a href="#情绪" class="headerlink" title="情绪"></a>情绪</h4><ul>
<li>情绪本身也许比说话更重要</li>
<li>把情绪表现出来，并承认有情绪是正常的。只有从埋在心底的情绪包袱重解脱出来，才可能集中精力思考问题。</li>
<li>让对方发泄情绪。</li>
<li>对付另一方发脾气的最好措施也许是静静地听着，并不时地让对方继续，指导他说完为止。这样，你不仅没有煽风点火、恶化形式，还给了对方说出心里话的勇气，不再留什么积怨。</li>
</ul>
<h4 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h4><ul>
<li>交流存在三大障碍：谈判者并不一定直接交流；对方不一定在听；误解</li>
<li>集中精力听对方说话，要求对方清楚明了地阐述其真正意图，且在模棱两可或没有把握时要求对方重复。对方说话时尽量不要回应，而要去真正理解对方。站在对方角度，考虑对方的需求，理解对方的压力。</li>
<li>理解不等于赞同。如果你能比对方更清楚的说出他们的观点，然后再进行反驳，就会大大增加双方根据实际情况进行建设性对话的可能性，也极大减少了他们认为被误解的可能。</li>
<li>谈论问题对自己的影响，而不是分析对方都做了些什么，或者为什么那么做。</li>
<li>如果希望对方倾听并且理解你的解释，先说原因再说结论。</li>
</ul>
<h3 id="利益：把利益和立场分开"><a href="#利益：把利益和立场分开" class="headerlink" title="利益：把利益和立场分开"></a>利益：把利益和立场分开</h3><ul>
<li>立场是已作的决定，利益是导致做出这一决定的原因。</li>
<li>协调双方利益而不是立场。</li>
<li>谈判的根本问题不在于双发立场冲突，而在于双发需求、愿望、想法乃至恐惧等方面的冲突。</li>
<li>利益驱动人的行为，是立场争执背后的动机。</li>
<li>大多数场景只要仔细考虑潜在的利益需求，就能发现双方共同或可调和的利益要远远多于相互对立的利益。</li>
<li>共同利益和互补的不同利益都可以成为达成明智协议的基础。</li>
</ul>
<h4 id="如何确定利益"><a href="#如何确定利益" class="headerlink" title="如何确定利益"></a>如何确定利益</h4><ul>
<li>问“为什么”。最基本的方法是站在对方的角度换位思考。分析对方采取的每一个立场，问自己对方为什么会这样做。<ul>
<li>“回头看”，找原因，认为我们的行为是由已经发生的事情决定</li>
<li>“向前看”，找目的。我们的行为取决于自己的意志。</li>
<li>向前看比回头看更符合利益,不要与对方争论已经发生的事情.</li>
</ul>
</li>
<li>问“为什么不”。对方为什么没有那样做，那样做会影响他们的什么利益？</li>
</ul>
<h4 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h4><ul>
<li><strong>承认对方的利益。(人类误判心理学：回馈倾向)</strong></li>
<li>利益清单：理清双方利益，按重要性评估。</li>
<li>讨论利益：如果希望对方认真考虑你的利益，明确、具体的告诉他们怎样做才符合你的利益。具体的细节不仅让你的叙述真实可信，还能增加影响力。</li>
<li>努力争取自己的利益：主动出击捍卫自己的利益。对方关注他们自己的利益往往对达成协议有过分乐观的估计。<strong>只有努力捍卫自己的利益，谈判才能取得明智结果，也就是自己获益最大，对方损失最小。</strong>谈判方都力主自己的利益，往往会激发创造性，找出对双方都有利的方案。</li>
<li>就事论事：彬彬有礼，感谢对方付出的时间和精力。让对方知道对事不对人。</li>
<li><strong>不仅全力对付问题，还要全力支持对方：心理学认知不一致理论认为，人们不喜欢矛盾，因而会努力消除矛盾。</strong></li>
</ul>
<h3 id="选择：为共同利益创造选择方案"><a href="#选择：为共同利益创造选择方案" class="headerlink" title="选择：为共同利益创造选择方案"></a>选择：为共同利益创造选择方案</h3><ul>
<li>善于创造多种选择方案是谈判者可以拥有的最具价值的一笔财富：分割蛋糕之前把蛋糕做大</li>
<li>谈判者“往往把钱留在谈判桌上”,未能利益最大化</li>
</ul>
<h4 id="阻碍创造多种方案的原因"><a href="#阻碍创造多种方案的原因" class="headerlink" title="阻碍创造多种方案的原因"></a>阻碍创造多种方案的原因</h4><ul>
<li>不成熟的判断</li>
<li>寻求单一的答案</li>
<li>以为蛋糕的大小是不变的</li>
<li>认为“他们的问题应该由他们自己解决”</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>将创造选择方案与评判方案二者分开。</li>
<li>扩大谈判桌上的选择，不要只寻求唯一方案。</li>
<li>寻求共同利益：以为蛋糕大小是固定不变的，你得的少我就得的多，这种想法几乎没有一次被证明是正确的。寻找对你代价最小，对对方好处最大的方案，反之亦然。<ul>
<li>共同利益潜藏在每项谈判中，往往不是即时可见.</li>
<li>共同利益是机遇不是天上掉下来的馅饼,要让它发挥作用,你必须对此有所作为.</li>
<li><strong>人们总是以为双方差异会造成问题，却不知差异也能解决问题：如股票交易。</strong></li>
</ul>
</li>
<li>找到让对方容易决策的方法。</li>
</ul>
<h3 id="坚持使用客观标准"><a href="#坚持使用客观标准" class="headerlink" title="坚持使用客观标准"></a>坚持使用客观标准</h3><ul>
<li>这部分废话多点，不做记录。</li>
</ul>
<h2 id="但是…"><a href="#但是…" class="headerlink" title="但是…"></a>但是…</h2><ul>
<li>如果对方实力更强大怎么办？</li>
<li>如果对方不合作怎么办？</li>
<li>如果对方使用卑鄙手段怎么办？</li>
</ul>
<h3 id="如果对方实力更强大怎么办"><a href="#如果对方实力更强大怎么办" class="headerlink" title="如果对方实力更强大怎么办"></a>如果对方实力更强大怎么办</h3><ul>
<li>最好的结局不外乎实现下面两大目标：</li>
<li>保护自己：不至于接受本应拒绝的协议。<ul>
<li>确定底线，但可能阻碍你设计出更富新意的解决方案,妨碍接受明智的解决方案</li>
<li>准备最佳替代方案：大多数情况下，更大的风险在于你太想达成协议。由于没有确定任何替代方案，你自然对谈判破裂可能产生的后果感到过于悲观。</li>
<li>谈判能否达成，完全取决于最佳替代方案对于你的吸引力。</li>
</ul>
</li>
<li>让你的谈判资源发挥最大的效用，使达成的协议能尽量满足你的利益需求。<ul>
<li><strong>“资源”并不等于“谈判实力”。谈判双方的相对实力主要取决于各方能在多大程度上承受谈判破裂的后果。</strong></li>
<li><strong>制定你的最佳替代方案。积极寻找谈判破裂后自己所面临的选择，可以大大增强你的谈判实力。</strong></li>
<li>是否该把最佳替代方案透露给对方，取决于你对对方想法的分析。</li>
<li>对另一方替代方案的了解越多，对谈判的准备就越充分。<strong>掌握了对方的替代方案，可以实事求是地估计自己对谈判的期望。越清楚的了解了对方的利益，就越能以最小的代价更好的满足对方。</strong></li>
<li><strong>只有当你的条件让对方感觉比他们的最佳替代方案更有吸引力时，你才可能获得谈判的成功。如果做不到这一点，谈判将没有意义。还不如集中精力完善自己的最佳替代方案，有可能的话，试着改变对方的最佳替代方案。</strong></li>
<li>将实力资源与其他资源协调起来利用。</li>
</ul>
</li>
</ul>
<h3 id="如果对方不合作怎么办"><a href="#如果对方不合作怎么办" class="headerlink" title="如果对方不合作怎么办"></a>如果对方不合作怎么办</h3><p>对方一味攻击你的建议；一心只考虑最大限度满足自己的利益；人身攻击；怎样才能让对方从立场整治转到摆事实、讲道理上来？</p>
<ul>
<li>关注自己能做什么：以身作则</li>
<li>关注对方能做什么：把对方注意力转移到实际问题上来，阻止对方陷入立场之争，这一战术成为“谈判柔术”</li>
<li>关注第三方能做什么    </li>
</ul>
<h4 id="谈判柔术"><a href="#谈判柔术" class="headerlink" title="谈判柔术"></a>谈判柔术</h4><h5 id="如何避免陷入攻击和辩解的恶性循环中？"><a href="#如何避免陷入攻击和辩解的恶性循环中？" class="headerlink" title="如何避免陷入攻击和辩解的恶性循环中？"></a>如何避免陷入攻击和辩解的恶性循环中？</h5><ul>
<li>不要回击：选择避开对方的攻击，并将对方的攻击直指问题本身。好比东方武术中的柔道和柔术一样，避免与对方直接对抗，运用躲闪技巧，借助对方的力量达到自己的目的。</li>
<li>不要对抗对方的力量，相反，要把对方的力量引导到探讨双方利益、制定共同受益的选择方案和寻求客观标准上来</li>
</ul>
<h5 id="对方的攻击手段"><a href="#对方的攻击手段" class="headerlink" title="对方的攻击手段"></a>对方的攻击手段</h5><ul>
<li>直截了当表明了自己的立场：既不接受也不拒绝<br>  不要攻击对方立场，透过立场看利益。把对方的立场当做一种可能的选择，找到其遵循的原则,并考虑解决方案。</li>
<li>反驳你的观点：不要辩解<ul>
<li>欢迎批评和建议：谈判的大部分时间都花在相互职责上。</li>
<li>通过换位思考，征求对方意见的方式把批评引向建设性轨道上。</li>
</ul>
</li>
<li>对你进行人身攻击：不要反唇相讥<ul>
<li>克制住为自己辩护或干脆攻击对方的冲动。不动声色，让对方发泄怨气。</li>
<li>表现出你愿意尊重他们的意见。等他们诉说完将注意力从对自己的攻击转移到对问题的批评上来。</li>
<li>提问与停顿：提问不是批评，而是启发。</li>
<li>在你提问之后，先停顿一下不要急于提出新问题或发表自己的评论，给对方逃避尖锐问题的机会。有时，最有效的谈判是在你没有开口时发生的。</li>
<li>沉默是你最好的武器，要充分利用它。如果对方提出不合理方案或是采取在你看来站不住脚的攻击，最好的手段是一言不发。如果他们对你开诚布公的提问未作充分回答，那就等一等。人们总是对沉默感觉不舒服，尤其是对自己阐述的理由有疑问时更是如此。（人类误判心理学：避免怀疑倾向）</li>
</ul>
</li>
</ul>
<h5 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h5><ul>
<li>陈述事实往往会带有威胁性，因此，尽可能用问问题的形式取而代之。</li>
<li>一名优秀的谈判者很少当场作出决定。表示友好和让步的心理压力是巨大的。利用时间和空间的变化可以帮助谈判者把人与事分开。</li>
<li>进行原则谈判时，你应当在拿出任何方案之前说出自己的理由。如果事后提出理由，只会被认为是为主管立场进行的辩解，而不是适用于任何方案的客观标准。</li>
</ul>
<h3 id="如果对方使用卑鄙手段怎么办"><a href="#如果对方使用卑鄙手段怎么办" class="headerlink" title="如果对方使用卑鄙手段怎么办"></a>如果对方使用卑鄙手段怎么办</h3><ul>
<li>发现诡计</li>
<li>揭穿诡计</li>
<li>质疑诡计的合理性与可取性</li>
</ul>
<h4 id="常见的诡计"><a href="#常见的诡计" class="headerlink" title="常见的诡计"></a>常见的诡计</h4><h5 id="故意欺骗"><a href="#故意欺骗" class="headerlink" title="故意欺骗"></a>故意欺骗</h5><ul>
<li>将人与事分开，除非有充分的理由，否则不要相信别人。这并不意味着把对方看成骗子，而是说把谈判与信任问题分开。</li>
<li>模糊的权限：不能只因为对方在和你谈判就认为他们拥有全部权利。做决定前确定对方的权限</li>
<li><strong>未完全透露不等于欺骗。在事实和意图上故意欺骗别人与不完全透露自己当时的想法是两码事。</strong>诚实的谈判并不需要完全透露自己的想法。如果双发不信任，可以依赖彼此信任的第三方来处理</li>
</ul>
<h5 id="心理战术"><a href="#心理战术" class="headerlink" title="心理战术"></a>心理战术</h5><ul>
<li>环境压抑：问问自己是否感觉紧张，如果是也许是对方故意安排，好让你觉得必须尽早结束谈判。如果发现环境对你不利，要立即指出来，必要的话可以终止谈判离席而去。</li>
<li>人身攻击：用各种言语或非语言的交流形式使你感觉不自在<br>红白脸战术</li>
<li>威胁：往往适得其反，不但不解决问题，反而会带来压力。让对方在实施威胁时冒极大的风险。</li>
</ul>
<h5 id="在立场上施压"><a href="#在立场上施压" class="headerlink" title="在立场上施压"></a>在立场上施压</h5><ul>
<li>拒绝谈判：把同意谈判作为讨价还价的筹码。这一招的另一种形式是为谈判设置先决条件。解决方法：提出一些选择方案，比如通过第三方谈判或通过信函进行协商</li>
<li>过分的要求：让对方用原则来解释其立场,看是否有充分的理由,直到连他们自己也觉得荒谬为止.</li>
<li>变本加厉：提醒对方注意，然后不妨中断谈判，考虑是否继续进行谈判或基于什么原则谈判。这样避免了在指出对方行为严重性时表现冲动，从而做到坚持原则。</li>
<li>锁定战术：不要把对方的锁定当回事，将他的重要性淡化，这样对方才能体面的做出让步。</li>
<li>强硬的同伴：用来拒绝对方的要求，谈判者本人称自己不反对，但同伴反对。认识到这点后不要和对方继续讨论,而是让他接受所适用的原则。并在可能的情况下,与那位强硬的同伴直接谈判。</li>
<li>故意拖延：除了指出对方的拖延战术并与之谈判外，考虑不给对方机会，如设置deadline等。</li>
<li>要不要请便：通常这是不可改变的事实没有什么错，只不过在措辞上应该礼貌。可以指出达不成协议他们会损失什么，并寻找一种保全脸面的方法，让对方走出困境。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>时时做到心中有数<ul>
<li>本书观点与你的经验和直觉越一致越好</li>
</ul>
</li>
<li>从实践中学习</li>
<li>取胜之道：<ul>
<li>不时提醒自己，首先要在谈判方法上取胜：避免自己在应得的利益与公平之间进行选择，因为原则谈判方法使你二者兼得</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>通用能力</category>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>穷查理宝典</title>
    <url>/2019/10/31/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/</url>
    <content><![CDATA[<p>整理芒格的演讲，对提升认知有非常大的帮助。<br>总结起来有以下收获：</p>
<ul>
<li>终生学习</li>
<li>谦虚</li>
<li>开放的心态，不自我设限</li>
<li>检查清单</li>
<li>多元模型</li>
</ul>
<a id="more"></a>
<h2 id="普世智慧"><a href="#普世智慧" class="headerlink" title="普世智慧"></a>普世智慧</h2><ul>
<li>必须拥有多元思维模型，因为只拥有一两个，研究人性的心理学表明，你将会扭曲现实，直到它符合你的思维模型在头脑里形成一个由各种思维模型构成的框架。然后将你们的实际经验和间接经验(通过阅读等手段得来的经验）悬挂在这强大的思维模型架上。使用这种方法可以让你们将各种知识融会贯通，加深对现实的认知。</li>
<li>数学：复利原理、排列组合原理、决策树模型</li>
<li>会计学（熟悉后才能理解会计学的局限性）</li>
<li>工程学：质量控制理论、后备系统、断点理论</li>
<li>物理学：临界质量概念</li>
<li>生物学/生理学</li>
<li>心理学</li>
<li>微观经济学</li>
<li>找出你最擅长的事情，然后持之以恒、乐此不疲地去把它做好</li>
<li><strong>弄清楚自己的能力圈，做自己有优势的事，不要在自己不擅长的领域竞争</strong></li>
</ul>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>你必须知道重要学科的重要理论，并经常使用它们，要全部都用上，而不是只有几种</li>
<li>跨学科学习</li>
<li>没有规则要求你不能增加一两个新的模型，即使你已经步入晚年(保持开放心态，不给自己设限)</li>
<li>通过广泛的阅读把自己培养成一个终生自学者：培养好奇心，每天努力使自己聪明一点点。</li>
<li>如果我们再某个阶段停滞不前，满足于拥有的知识，我们的业绩要比现在差得多。所以诀窍就在于不断学习。</li>
<li><strong>简单是长期努力工作的结果，而不是起点。</strong></li>
</ul>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul>
<li><p>直面你的大问题，别把它隐藏起来</p>
</li>
<li><p>不断地挑战和主动地修正你“最爱的观念”</p>
</li>
<li><p>能力会让你到达巅峰，但只有品德才能让你留在那里</p>
</li>
<li><p>一个人很少完全清楚他自己的动机。</p>
</li>
<li><p>芒格在意的并不是他本人是否能赢牌，而是是否能把手上的牌打好</p>
</li>
<li><p>说真话，你将无需记住你的谎言</p>
</li>
<li><p>如果你把葡萄干和大便搅在一起，你得到的仍然是大便</p>
</li>
<li><p>人生不同阶段遇到非常棘手的问题，有三点有助于应付这些困难：别期望太高；拥有幽默感；让自己置身于朋友和家人的爱之中。</p>
</li>
<li><p>为了养家糊口，你不妨偶尔替那些丧失理智的自大狂服务。但你应该像格兰特-麦克费登那样为人处世。</p>
</li>
<li><p>容忍对某一些人有一点不公平，以便对所有人更为公平。</p>
</li>
<li><p>简化任务的最佳方法一般是先解决那些答案显而易见的大问题。</p>
</li>
<li><p>如果你想要说服别人，要诉诸利益，而非诉诸理性。</p>
</li>
</ul>
<h2 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h2><ul>
<li>最重要的是别愚弄你自己，而且要记住，你是最容易被自己愚弄的人</li>
<li>抵制追求虚假的精确和错误的确定性的欲望</li>
<li>当别人贪婪时要害怕；当别人害怕时要贪婪</li>
<li>比求胜的意愿更重要的是做好准备的意愿。真正好的投资机会不会经常有，也不会持续很长的时间，所以你必须做好行动的准备。要有随时行动的思想准备。</li>
<li><strong>花在学习和思考上的时间，比花在行动上的时间要多</strong></li>
<li>凡事往简单处想，往认真处行</li>
<li>让最有能力和最愿意成为学习机器的人发挥最大的作用(机会留给核心人员)</li>
<li>让最好的球员打很长时间的比赛</li>
<li>逆向思考</li>
<li><strong>你是正确的或错误的，并不取决于大家是否同意你。你是正确的，是因为你的资料和推理是正确的</strong></li>
<li><strong>准备不足和仓促决策是不可原谅的</strong></li>
<li><strong>随大流只会让你往平均值靠近</strong> </li>
<li><strong>不追逐平庸的机会</strong>(机会成本)</li>
<li><strong>就算你90%的时间都在说“不”，你也不会错失太多的东西。</strong></li>
</ul>
<h2 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h2><ul>
<li>股价公道的伟大企业比股价超低的普通企业好</li>
<li>等待好球的出现</li>
<li>我们偏向于把大量的钱投在我们不用再另做决策的地方</li>
<li>在漫长的人生中，你只要培养自己的智慧，抓住一两次这样的好机会，就能够赚许许多多的钱</li>
<li><strong>聪明人发现好机会就狠狠下注，其他时间则按兵不动</strong></li>
<li><strong>你需要的不是大量的行动，而是大量的耐心。你必须坚持原则，等到机会来临，你就用力去抓住它们。</strong></li>
<li>我们赚钱，靠的是记住浅显的，而不是掌握深奥的。我们从来不去试图成为非常聪明的人，而是持续地试图别变成蠢货，久而久之，我们这种人便能获得非常大的优势。</li>
<li>用低廉的价格，甚至是合理的价格，来购买那些拥有可持续竞争优势的企业。</li>
</ul>
<h2 id="误判心理学"><a href="#误判心理学" class="headerlink" title="误判心理学"></a>误判心理学</h2><ul>
<li>奖励和惩罚 超级反应倾向：激励机制能够导致人们在做坏事的时候觉得自己是正当的</li>
<li>喜欢/热爱倾向：人类喜欢和热爱被喜欢和被热爱(人天生喜欢被舔)。<strong>人类终身都会渴望得到许多和他毫无关系的他人的怜惜和欣赏。</strong></li>
<li>讨厌/憎恨倾向</li>
<li><strong>避免怀疑倾向：人类的大脑天生就有一种尽快作出决定，以此消除怀疑倾向。</strong></li>
<li><strong>避免不一致倾向：为了节省运算空间，人类的大脑会不愿意做出改变。这是一种避免不一致性的形式。</strong></li>
<li>好奇心倾向</li>
<li>康德式公平倾向：每个人在自身维护公平的同事希望得到公平，如果得不到就会很不满</li>
<li>艳羡/妒忌倾向</li>
<li>回馈倾向：以德报德，以牙还牙</li>
<li>受简单联想影响的倾向</li>
<li>简单的、避免痛苦的心里否认</li>
<li>自视过高的倾向</li>
<li>过度乐观倾向</li>
<li><strong>被剥夺超级反应倾向：</strong>失去造成的伤害比得到带来的快乐多得多。如果某个人即将得到某样他非常渴望的东西，而这样东西却在最后一刻飞走了，那么他的反应就会像这件东西应拥有了很久却突然被夺走一样。</li>
<li><strong>社会认同倾向：</strong> 自动根据他看到的周边人们的思考和行动方式去思考和行动的倾向。如果一个人自动依照他所观察到的周围人们的思考和行动方式去思考和行动，那么他就能够把一些原本很复杂的行为进行简化。而且这种从中的做法往往是有效的。人们在感到困惑或者有压力的时候，尤其是在既困惑又有压力的时候，最容易受到社会认同倾向影响。</li>
<li>对比错误反应倾向</li>
<li>压力影响倾向</li>
<li>错误衡量易得性倾向：人类大脑会高估容易得到的东西的重要性倾向。</li>
<li>不用就忘倾向</li>
<li>化学物质错误影响倾向</li>
<li>衰老-错误影响倾向</li>
<li>权威-错误影响倾向</li>
<li>废话倾向</li>
<li>重视理由倾向</li>
<li>数种心理倾向共同作用造成极端后果的倾向</li>
</ul>
<h2 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a>推荐书单</h2><ul>
<li>人类&amp;社会<ul>
<li>苏格兰人如何发明现代世界</li>
<li>枪炮、病菌与铁：人类社会的命运</li>
<li>第三种猩猩：人类的身世与未来</li>
<li>基因组：人种自传23章</li>
<li>温度，决定一切</li>
<li>深奥的简洁</li>
<li>自私的基因</li>
</ul>
</li>
<li>经济<ul>
<li>洛克菲勒：一个关于财富的神话</li>
<li>国富国穷</li>
<li>生活在极限之内：生态学、经济学和人口禁忌</li>
<li>沃伦巴菲特的投资组合:掌握集中投资战略的秘诀</li>
<li>诚信的背后：华尔街圈钱游戏的真相</li>
</ul>
</li>
<li>心理学<ul>
<li>影响力</li>
<li>谈判力</li>
</ul>
</li>
<li>自传<ul>
<li>我生活的种种模式 赫尔伯特-西蒙自传</li>
<li>富兰克林自传</li>
</ul>
</li>
<li>其他<ul>
<li>只有偏执狂才能生存</li>
</ul>
</li>
<li>编辑推荐的书<ul>
<li>勒斯施瓦伯：因业绩而骄傲</li>
<li>凡人与大亨：经商的故事</li>
<li>筚路蓝缕的先行者：1840至1900年的西部大开发</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>通用能力</category>
        <category>认知</category>
      </categories>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title>只有偏执狂才能生存</title>
    <url>/2018/07/15/%E5%8F%AA%E6%9C%89%E5%81%8F%E6%89%A7%E7%8B%82%E6%89%8D%E8%83%BD%E7%94%9F%E5%AD%98/</url>
    <content><![CDATA[<p>《Only the Paranoid Survive》，读下来没感觉到和“偏执狂”有什么关系。</p>
<p>这本书主要讲随着时代发展，企业及个人如何发现变化及时做出调整。主要讲企业，企业由高管带领，讲述高管应如何做。</p>
<p>记录一些看的懂得重点。</p>
<a id="more"></a>
<h2 id="10倍速变化"><a href="#10倍速变化" class="headerlink" title="10倍速变化"></a>10倍速变化</h2><h3 id="影响企业竞争力六个因素"><a href="#影响企业竞争力六个因素" class="headerlink" title="影响企业竞争力六个因素"></a>影响企业竞争力六个因素</h3><ol>
<li>现有竞争对手的实力、活力和能力<ul>
<li>竞争对手数量多吗？资本是否雄厚？</li>
<li>是否清楚的瞄准了你？</li>
</ul>
</li>
<li>公司潜在竞争对手的实力、活力和能力.<ul>
<li>形势一变，他们就能加入进来</li>
<li>可能比现有的竞争对手更加强大。</li>
</ul>
</li>
<li>公司的供应商的实力、活力和能力<ul>
<li>供应商数据是否足够多让你的业务有足够的选择余地；</li>
<li>还是只有几家，他们可以掐住你的咽喉？</li>
<li>他们是充满挑衅，贪得无厌还是较为谨慎稳妥，并把客户情况的长远评价作为企业指导？</li>
</ul>
</li>
<li>企业客户数量<ul>
<li>是很多还是仅靠一两家主要客户做生意？</li>
<li>他们是倚恃激烈的竞争对你求全责备还是采用较为温和的态度？</li>
</ul>
</li>
<li>你的产品或服务项目采用其他方式投产或发送的可能性<ul>
<li>这常常叫做“替代方式”,<strong>作者认为这是最致命的一点。</strong></li>
<li>新技术、新方法可以垫付旧秩序，建立新规则，是商业环境发生翻天覆地变化。类似于超时对小商店的冲击，微处理器对运算的冲击，以及数字媒体对娱乐的冲击。</li>
</ul>
</li>
<li>互补企业因素<ul>
<li>为客户提供互补型产品的其他企业。</li>
<li>每个公司的产品都要和其他公司产品互相结合才能发挥更大的作用。</li>
</ul>
</li>
</ol>
<p>这是传统行业的六大因素，当今互联网行业也可以参考，主要区别在于供应商及”替代方式“：</p>
<ol>
<li>供应商及客户可以理解为企业的上下游。对互联网公司产品来说，供应商就是使用者，客户就是能够创造利润的。如Google，供应商就是C端用户，客户就是广告主。</li>
<li>”替代方式“：指的不是被其他产品替代，而是产品能否适应时代发展。</li>
</ol>
<h3 id="超竞争因素"><a href="#超竞争因素" class="headerlink" title="超竞争因素"></a>超竞争因素</h3><p>当某一个因素发生了重大变化，超过了企业能够承受的程度，成败就在此一举。这就是”10倍速变化“，意为该因素在短期内实力增至原来10倍。<br><img src="/img/15316649124960.jpg" alt></p>
<p>企业由此进入战略转折点，要么上升到新高度，要么走向低谷。<br><img src="/img/15316649360996.jpg" alt></p>
<p>战略转折点的出现不容易精确找出。再前行过程中，终于在某个点停了下来说：我们迷路了。这时就是战略转折点。</p>
<h3 id="哪些会产生10倍速变化"><a href="#哪些会产生10倍速变化" class="headerlink" title="哪些会产生10倍速变化"></a>哪些会产生10倍速变化</h3><ol>
<li>竞争</li>
<li>技术</li>
<li>用户</li>
<li>供应商</li>
<li>互补企业</li>
<li>营运规则</li>
</ol>
<h3 id="哪些情况意味着转折点"><a href="#哪些情况意味着转折点" class="headerlink" title="哪些情况意味着转折点"></a>哪些情况意味着转折点</h3><ol>
<li>第一阶段，有些不安，感觉清醒与以往有些不同</li>
<li>第二阶段是你对公司业务的看法和实际情况大相径庭</li>
<li>最后出现了新立场、新看法和新举措，一套新的公司声明诞生了，高层领导班子也改组。</li>
</ol>
<p>最好的情况是在公司仍然健全、外部业务仍能支撑在内部实验新的经营方式的时候进行改革。</p>
<p>时间是一切，意味着需要在情报尚不完全、情况不清楚的时候采取行动。可悲的是，<strong>一旦进入了战略转折点，就只有感觉和个人判断能够作为指导。</strong></p>
<h2 id="如何察觉他们"><a href="#如何察觉他们" class="headerlink" title="如何察觉他们"></a>如何察觉他们</h2><p>如何从”噪声“中分辨出”信号“？</p>
<ol>
<li>对于可能成为企业10倍速因素的发展变化，要保持长久警惕。</li>
<li>主要竞争对手是否将要发生某种变化。首先判断主要竞争对手是谁？自问：如果枪里只有一颗子弹，你会用在哪个竞争对手身上。</li>
<li>互补企业是否就要发生变化。</li>
<li>周围的人是否变得迷惑不知所从。</li>
<li>保持开放的心态，倾听一线员工的。（要消除员工对战略讨论会发言的后顾之忧，没有多年时间是不行的。）</li>
<li>倾听一线观点，要分辨哪些消息是待琢璞玉(需要再次加工分析），又有哪些人利用你的兼听之明，用噪声来包围你。</li>
<li>避开最初模型的陷阱。不能只凭最初模型的质量来判断他是否具有战略转折点意义。如果你认为改进10倍之后，这件事足以引起人们的兴奋而成为新的威胁因素，你就可能出在观察一个战略转折点开端的边缘。应该训练自己深入的思考问题，把最初模型优劣与该产品或技术的长期潜能和长远意义区分开来。（很多互联网产品估值那么高都源于此。）</li>
<li>与数据争论。数据说明过去，战略转折点表示未来。应该清楚何时使用数据，何时离开。</li>
</ol>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p>一篇讲增长的文章：<a href="https://mp.weixin.qq.com/s/w83PtvGewwCjwvuIBDa2bw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/w83PtvGewwCjwvuIBDa2bw</a> 根据很多资料总结的。</p>
]]></content>
      <categories>
        <category>通用能力</category>
        <category>系统思维</category>
      </categories>
      <tags>
        <tag>企业</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做项目管理</title>
    <url>/2018/04/21/%E5%A6%82%E4%BD%95%E5%81%9A%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>本周参加了公司内部通用能力培训，总结一下。本篇是强哥关于项目管理的分享。<br>之前带过一些项目，自己的一些做法暗合分享内容。但不成体系，拾人牙慧，整理一下。</p>
<a id="more"></a>
<h2 id="项目管理是什么"><a href="#项目管理是什么" class="headerlink" title="项目管理是什么"></a>项目管理是什么</h2><blockquote>
<p>在既定的资源和要求的约束下，为实现某种目的而相互联系的一次性工作任务。<br><a href="https://baike.baidu.com/item/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/85389?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/85389?fr=aladdin</a></p>
</blockquote>
<p>具有以下关键信息。<br>1.目的<br>2.资源和要求的约束<br>3.相互联系<br>4.一次性工作</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>可以理解成目标，按照smart原则设定。</p>
<h3 id="资源和要求的约束"><a href="#资源和要求的约束" class="headerlink" title="资源和要求的约束"></a>资源和要求的约束</h3><ol>
<li>资源 = 人力 + 时间</li>
<li>要求约束<ul>
<li>功能约束(需求、交互)</li>
<li>非功能约束(性能、可用性、安全、架构)</li>
</ul>
</li>
</ol>
<h4 id="如何应对"><a href="#如何应对" class="headerlink" title="如何应对"></a>如何应对</h4><p><img src="/img/15262834463445.jpg" alt><br><strong>scope</strong>：可以理解为做得事情<br><strong>cost</strong>:投入的资源。<br><strong>核心</strong>：质量不能妥协。</p>
<h4 id="三边如何取舍"><a href="#三边如何取舍" class="headerlink" title="三边如何取舍"></a>三边如何取舍</h4><ol>
<li>深刻理解业务 </li>
<li>深刻理解技术</li>
</ol>
<h3 id="相互联系"><a href="#相互联系" class="headerlink" title="相互联系"></a>相互联系</h3><ol>
<li>项目外有哪些外部联系</li>
<li>项目中的事情是如何关联的</li>
<li>任务拆解：分配人做合适的事</li>
<li>关键路径：关注路径最长的。</li>
<li>哪些人会关心这个项目：干系人。</li>
</ol>
<h3 id="一次性"><a href="#一次性" class="headerlink" title="一次性"></a>一次性</h3><ol>
<li>要有明确的开始和结束时间</li>
<li><strong>一次性</strong>: 一次性把事情做对(在华为时从培训开始公司就一直强调)</li>
<li>快速迭代 != 目标打折</li>
<li>一次性工作 != 临时性工作</li>
</ol>
<h2 id="项目管理怎么做"><a href="#项目管理怎么做" class="headerlink" title="项目管理怎么做"></a>项目管理怎么做</h2><p><img src="/img/15301771013809.jpg" alt></p>
<h2 id="迭代的两种方式"><a href="#迭代的两种方式" class="headerlink" title="迭代的两种方式"></a>迭代的两种方式</h2><ol>
<li><strong>MVP</strong>(Minimum Viable Product): 最小可行产品。适用于新领域，快速接收反馈，调整策略。</li>
<li><strong>MAP</strong>(Mimimum Awesome Product):最低完成度但足够能让人惊艳的产品。适用于成熟市场，有其他竞品。</li>
</ol>
<h2 id="常见的坑"><a href="#常见的坑" class="headerlink" title="常见的坑"></a>常见的坑</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ol>
<li>启动过快:启动容易收尾难。这一点做线上CRM一期体会较深。需求有很多不合理地方，推动理清问题及评估方案可行性才开始做。</li>
<li>目标是上线</li>
</ol>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><ol>
<li>兵马先行，粮草没有</li>
<li>名义资源:项目组人员身兼数职，投入项目时间不可控。</li>
<li>万能资源:不考虑人的技能特点，简单数人头。</li>
</ol>
<h3 id="排期"><a href="#排期" class="headerlink" title="排期"></a>排期</h3><ol>
<li>倒排</li>
<li>WBS(work breakdown structure)太粗</li>
<li>搞不清任务依赖关系</li>
<li>看不到项目关键路径</li>
</ol>
<h3 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h3><ol>
<li>不沟通</li>
<li>尽量不给老大添麻烦 -&gt; 给他“惊喜”</li>
<li>都听听没坏处 -&gt;开大会</li>
<li>会议内容：大会小开，小会大开。小会详细讨论；大会之前私下有过交流，会上再次确认。</li>
</ol>
<h4 id="沟通的方法"><a href="#沟通的方法" class="headerlink" title="沟通的方法"></a>沟通的方法</h4><ol>
<li>每日站会</li>
<li>周会</li>
<li>项目周报</li>
</ol>
<h3 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h3><ol>
<li>只讲问题，不讲方法</li>
<li>过程管理</li>
<li>契约精神：认为还有时间，项目成员应确保在dealline前完成。</li>
<li>无声变更：接PM需求只有自己知道。</li>
<li>事情会按计划进行：缺少监控</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>强哥的分享</li>
<li>MVP和MAP：<a href="https://medium.com/swlh/the-mvp-is-dead-long-life-to-the-map-minimum-awesome-product-404df90fef7f(翻译版本到处都是)" target="_blank" rel="noopener">https://medium.com/swlh/the-mvp-is-dead-long-life-to-the-map-minimum-awesome-product-404df90fef7f(翻译版本到处都是)</a></li>
</ol>
]]></content>
      <categories>
        <category>通用能力</category>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka生产者</title>
    <url>/2018/04/18/Kafka%E7%94%9F%E4%BA%A7%E8%80%85/</url>
    <content><![CDATA[<h2 id="发送消息步骤"><a href="#发送消息步骤" class="headerlink" title="发送消息步骤"></a>发送消息步骤</h2><p><img src="/img/15255335466815.jpg" alt></p>
<p>ProducerRecord 对象需要包含目标主题和要发送的内容。我们还可以指定键或分区。</p>
<a id="more"></a>
<ol>
<li>在发送 ProducerRecord 对象时，生产者要先把键和值对象序列化成字节数组，这样它们才能够在网络上传输。</li>
<li>数据被传给分区器。如果之前在 ProducerRecord 对象里指定了分区，那么分区器就不会再做任何事情，直接把指定的分区返回。如果没有指定分区，那么分区器会根据 ProducerRecord 对象的键来选择一个分区。选好分区以后，生产者就知道该往哪个主题和分区发送这条记录了。</li>
<li>紧接着，这条记录被添加到一个记录批次里，这个批次里的所有消息会被发送到相同的主题和分区上。</li>
<li>有一个独立的线程负责把这些记录批次发送到相应的 broker 上。<br>———–<strong>问题是这样节省了带宽，不会影响实时性么？生产者并不会等待批次满了才发，半满甚至只包含一个消息就会发。感觉有个间隔，间隔到了不管有多少都发。</strong></li>
<li>服务器在收到这些消息时会返回一个响应。如果消息成功写入 Kafka，就返回一个 RecordMetaData 对象，它包含了主题和分区信息，以及记录在分区里的偏移量。如果写入失败，则会返回一个错误</li>
<li>生产者在收到错误之后会尝试重新发送消息，几次之后如果还是失败，就返回错误信息。</li>
</ol>
<h2 id="发送消息方式"><a href="#发送消息方式" class="headerlink" title="发送消息方式"></a>发送消息方式</h2><h3 id="发送并忘记（fire-and-forget）"><a href="#发送并忘记（fire-and-forget）" class="headerlink" title="发送并忘记（fire-and-forget）"></a>发送并忘记（fire-and-forget）</h3><p>我们把消息发送给服务器，但并不关心它是否正常到达。大多数情况下，消息会正常到达，因为 Kafka 是高可用的，而且生产者会自动尝试重发(可通过参数配置)。不过，使用这种方式有时候也会丢失一些消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record =</span><br><span class="line">        <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Precision Products"</span>,</span><br><span class="line">          <span class="string">"France"</span>); ➊</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  producer.send(record); ➋</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace(); ➌</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>❶ 生产者的 send() 方法将 ProducerRecord 对象作为参数，所以我们要先创建一个 ProducerRecord 对象。它需要目标主题的名字和要发送的键和值对象，它们都是字符串。键和值对象的类型必须与序列化器和生产者对象相匹配。</p>
<p>❷ 我们使用生产者的 send() 方法发送 ProducerRecord 对象。从生产者的架构图里可以看到，消息先是被放进缓冲区，然后使用单独的线程发送到服务器端。send() 方法会返回一个包含 RecordMetadata 的 Future 对象，不过因为我们会忽略返回值，所以无法知道消息是否发送成功。如果不关心发送结果，那么可以使用这种发送方式。比如，记录 Twitter 消息日志，或记录不太重要的应用程序日志。</p>
<p>❸ 我们可以忽略发送消息时可能发生的错误或在服务器端可能发生的错误，但在发送消息之前，生产者还是有可能发生其他的异常。这些异常有可能是 SerializationException（说明序列化消息失败）、BufferExhaustedException 或 TimeoutException（说明缓冲区已满），又或者是 InterruptException（说明发送线程被中断）。</p>
<h3 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h3><p>我们使用 send() 方法发送消息，它会返回一个 Future 对象，调用 get() 方法进行等待，就可以知道消息是否发送成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record =</span><br><span class="line">        <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Precision Products"</span>, <span class="string">"France"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        producer.send(record).get(); ➊</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace(); ➋</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>❶ 在这里，producer.send() 方法先返回一个 Future 对象，然后调用 Future 对象的 get() 方法等待 Kafka 响应。如果服务器返回错误，get() 方法会抛出异常。如果没有发生错误，我们会得到一个 RecordMetadata 对象，可以用它获取消息的偏移量。</p>
<p>❷ 如果在发送数据之前或者在发送过程中发生了任何错误，比如 broker 返回了一个不允许重发消息的异常或者已经超过了重发的次数，那么就会抛出异常。我们只是简单地把异常信息打印出来。</p>
<p>KafkaProducer 一般会发生两类错误。其中一类是可重试错误，这类错误可以通过重发消息来解决。比如对于连接错误，可以通过再次建立连接来解决，“无主（no leader）”错误则可以通过重新为分区选举首领来解决。KafkaProducer 可以被配置成自动重试，如果在多次重试后仍无法解决问题，应用程序会收到一个重试异常。另一类错误无法通过重试解决，比如“消息太大”异常。对于这类错误，KafkaProducer 不会进行任何重试，直接抛出异常。</p>
<h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>我们调用 send() 方法，并指定一个回调函数，服务器在返回响应时调用该函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoProducerCallback</span> <span class="keyword">implements</span> <span class="title">Callback</span> </span>&#123;➊</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">         e.printStackTrace(); ➋</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProducerRecord&lt;String, String&gt; record =</span><br><span class="line">        <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomerCountry"</span>, <span class="string">"Biomedical Materials"</span>, <span class="string">"USA"</span>); ➌</span><br><span class="line">producer.send(record, <span class="keyword">new</span> DemoProducerCallback()); ➍</span><br></pre></td></tr></table></figure>
<p>❶ 为了使用回调，需要一个实现了 org.apache.kafka.clients.producer.Callback 接口的类，这个接口只有一个 onCompletion 方法。</p>
<p>❷ 如果 Kafka 返回一个错误，onCompletion 方法会抛出一个非空（non null）异常。这里我们只是简单地把它打印出来，但是在生产环境应该有更好的处理方式。</p>
<p>❸ 记录与之前的一样。</p>
<p>❹ 在发送消息时传进去一个回调对象。</p>
<h2 id="生产者参数"><a href="#生产者参数" class="headerlink" title="生产者参数"></a>生产者参数</h2><h3 id="acks"><a href="#acks" class="headerlink" title="acks"></a>acks</h3><p>acks 参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。这个参数对消息丢失的可能性有重要影响”</p>
<p>acks = 0:生产者在成功写入消息之前不会等待任何来自服务器的响应。也就是说，如果当中出现了问题，导致服务器没有收到消息，那么生产者就无从得知，消息也就丢失了</p>
<p>acks = 1:只要集群的首领节点收到消息，生产者就会收到一个来自服务器的成功响应。</p>
<p>acks = all:只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。</p>
<h3 id="buffer-memory"><a href="#buffer-memory" class="headerlink" title="buffer.memory"></a>buffer.memory</h3><p>该参数用来设置生产者内存缓冲区的大小，生产者用它缓冲要发送到服务器的消息。</p>
<p>如果应用程序发送消息的速度超过发送到服务器的速度，会导致生产者空间不足。</p>
<p>这个时候， send() 方法调用要么被阻塞，要么抛出异常.</p>
<p>取决于如何设置 block.on.buffer.full 参数（在 0.9.0.0 版本里被替换成了 max.block.ms，表示在抛出异常之前可以阻塞一段时间）。</p>
<p>retries<br>产者从服务器收到的错误有可能是临时性的错误（比如分区找不到首领）。</p>
<p>在这种情况下，retries 参数的值决定了生产者可以重发消息的次数，如果达到这个次数，生产者会放弃重试并返回错误。</p>
<p>默认情况下，生产者会在每次重试之间等待 100ms，不过可以通过 retry.backoff.ms 参数来改变这个时间间隔。</p>
<p>建议在设置重试次数和重试时间间隔之前，先测试一下恢复一个崩溃节点需要多少时间（比如所有分区选举出首领需要多长时间），让总的重试时间比 Kafka 集群从崩溃中恢复的时间长，否则生产者会过早地放弃重试。不过有些错误不是临时性错误，没办法通过重试来解决（比如“消息太大”错误）。</p>
<p>一般情况下，因为生产者会自动进行重试，所以就没必要在代码逻辑里处理那些可重试的错误。只需要处理那些不可重试的错误或重试次数超出上限的情况。 </p>
<h3 id="batch-size"><a href="#batch-size" class="headerlink" title="batch.size"></a>batch.size</h3><p>“当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。</p>
<p>该参数指定了一个批次可以使用的内存大小，按照字节数计算（而不是消息个数）。</p>
<p>当批次被填满，批次里的所有消息会被发送出去。不过生产者并不一定都会等到批次被填满才发送，半满的批次，甚至只包含一个消息的批次也有可能被发送。</p>
<p>所以就算把批次大小设置得很大，也不会造成延迟，只是会占用更多的内存而已。但如果设置得太小，因为生产者需要更频繁地发送消息，会增加一些额外的开销”</p>
<h3 id="linger-ms"><a href="#linger-ms" class="headerlink" title="linger.ms"></a>linger.ms</h3><p>指定生产者在发送批次之前等待更多消息加入批次的时间。</p>
<p>KafkaProducer 会在批次填满或 linger.ms 达到上限时把批次发送出去。</p>
<p>默认情况下，只要有可用的线程，生产者就会把消息发送出去，就算批次里只有一个消息。</p>
<p>把 linger.ms 设置成比 0 大的数，让生产者在发送批次之前等待一会儿，使更多的消息加入到这个批次。</p>
<p>虽然这样会增加延迟，但也会提升吞吐量（因为一次性发送更多的消息，每个消息的开销就变小了）。</p>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="默认分区策略"><a href="#默认分区策略" class="headerlink" title="默认分区策略"></a>默认分区策略</h3><p>kafka消息可以是一个个键值对，键有两个作用：一个是作为消息的附加信息，也可以决定消息被写道主题哪个分区。</p>
<p>key为空且使用默认分区器，分区器使用轮询算法将消息均衡分不到各个分区。</p>
<p>如果key不为空且使用默认分区器，对key进行散列(kafka自己的散列算法)，每次都是散列到同一分区。<br>可能散列到的分区不可用，出现问题。<br>增加新分区也会出现问题，所以永远不要增加新分区</p>
<h3 id="自定义分区策略"><a href="#自定义分区策略" class="headerlink" title="自定义分区策略"></a>自定义分区策略</h3><p>实现Partitioner接口</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《kafka权威指南》</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft概述</title>
    <url>/2018/04/16/Raft%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RAFT协议作用是保证分布式系统同一数据的一致性（与2pc不同，2pc是保证多个数据的原子性）。</p>
<p>采取的方式是分布式系统中只有一个节点接收数据，然后向其他节点复制</p>
<p>在一个由 Raft 协议组织的集群中有三类角色：</p>
<ol>
<li>Leader（领袖）</li>
<li>Follower（群众）</li>
<li>Candidate（候选人）</li>
</ol>
<p>Raft将问题分解和具体化：Leader统一处理变更操作请求，一致性协议的作用具化为保证节点间操作日志副本(log replication)一致，以term作为逻辑时钟(logical clock)保证时序，节点运行相同状态机(state machine)得到一致结果。Raft协议具体过程如下：</p>
<a id="more"></a>
<p><img src="/img/15254237788398.jpg" alt></p>
<ol>
<li>Client发起请求，每一条请求包含操作指令</li>
<li>请求交由Leader处理，Leader将操作指令(entry)追加(append)至操作日志，紧接着对Follower发起AppendEntries请求、尝试让操作日志副本在Follower落地</li>
<li>如果Follower多数派(quorum)同意AppendEntries请求，Leader进行commit操作、把指令交由状态机处理</li>
<li>状态机处理完成后将结果返回给Client<br>指令通过log index(指令id)和term number保证时序，正常情况下Leader、Follower状态机按相同顺序执行指令，得出相同结果、状态一致。</li>
</ol>
<p>宕机、网络分化等情况可引起Leader重新选举(每次选举产生新Leader的同时，产生新的term)、Leader/Follower间状态不一致。Raft中Leader为自己和所有Follower各维护一个nextIndex值，其表示Leader紧接下来要处理的指令id以及将要发给Follower的指令id，LnextIndex不等于FnextIndex时代表Leader操作日志和Follower操作日志存在不一致，这时将从Follower操作日志中最初不一致的地方开始，由Leader操作日志覆盖Follower，直到LnextIndex、FnextIndex相等。</p>
<p>Paxos中Leader的存在是为了提升决议效率，Leader的有无和数目并不影响决议一致性，Raft要求具备唯一Leader，并把一致性问题具体化为保持日志副本的一致性，以此实现相较Paxos而言更容易理解、更容易实现的目标。</p>
<h3 id="RAFT论文"><a href="#RAFT论文" class="headerlink" title="RAFT论文"></a>RAFT论文</h3><p>论文讲的很详细了</p>
<blockquote>
<p><a href="https://github.com/maemual/raft-zh_cn" target="_blank" rel="noopener">https://github.com/maemual/raft-zh_cn</a></p>
</blockquote>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><blockquote>
<p><a href="https://mp.weixin.qq.com/s/MZlJFSOCm0c7ak7CIKL5MQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MZlJFSOCm0c7ak7CIKL5MQ</a></p>
</blockquote>
<h3 id="动画方式展示原理"><a href="#动画方式展示原理" class="headerlink" title="动画方式展示原理"></a>动画方式展示原理</h3><blockquote>
<p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p>
</blockquote>
<p>相比于Paxos，Raft最大的特点就是可理解性。<br>Raft把一致性问题，分解成三个比较独立的子问题，并给出每个子问题的解决方法。</p>
<h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><p>当现存的领导人不存在时，需要选举新的领导人。</p>
<h3 id="任期-term"><a href="#任期-term" class="headerlink" title="任期(term)"></a>任期(term)</h3><p><img src="/img/15254217092487.jpg" alt></p>
<p>Raft 算法将时间划分成为任意不同长度的任期（term）。任期用连续的数字进行表示。<br>每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。每次选举任期号都增加。<br>如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。<br>在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始<strong>另一个任期</strong>，并且立刻开始下一次选举。<br>Raft 算法保证在给定的一个任期最多只有一个领导人。</p>
<h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ol>
<li>一般情况下，追随者接到领导者的心跳时，把ElectionTimeout（后面会讲election timeout）清零，不会触发；</li>
<li>领导者故障，追随者的ElectionTimeout超时发生时，会变成候选者，触发领导人选取</li>
</ol>
<h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><ol>
<li>每个节点以follower启动。</li>
<li>每个节点设置一个150-300ms的随机超时时间（election timeout)，没有接收到leader消息时，变成candinate。</li>
<li>candinate要求其他节点投票。</li>
<li>各节点投票。</li>
<li>如果超过半数投票，candinate变成leader。</li>
</ol>
<p>有两个超时时间控制选举过程。</p>
<h3 id="election-timeout"><a href="#election-timeout" class="headerlink" title="election timeout"></a>election timeout</h3><ol>
<li>follower等待这个时间，超过这个时间变为candinate，发起新的选举。</li>
<li>如果其他follower在该任期内没投过票，就会给发起投票的candinate投票。并重置自己的election timeout。</li>
<li>超过半数投票，candinate变为leader</li>
<li>leader开始向followers发送Append Entries(包含心跳信息及日志）消息。</li>
</ol>
<h3 id="heartbeat-timeout"><a href="#heartbeat-timeout" class="headerlink" title="heartbeat timeout"></a>heartbeat timeout</h3><ol>
<li>leader 必须在 heartbeat timeout 间隔内发送Append Entries消息。</li>
<li>follower会响应每个Append Entries消息，重置自己的election timeout。</li>
<li>在follower停止接收heartbeats并且成为candinate时，停止选举过程</li>
</ol>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>描述Raft的leader是如何把日志复制到集群的各个节点上的。</p>
<p>领导人必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其他节点的日志保持和自己相同。</p>
<h3 id="日志复制过程"><a href="#日志复制过程" class="headerlink" title="日志复制过程"></a>日志复制过程</h3><ol>
<li>客户端请求只经过leader。</li>
<li>每个变化都作为entry加到leader日志中。</li>
<li>log entry是uncomitted状态，所以不会更新节点值。</li>
<li>将日志同步到follower节点，完成更新节点值。</li>
<li>leader等待超过半数follower更新成功。</li>
<li>leader entry状态变为commited。</li>
<li>leader通知entry状态为commited。</li>
<li>响应客户端。</li>
</ol>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><table>
<thead>
<tr>
<th>特性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>日志匹配原则</td>
<td>如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同（5.3 log replication 节）if two logs contain an entry with the same index and term, then the logs are identical in all entries up through the given index.</td>
</tr>
<tr>
<td>状态机安全特性</td>
<td>如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志（5.4.3 安全性论证 节）if a server has applied a particular log entry to its state machine, then no other server may apply a different command for the same log.</td>
</tr>
<tr>
<td>选举安全特性</td>
<td>对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 leader election 节）at most one leader can be elected in a given term.</td>
</tr>
<tr>
<td>领导人只附加原则</td>
<td>领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 log replication 节）a leader can only append new entries to its logs (it can neither overwrite nor delete entries).</td>
</tr>
<tr>
<td>领导人完全特性</td>
<td>如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 安全性 节）if a log entry is committed in a given term then it will be present in the logs of the leaders since this term</td>
</tr>
</tbody>
</table>
<p>一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。</p>
<p>这一节通过在领导选举的时候增加一些限制来完善 Raft 算法。这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目。</p>
<p>增加这一选举时的限制，我们对于提交时的规则也更加清晰。</p>
<p><strong>Raft 保证，只有包含了所有已经提交的日志条目的候选人才有可能赢得选举。</strong><br>候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。</p>
<p>如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。</p>
<p>请求投票 RPC 实现了这样的限制： RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。</p>
<p>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新：</p>
<ul>
<li>如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。</li>
<li>如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</li>
</ul>
<p>**Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；</p>
<p>一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。（Leader可以复制前面任期的日志，但是不会主动提交前面任期的日志。而是通过提交当前任期的日志，而间接地提交前面任期的日志）</p>
<p>在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用一种更加保守的方法。</p>
<p>当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号, 这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号).**</p>
<p>为了消除上述场景就规定Leader可以复制前面任期的日志，但是不会主动提交前面任期的日志。而是通过提交当前任期的日志，而间接地提交前面任期的日志。</p>
<h3 id="时间和可用性"><a href="#时间和可用性" class="headerlink" title="时间和可用性"></a>时间和可用性</h3><p>Raft 的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。例如，如果消息交换在服务器崩溃时花费更多的时间，候选人将不会等待太长的时间来赢得选举；没有一个稳定的领导人，Raft 将无法工作。</p>
<p>领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：</p>
<blockquote>
<p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</p>
</blockquote>
<p>在这个不等式中，广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；</p>
<p>选举超时时间就是在 5.2 节中介绍的选举的超时时间限制；</p>
<p>然后平均故障间隔时间就是对于一台服务器而言，两次故障之间的平均时间。</p>
<p>广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态；通过随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。</p>
<p>选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用；我们希望这种情况在整个系统的运行中很少出现。</p>
<p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol>
<li>ETCD</li>
<li>百度云 braft</li>
</ol>
<h2 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h2><ol>
<li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a> </li>
<li><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md</a></li>
<li><a href="https://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">https://www.cnblogs.com/mindwind/p/5231986.html</a></li>
<li><a href="https://raft.github.io/" target="_blank" rel="noopener">https://raft.github.io/</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1005803" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1005803</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>一致性</tag>
        <tag>Raft</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2018/03/18/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作，属于行为型模式(创建型、结构型、行为型）</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>操作<strong>复杂对象结构</strong>，将数据与操作分离。稳定的数据结构和易变的操作耦合问题。</p>
<h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</p>
<a id="more"></a>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>在医生开具处方单（药单）后，很多医院都存在如下处理流程：</p>
<ol>
<li>划价人员拿到  <strong>处方单</strong>  之后根据 <strong>药品名称和数量</strong>    <strong>计算总价</strong></li>
<li>药房工作人员根据 <strong>药品名称和数量</strong>   <strong>准备药品</strong></li>
</ol>
<p><img src="/img/15255288247167.jpg" alt></p>
<ol>
<li>我们可以将处方单看成一个药品信息的集合，里面包含了一种或多种不同类型的药品信息。</li>
<li>不同类型的工作人员（如划价人员和药房工作人员）在操作同一个药品信息集合时将提供不同的处理方式，而且可能还会增加新类型的工作人员来操作处方单。</li>
</ol>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>在被访问的类里面加一个对外提供接待访问者的接口。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/img/15255288648498.jpg" alt></p>
<p>在访问者模式结构图中包含如下几个角色：</p>
<p>●Vistor（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作。</p>
<p>●ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。</p>
<p>●Element（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法通常以一个抽象访问者作为参数。【稍后将介绍为什么要这样设计。】</p>
<p>●ConcreteElement（具体元素）：具体元素实现了accept()方法，在accept()方法中调用访问者的访问方法以便完成对一个元素的操作。</p>
<p>● ObjectStructure（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个List对象或一个Set对象。</p>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p>
<h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p><img src="/img/15255288942840.jpg" alt></p>
<h3 id="抽象元素-药"><a href="#抽象元素-药" class="headerlink" title="抽象元素 药"></a>抽象元素 药</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.pattern.visitor.element;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.visitor.MedicalStaff;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yutianfang</span></span><br><span class="line"><span class="comment"> * DATE: 18/3/18星期日.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMedicine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractMedicine <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractMedicine <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(MedicalStaff medicalStaff)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具体元素"><a href="#具体元素" class="headerlink" title="具体元素"></a>具体元素</h3><h4 id="感冒药"><a href="#感冒药" class="headerlink" title="感冒药"></a>感冒药</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.pattern.visitor.element.impl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.element.AbstractMedicine;</span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.visitor.MedicalStaff;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yutianfang</span></span><br><span class="line"><span class="comment"> * DATE: 18/3/18星期日.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColdMedicine</span> <span class="keyword">extends</span> <span class="title">AbstractMedicine</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(MedicalStaff medicalStaff)</span> </span>&#123;</span><br><span class="line">        medicalStaff.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColdMedicine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"感冒药"</span>;</span><br><span class="line">        <span class="keyword">this</span>.price = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="晕车药"><a href="#晕车药" class="headerlink" title="晕车药"></a>晕车药</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.pattern.visitor.element.impl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.element.AbstractMedicine;</span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.visitor.MedicalStaff;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yutianfang</span></span><br><span class="line"><span class="comment"> * DATE: 18/3/18星期日.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarSickMedicine</span> <span class="keyword">extends</span> <span class="title">AbstractMedicine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(MedicalStaff medicalStaff)</span> </span>&#123;</span><br><span class="line">        medicalStaff.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarSickMedicine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"晕车药"</span>;</span><br><span class="line">        <span class="keyword">this</span>.price = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a>对象结构</h3><h4 id="药单"><a href="#药单" class="headerlink" title="药单"></a>药单</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.pattern.visitor.element.impl;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yutianfang</span></span><br><span class="line"><span class="comment"> * DATE: 18/3/18星期日.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.element.AbstractMedicine;</span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.visitor.MedicalStaff;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 药单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prescription</span> <span class="keyword">extends</span> <span class="title">AbstractMedicine</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> List&lt;AbstractMedicine&gt; medicines = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(MedicalStaff medicalStaff)</span> </span>&#123;</span><br><span class="line">        medicines.forEach(medicine -&gt; &#123;</span><br><span class="line">            medicine.accept(medicalStaff);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Prescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ColdMedicine coldMedicine = <span class="keyword">new</span> ColdMedicine();</span><br><span class="line">        CarSickMedicine carSickMedicine = <span class="keyword">new</span> CarSickMedicine();</span><br><span class="line">        medicines.add(coldMedicine);</span><br><span class="line">        medicines.add(carSickMedicine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象访问者-医护人员"><a href="#抽象访问者-医护人员" class="headerlink" title="抽象访问者 医护人员"></a>抽象访问者 医护人员</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.pattern.visitor.visitor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.element.impl.CarSickMedicine;</span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.element.impl.ColdMedicine;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yutianfang</span></span><br><span class="line"><span class="comment"> * DATE: 18/3/18星期日.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 医护人员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MedicalStaff</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ColdMedicine coldMedicine)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(CarSickMedicine carSickMedicine)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具体访问者"><a href="#具体访问者" class="headerlink" title="具体访问者"></a>具体访问者</h3><h4 id="划价人员"><a href="#划价人员" class="headerlink" title="划价人员"></a>划价人员</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.pattern.visitor.visitor.impl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.element.impl.CarSickMedicine;</span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.element.impl.ColdMedicine;</span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.visitor.MedicalStaff;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yutianfang</span></span><br><span class="line"><span class="comment"> * DATE: 18/3/18星期日.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pricing</span> <span class="keyword">implements</span> <span class="title">MedicalStaff</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ColdMedicine coldMedicine)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"划价："</span> + coldMedicine.getName() + <span class="string">"，价格："</span> + coldMedicine.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(CarSickMedicine carSickMedicine)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"划价："</span> + carSickMedicine.getName() + <span class="string">"，价格："</span> + carSickMedicine.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="取药人员"><a href="#取药人员" class="headerlink" title="取药人员"></a>取药人员</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.pattern.visitor.visitor.impl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.element.impl.CarSickMedicine;</span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.element.impl.ColdMedicine;</span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.visitor.MedicalStaff;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yutianfang</span></span><br><span class="line"><span class="comment"> * DATE: 18/3/18星期日.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 药房取药</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pharmacy</span> <span class="keyword">implements</span> <span class="title">MedicalStaff</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ColdMedicine coldMedicine)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"取药："</span> + coldMedicine.getName());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(CarSickMedicine carSickMedicine)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"取药："</span> + carSickMedicine.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.pattern.visitor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.element.impl.Prescription;</span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.visitor.impl.Pharmacy;</span><br><span class="line"><span class="keyword">import</span> com.ytf.pattern.visitor.visitor.impl.Pricing;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yutianfang</span></span><br><span class="line"><span class="comment"> * DATE: 18/3/18星期日.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 药单</span></span><br><span class="line">        Prescription prescription = <span class="keyword">new</span> Prescription();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 划价</span></span><br><span class="line">        Pricing pricing = <span class="keyword">new</span> Pricing();</span><br><span class="line">        prescription.accept(pricing);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 取药</span></span><br><span class="line">        Pharmacy pharmacy = <span class="keyword">new</span> Pharmacy();</span><br><span class="line">        prescription.accept(pharmacy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><img src="/img/15255293069565.jpg" alt></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>符合单一职责原则。</li>
<li>优秀的扩展性。 </li>
<li>灵活性。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>具体元素对访问者公布细节，违反了迪米特原则。</li>
<li>具体元素变更比较困难。 增加具体元素时，访问者也需要添加。</li>
<li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网常用技术</title>
    <url>/2017/12/03/%E4%BA%92%E8%81%94%E7%BD%91%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p><img src="/img/%E4%BA%92%E8%81%94%E7%BD%91%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF.png" alt="互联网常用技术"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>一次OOM问题定位过程</title>
    <url>/2017/08/26/%E4%B8%80%E6%AC%A1OOM%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>8.21日bdop dev环境机器突然发生oom服务不可用，重启服务后也很快发生OOM。</p>
<p>之前一直运行没问题，OOM是突然发生的。</p>
<a id="more"></a>
<h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="获取dump文件"><a href="#获取dump文件" class="headerlink" title="获取dump文件"></a>获取dump文件</h3><p>之前机器上使用<strong>jps -v </strong>查看过启动参数<strong>：(下面的参数不是当时的，只是日期有差别,删除了公司目录相关参数）</strong></p>
<blockquote>
<p>4597 Bootstrap -Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -Djava.net.preferIPv6Addresses=false -Djava.io.tmpdir=/tmp -Djetty.defaultsDescriptor=WEB-INF/web.xml -Duser.timezone=GMT+08 -Xloggc:/XX/gc.log.201708251824 -XX:ErrorFile=/vmerr.log.201708251824 -XX:HeapDumpPath=/XX/XXXXX/logs/xxxx.heaperr.log.201708251824 -XX:+HeapDumpOnOutOfMemoryError -XX:+DisableExplicitGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Denvironment=test -Dmedis_environment=test -Dcore.zookeeper=sgconfig-zk.sankuai.com:9331 </p>
</blockquote>
<p>注意 <strong>XX:HeapDumpPath=/XX/XXXXX/logs/xxxx.heaperr.log.201708251824 -XX:+HeapDumpOnOutOfMemoryError</strong> 参数，这个是配置发生内存溢出时dump出文件到该路径下 。</p>
<p>到路径下获取dump文件。</p>
<p>ps：从服务器上取文件可用 python -m SimpleHTTPServer开一个http服务获取。</p>
<p>由于dump文件很大，下载前先压缩会小很多。</p>
<h3 id="MAT工具排查"><a href="#MAT工具排查" class="headerlink" title="MAT工具排查"></a>MAT工具排查</h3><p>将下载的dump文件然后使用MAT打开，MAT介绍：</p>
<p><a href="http://www.jianshu.com/p/d8e247b1e7b2" target="_blank" rel="noopener">http://www.jianshu.com/p/d8e247b1e7b2</a></p>
<p><a href="http://wiki.eclipse.org/MemoryAnalyzer" target="_blank" rel="noopener">http://wiki.eclipse.org/MemoryAnalyzer</a></p>
<p><a href="https://www.yourkit.com/docs/java/help/sizes.jsp" target="_blank" rel="noopener">https://www.yourkit.com/docs/java/help/sizes.jsp</a></p>
<ol>
<li>在界面选择 “Dominator Tree”:<img src="/2017/08/26/一次OOM问题定位过程/dominator_tree.png" title="dominator tree"></li>
<li>按对象大小排序<img src="/2017/08/26/一次OOM问题定位过程/object_size_sorted.png" title="object size sorted">
发现databus线程对象有900M大小。databus在服务中是用来同步表数据到ES中的，继续向下看对象里包含了什么</li>
<li>线程对象持有的对象<img src="/2017/08/26/一次OOM问题定位过程/reference_objects.png" title="reference objects">
发现持有了大量的hashmap和hashset对象。hashset是使用hashmap实现，所以直接看hashset。<br>mat显示hashset中一共有450000+个数据，内存溢出很可能就是这里导致的。<br>数据内容都还是一样的：<img src="/2017/08/26/一次OOM问题定位过程/same_data.png" title="same data"></li>
<li>由于是databus线程时同步表数据，于是到表中查找包含这些拼音的数据，但并没找到。</li>
<li>继续看线程对象持有的对象，看看是否有其它信息有用信息<img src="/2017/08/26/一次OOM问题定位过程/poi_id.png" title="poi_id">
对象持有的string对象直接给出了poi_id，所以到表里直接查该数据，发现该poi的poi_name字段为“需要超长超长超长超长超长超长超长超长….”</li>
<li>表中数据找到了但为什么会导致内存溢出呢？当时使用了一个比较笨的方法，直接在项目中搜 “HashSeet”，因为hashset还是比较少用的</li>
<li>发现在databus更新ES时有用到 将门店名称拼音存到索引中。直接将该门店名称放到单测里跑，发现果然很长时间不能结束。</li>
<li>一步步打断点定位到出问题的方法：<img src="/2017/08/26/一次OOM问题定位过程/descart_method.png" title="descart method"></li>
<li>该方法会计算多音字的所有组合。目的是为了支持多音字搜索。debug时发现pinyinSets大小有49，汉字“超长超长超长…”有多个“长”，因此会有多个2的n次方中组合。<br><strong>导致内存中有大量hashset，最终导致内存溢出</strong></li>
</ol>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>找到相关负责人修改，限制笛卡尔积最大长度为32，超过这个大小的多音字不再处理。</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><ol>
<li>该问题发生在线下，当天就改完了但没上线。第二天线上也很巧的也发生了一样故障导致OOM。还好前一天已经定位出了问题，直接发布上线解决。不然线上服务会不可用比较长时间。</li>
<li>推荐一个比较好用的jvm命令 jcmd</li>
</ol>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><ol>
<li>线下很奇怪的问题也需要重视，这次如果没有及时定位解决，到了第二天线上出问题就会引起比较严重的事故。会直接导致门店列表页无法展示，几乎影响M端所有系统。</li>
<li>难得的一次OOM问题排查实战，还是挺有收获的，后续需继续研究jvm及mat工具使用。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 锁机制</title>
    <url>/2017/08/16/MySql-%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="锁是什么"><a href="#锁是什么" class="headerlink" title="锁是什么"></a>锁是什么</h2><p>锁是计算机协调多个进程或纯线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所在有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决。</p>
<a id="more"></a>
<p>锁的运作？</p>
<p>事务T在度某个数据对象（如表、记录等）操作之前，先向系统发出请求，对其加锁，加锁后事务T就对数据库对象有一定的控制，在事务T释放它的锁之前，其他事务不能更新此数据对象。</p>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="按锁类型分"><a href="#按锁类型分" class="headerlink" title="按锁类型分"></a>按锁类型分</h3><h4 id="排他锁-又称写锁，X锁）"><a href="#排他锁-又称写锁，X锁）" class="headerlink" title="排他锁(又称写锁，X锁）"></a>排他锁(又称写锁，X锁）</h4><ul>
<li>会阻塞其他事务读和写。</li>
</ul>
<ul>
<li>若事务T对数据对象A(可能是表也可能是数据）加上X锁，则只允许T读取和修改A，其他任何事务都不能再对加任何类型的锁，直到T释放锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</li>
</ul>
<h4 id="共享锁-又称读取，S锁）"><a href="#共享锁-又称读取，S锁）" class="headerlink" title="共享锁(又称读取，S锁）"></a><strong>共享锁(</strong>又称读取，S锁）</h4><ul>
<li>会阻塞其他事务修改表数据。</li>
</ul>
<ul>
<li>若事务T对数据对象A加上S锁，则其他事务只能再对A加S锁，而不能X锁，直到T释放A上的锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li>
</ul>
<p>X锁和S锁都是加载某一个数据对象上的。也就是数据的粒度。</p>
<h3 id="按锁粒度分"><a href="#按锁粒度分" class="headerlink" title="按锁粒度分"></a>按锁粒度分</h3><h4 id="行级锁-row-level"><a href="#行级锁-row-level" class="headerlink" title="行级锁(row-level)"></a><strong>行级锁(row-level)</strong></h4><ul>
<li>开销大，加锁慢，<strong>针对索引加锁而不是数据</strong></li>
<li>会出现死锁。</li>
<li>锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
</ul>
<p>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。</p>
<p>缺陷：由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</p>
<h4 id="表级锁-table-level"><a href="#表级锁-table-level" class="headerlink" title="表级锁(table-level)"></a><strong>表级锁(table-level)</strong></h4><ul>
<li>开销小，加锁快。</li>
<li>不会出现死锁。</li>
<li>锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
</ul>
<p>和行级锁相反，表级别的锁是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。</p>
<p>缺陷：锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度大打折扣。</p>
<h4 id="页级锁-page-level-MySQL特有"><a href="#页级锁-page-level-MySQL特有" class="headerlink" title="页级锁(page-level) (MySQL特有)"></a><strong>页级锁(page-level) (</strong>MySQL特有)</h4><ul>
<li>开销和加锁时间界于表锁和行锁之间。</li>
<li>会出现死锁。</li>
<li>锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。</p>
<p>缺陷：页级锁定和行级锁定一样，会发生死锁。</p>
<h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><ul>
<li>ACID</li>
</ul>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul>
<li>默认都清楚</li>
</ul>
<h2 id="InnoDB锁机制"><a href="#InnoDB锁机制" class="headerlink" title="InnoDB锁机制"></a>InnoDB锁机制</h2><p>一共三类：<strong>共享锁，排他锁，意向锁</strong>。</p>
<p>意向锁为innodb引擎特有，单独介绍：</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>举个例子，数据库操作存在以下场景：</p>
<p>事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。</p>
<p>数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。数据库要怎么判断这个冲突呢？</p>
<p>普通认为两步：</p>
<ol>
<li>判断表是否已被其他事务用表锁锁表。</li>
<li>判断表中的每一行是否已被行锁锁住。但是这样的方法效率很低，因为要遍历整个表。</li>
</ol>
<p>所以<strong>解决方案是</strong>：意向锁。</p>
<p>在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。</p>
<p>在意向锁存在的情况下，两步骤为</p>
<ol>
<li>判断表是否已被其他事务用表锁锁表。</li>
<li>发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。</li>
</ol>
<p>注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。</p>
<p><strong>意向锁目的：</strong>解决表级锁和行级锁之间的冲突</p>
<p><strong>意向锁是一种表级锁</strong>，锁的粒度是整张表。结合共享与排他锁使用，分为<strong>意向共享锁（IS）</strong>和<strong>意向排他锁（IX）</strong>。意向锁为了方便检测表级锁和行级锁之间的冲突，故在给一行记录加锁前，首先给该表加意向锁。也就是同时加意向锁和行级锁。</p>
<h3 id="锁之间的兼容性"><a href="#锁之间的兼容性" class="headerlink" title="锁之间的兼容性"></a>锁之间的兼容性</h3><table>
<thead>
<tr>
<th>请求锁模式/是否兼容/当前锁模式</th>
<th>共享锁</th>
<th>排他锁</th>
<th>意向共享锁</th>
<th>意向排他锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>共享锁</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>排他锁</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>意向共享锁</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>意向排他锁</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<p>如果一个事务请求的锁模式与当前的锁模式兼容，innodb就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p>
<p><strong>意向锁是Innodb自动加的，不需要用户干预</strong>。</p>
<p>对于UPDATE、DELETE、INSERT语句，Innodb会自动给涉及的数据集加排他锁（X）；对于普通SELECT语句，Innodb不会加任何锁。</p>
<p>若读操作想加锁需显示指定：</p>
<blockquote>
<p><code>//显示共享锁(S)</code></p>
<p><code>SELECT * FROM table_name WHERE .... LOCK IN SHARE MODE</code></p>
<p><code>//显示排他锁(X)</code></p>
<p><code>SELECT * FROM table_name WHERE .... FOR UPDATE.</code></p>
</blockquote>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p>
<p>举例来说，假如user表中只有101条记录，其userid 的值分别是1,2,…,100,101，下面的SQL：SELECT * FROM user WHERE userid &gt; 100 FOR UPDATE</p>
<p>上面是一个范围条件的检索，InnoDB不仅会对符合条件的userid 值为101的记录加锁，也会对userid 大于101（这些记录并不存在）的“间隙”加锁。</p>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了userid 大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。</p>
<p>实际开发：</p>
<p>可见，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
<h3 id="何时使用表锁"><a href="#何时使用表锁" class="headerlink" title="何时使用表锁"></a>何时使用表锁</h3><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个另特殊事务中，也可以考虑使用表级锁。</p>
<ol>
<li>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li>
<li>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li>
</ol>
<p>在InnoDB下 ，<strong>使用表锁要注意以下两点。</strong></p>
<p>（１）使用LOCK TALBES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层ＭySQL Server负责的，仅当autocommit=0、innodb_table_lock=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，ＭySQL Server才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。</p>
<p>如果需要写表t1并从表t读，可以按如下做：</p>
<blockquote>
<p>mysql&gt; SET AUTOCOMMIT=<code>0</code>;</p>
<p>mysql&gt; LOCAK TABLES t1 WRITE, t2 READ, …;`</p>
<p>[<code></code>do<code></code>something with tables t1 and here];`</p>
<p>mysql&gt; COMMIT;`</p>
<p>mysql&gt; UNLOCK TABLES;`</p>
</blockquote>
<h3 id="事务引擎导致的死锁"><a href="#事务引擎导致的死锁" class="headerlink" title="事务引擎导致的死锁"></a><strong>事务引擎导致的死锁</strong></h3><p>发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并退回，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决。<strong>需要说明的是，这个参数并不是只用来解决死锁问题</strong>，在并发访问比较高的情况下，如果大量事务因无法立即获取所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖垮数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。</p>
<p>通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小、以及访问数据库的SQL语句，绝大部分都可以避免。</p>
<p>下面就通过实例来介绍几种死锁的常用避免和解决方法。</p>
<ol>
<li>在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序为访问表，这样可以大大降低产生死锁的机会。如果两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可能避免。</li>
<li>在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低死锁的可能。</li>
<li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁，甚至死锁。</li>
<li>在REPEATEABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT…ROR UPDATE加排他锁，在没有符合该记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可以避免问题。</li>
<li>当隔离级别为READ COMMITED时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第１个线程提交后，第２个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第３个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。</li>
</ol>
<p>尽管通过上面的设计和优化等措施，可以大减少死锁，但死锁很难完全避免。因此，在程序设计中总是捕获并处理死锁异常是一个很好的编程习惯。</p>
<p>如果出现死锁，可以用SHOW INNODB STATUS命令来确定最后一个死锁产生的原因和改进措施。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h3 id="next-key-锁"><a href="#next-key-锁" class="headerlink" title="next-key 锁"></a>next-key 锁</h3><h3 id="表锁问题"><a href="#表锁问题" class="headerlink" title="表锁问题"></a>表锁问题</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/jack__frost/article/details/73347688" target="_blank" rel="noopener">http://blog.csdn.net/jack__frost/article/details/73347688</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper概述</title>
    <url>/2017/07/10/zookeeper%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>ZooKeeper是一个用于分布式应用的开源分布式协调服务。它提供了简单的原语集合，分布式应用可在这些原语之上构建用于同步、配置维护、分组和命名的高层服务。ZooKeeper的设计使得编程容易，并且使用类似于广泛熟知的文件系统目录树结构的数据模型。它运行在Java环境中，但是有Java和C语言绑定。分布式协调服务是出了名的难得编写正确，很容易出现竞争条件和死锁之类的错误。ZooKeeper的动机是减轻为分布式应用开发协调服务的负担。<br><a id="more"></a></p>
<h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>ZooKeeper让分布式进程通过共享的、与标准文件系统类似的分层名字空间相互协调。名字空间由数据寄存器（在ZooKeeper世界中称作znode）构成，这与文件和目录类似。与典型文件系统不同的是，ZooKeeper在内存中保存数据，这让其可以达到高吞吐量和低延迟。</p>
<p>ZooKeeper的实现很重视高性能、高可用性，以及严格的顺序访问。高性能意味着可将ZooKeeper用于大的分布式系统。可靠性使之可避免单点失败。严格的顺序访问使得客户端可以实现复杂的同步原语。</p>
<h3 id="自我复制"><a href="#自我复制" class="headerlink" title="自我复制"></a>自我复制</h3><p>与它所协调的进程一样，ZooKeeper本身也会试图在集群中进行复制。</p>
<img src="/2017/07/10/zookeeper概述/ZooKeeper-Service.jpg" title="ZooKeeper Service">
<p>组成ZooKeeper服务的各个服务器必须相互知道对方。它们在内存中维护状态和事务日志，还在永久存储中维护快照。只要大部分(majority)服务器可用，ZooKeeper服务就是可用的。</p>
<h3 id="有序"><a href="#有序" class="headerlink" title="有序"></a>有序</h3><p>ZooKeeper为每次更新设置一个反映所有ZooKeeper事务顺序的序号。后续操作可使用序号来实现更高层抽象，如同步原语。</p>
<h3 id="高速"><a href="#高速" class="headerlink" title="高速"></a>高速</h3><p>在读多的应用中zookeeper尤其快，读写比例10:1时表现最好</p>
<h2 id="数据模型与分层的命名空间"><a href="#数据模型与分层的命名空间" class="headerlink" title="数据模型与分层的命名空间"></a>数据模型与分层的命名空间</h2><p>ZooKeeper提供的名字空间与标准文件系统非常相似。名字是一个由斜杠/分隔的路径元素序列。ZooKeeper名字空间中的每个节点都由其路径标识。</p>
<img src="/2017/07/10/zookeeper概述/zknamespace.jpg" title="zk namespace">
<h3 id="节点与临时节点"><a href="#节点与临时节点" class="headerlink" title="节点与临时节点"></a>节点与临时节点</h3><p>与标准文件系统不同，ZooKeeper名字空间中的每个节点都可以有关联的数据以及子节点。这就像一个允许文件也是目录的文件系统。（ZooKeeper设计用于存储协调数据：状态信息、配置、位置信息等，所以通常存储在每个节点中的数据很小，在字节到千字节范围内）讨论ZooKeeper数据节点时，我们用术语znode来明确指示。</p>
<p>Znode会维护一个stat结构体，其中包含数据和ACL的版本号与时间戳，以便于进行缓存验证和协调更新。每次修改znode数据时，版本号会增长。客户端获取数据的时候，也同时获取数据的版本。</p>
<p>对znode数据的读写操作是原子的。读取操作获取节点的所有数据，写入操作替换所有数据。节点的访问控制列表（ACL）控制可以进行操作的用户。</p>
<p>ZooKeeper具有临时节点的概念。只要创建节点的会话是活动的，临时节点就存在。一旦会话终止，临时节点会被删除。临时节点对于实现tbd是很有用的。</p>
<h3 id="条件更新和观察"><a href="#条件更新和观察" class="headerlink" title="条件更新和观察"></a>条件更新和观察</h3><p>ZooKeeper支持观察的概念。客户端可以在znode上设置观察。观察将在znode修改时被触发和移除。观察被触发时客户端会收到一个数据包，指示znode已经被修改。如果与ZooKeeper服务之间的连接断开，客户端会收到一个本地通知。这可用于tbd。</p>
<h3 id="保证"><a href="#保证" class="headerlink" title="保证"></a>保证</h3><p>ZooKeeper非常高效和简单。基于其目标：成为构建如同步这样的更复杂服务的基础，ZooKeeper提供下述保证：</p>
<p>顺序一致性：客户端的更新将以请求发送的次序被应用。</p>
<p>原子性：更新要么成功，要么失败，没有部分更新。</p>
<p>单一系统镜像：无论连接到哪个服务器，客户端将看到一样的视图。</p>
<p>可靠性：更新操作的结果将是持续的，直到客户端覆盖了更新。</p>
<p>及时性：在某个时间范围内，客户端视图确保是最新的。</p>
<p>关于这些保证的详细信息，以及如何使用这些保证，请参看tbd。</p>
<h3 id="简单的API"><a href="#简单的API" class="headerlink" title="简单的API"></a>简单的API</h3><p>ZooKeeper的设计目标之一是提供非常简单的编程接口。ZooKeeper仅支持这些操作：</p>
<p>create：在树中某位置创建一个节点。</p>
<p>delete：删除一个节点。</p>
<p>exists：测试某位置是否存在某节点。</p>
<p>get data：读取节点数据。</p>
<p>set data：向节点写入数据。</p>
<p>get children：获取子节点列表。</p>
<p>sync：等待数据传播。</p>
<p>关于这些操作的更深入讨论，以及如何使用它们来实现更高层的操作，请参看tbd。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>下图显示了ZooKeeper服务的高层组件。除了请求处理器(Request Processor)之外，组成ZooKeeper服务的每个服务器拥有每个组件的自有拷贝。</p>
<img src="/2017/07/10/zookeeper概述/zkcomponents.jpg" title="zk components">
<p>自我复制数据库(replicated database)是一个包含整个数据树的内存数据库。更新会记录到磁盘中以便可以恢复，并且将写操作应用到内存数据库之前会先写入到磁盘。</p>
<p>每个ZooKeeper服务器都为客户服务。客户端连接到一个服务器，提交请求。读请求由每个服务器数据库的本地拷贝进行服务。改变服务状态的请求和写请求由一致性协议处理。</p>
<p>作为一致性协议的一部分，客户端的所有写请求都被转发到单个服务器，也就是领导者。其他ZooKeeper服务器则是跟随者，它们接收来自领导者的建议，对传递的消息达成一致。消息层考虑了替换失败的领导者和跟随者与领导者同步的问题。</p>
<p>ZooKeeper使用定制的原子消息协议。因为消息层是原子的，ZooKeeper可保证本地拷贝不会发散（diverge）。收到写请求时，领导者计算写入操作后系统的状态，将其转换成一个捕获此状态的事务。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>ZooKeeper的编程接口非常简单。但是，可将其用于实现高层顺序操作，如同步原语、组成员管理、所有者关系管理等。更多信息请参看tbd。</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>ZooKeeper被设计为高性能的。但它真的是高性能的吗？Yahoo研究中心的ZooKeeper开发团队证实了ZooKeeper的高性能，特别是在读操作比写操作多的应用中（见下图），因为写操作涉及在所有服务器间同步状态。（读操作比写操作多是协调服务的典型情况）</p>
<img src="/2017/07/10/zookeeper概述/zkthrought.png" title="zk throught">
<p>上图是ZooKeeper 3.2在配置有两个2GHz Xeon处理器和两个SATA 15K RPM驱动器的服务器上运行时的吞吐率图形。一个驱动器配置为ZooKeeper日志专用设备。快照写入到操作系统驱动器。读写操作1KB的数据。“服务器数”指的是ZooKeeper集群的大小，即组成服务的服务器个数。大约30个其他服务器用于模拟客户端。ZooKeeper集群配置为不允许客户端连接到领导者。</p>
<p>提示：3.2版的读写性能是3.1版的2倍。</p>
<p>Benchmarks也表明ZooKeeper是可靠的。下图（可靠性中的图）显示了ZooKeeper在各种失败情况下的反应。图中标记的各个事件是：</p>
<p>1．跟随者失败和恢复</p>
<p>2．另一个跟随者失败和恢复</p>
<p>3．领导者失败</p>
<p>4．两个跟随者失败和恢复</p>
<p>5．另一个领导者失败</p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>为揭示在有失败注入时系统的行为，我们在一个由7台机器组成的ZooKeeper服务上运行和先前一样的benchmark测试，但是让写操作的百分比固定为30%，这是预期负载比例的保守估计。</p>
<img src="/2017/07/10/zookeeper概述/zkperfreliability.jpg" title="zk performance reliability">
<p>此图有几处值得仔细观察。首先，如果跟随者失败后快速恢复，则ZooKeeper可以维持高吞吐率。但更重要的是，领导者选举算法让系统可以足够快地恢复，以阻止吞吐率有实质性的下降。据我们观察，ZooKeeper选举一个新的领导者的时间小于200ms。第三，一旦跟随者恢复并且开始处理请求，ZooKeeper可以恢复高吞吐率。</p>
<h2 id="ZooKeeper-项目"><a href="#ZooKeeper-项目" class="headerlink" title="ZooKeeper 项目"></a>ZooKeeper 项目</h2><p>ZooKeeper已经在很多工业应用中<a href="http://wiki.apache.org/hadoop/ZooKeeper/PoweredBy" target="_blank" rel="noopener">成功使用</a>。Yahoo!在Yahoo! Message Broker中使用ZooKeeper作为协调和故障恢复服务。Yahoo! Message Broker是一个高度扩展的发布-订阅系统，管理着成千上万个需要拷贝和数据传递的话题。Yahoo!的很多广告系统也使用ZooKeeper来实现可靠服务。</p>
<p>我们鼓励用户和开发者加入社区，贡献技能。更多信息请看<a href="http://hadoop.apache.org/zookeeper/" target="_blank" rel="noopener">Apache的ZooKeeper工程</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zookeeper.apache.org/doc/trunk/zookeeperOver.html" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/trunk/zookeeperOver.html</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Vgrant使用入门</title>
    <url>/2017/06/26/Vgrant%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>前面讲了Vagrant的几个命令：</p>
<ul>
<li>vagrant box add 添加box的操作</li>
<li>vagrant init 初始化box的操作</li>
<li>vagrant up 启动虚拟机的操作</li>
<li>vagrant ssh 登录虚拟机的操作</li>
</ul>
<a id="more"></a>
<p>Vagrant还包括如下一些操作：</p>
<ul>
<li><p>vagrant box list<br>显示当前已经添加的box列表<br>$ vagrant box list<br>base (virtualbox)<br>vagrant box remove</p>
</li>
<li><p>删除相应的box<br>$ vagrant box remove base virtualbox<br>Removing box ‘base’ with provider ‘virtualbox’…</p>
</li>
<li><p>vagrant destroy<br>停止当前正在运行的虚拟机并销毁所有创建的资源<br>$ vagrant destroy<br>Are you sure you want to destroy the ‘default’ VM? [y/N] y<br>[default] Destroying VM and associated drives…</p>
</li>
<li><p>vagrant halt<br>关机</p>
<p>$ vagrant halt<br>[default] Attempting graceful shutdown of VM…</p>
</li>
<li><p>vagrant package<br>打包命令，可以把当前的运行的虚拟机环境进行打包</p>
<p>$ vagrant package<br>[default] Attempting graceful shutdown of VM…<br>[default] Clearing any previously set forwarded ports…<br>[default] Creating temporary directory for export…<br>[default] Exporting VM…<br>[default] Compressing package to: /Users/astaxie/vagrant/package.box</p>
</li>
<li><p>vagrant plugin<br>用于安装卸载插件</p>
</li>
<li><p>vagrant provision</p>
</li>
</ul>
<p>通常情况下Box只做最基本的设置，而不是设置好所有的环境，因此Vagrant通常使用Chef或者Puppet来做进一步的环境搭建。那么Chef或者Puppet称为provisioning，而该命令就是指定开启相应的provisioning。按照Vagrant作者的说法，所谓的provisioning就是”The problem of installing software on a booted system”的意思。除了Chef和Puppet这些主流的配置管理工具之外，我们还可以使用Shell来编写安装脚本。</p>
<p>例如： vagrant provision –provision-with chef</p>
<ul>
<li>vagrant reload</li>
</ul>
<p>重新启动虚拟机，主要用于重新载入配置文件</p>
<p>  $ vagrant reload<br>  [default] Attempting graceful shutdown of VM…<br>  [default] Setting the name of the VM…<br>  [default] Clearing any previously set forwarded ports…<br>  [default] Creating shared folders metadata…<br>  [default] Clearing any previously set network interfaces…<br>  [default] Preparing network interfaces based on configuration…<br>  [default] Forwarding ports…<br>  [default] – 22 =&gt; 2222 (adapter 1)<br>  [default] Booting VM…<br>  [default] Waiting for VM to boot. This can take a few minutes.<br>  [default] VM booted and ready for use!<br>  [default] Setting hostname…<br>  [default] Mounting shared folders…<br>  [default] – /vagrant</p>
<ul>
<li><p>vagrant resume<br>恢复前面被挂起的状态</p>
<p>$vagrant resume<br>[default] Resuming suspended VM…<br>[default] Booting VM…<br>[default] Waiting for VM to boot. This can take a few minutes.<br>[default] VM booted and ready for use!</p>
</li>
<li><p>vagrant ssh-config<br>输出用于ssh连接的一些信息</p>
<p>$vagrant ssh-config<br>Host default<br>  HostName 127.0.0.1<br>  User vagrant<br>  Port 2222<br>  UserKnownHostsFile /dev/null<br>  StrictHostKeyChecking no<br>  PasswordAuthentication no<br>  IdentityFile “/Users/astaxie/.vagrant.d/insecure_private_key”<br>  IdentitiesOnly yes<br>  LogLevel FATAL</p>
</li>
<li><p>vagrant status<br>获取当前虚拟机的状态</p>
<p>$vagrant status<br>Current machine states:</p>
<p>default                   running (virtualbox)</p>
<p>The VM is running. To stop this VM, you can run <code>vagrant halt</code> to<br>shut it down forcefully, or you can run <code>vagrant suspend</code> to simply<br>suspend the virtual machine. In either case, to restart it again,<br>simply run <code>vagrant up</code>.</p>
</li>
<li><p>vagrant suspend<br>挂起当前的虚拟机</p>
<p>$ vagrant suspend<br>[default] Saving VM state and suspending execution…</p>
</li>
</ul>
<h2 id="模拟打造多机器的分布式系统"><a href="#模拟打造多机器的分布式系统" class="headerlink" title="模拟打造多机器的分布式系统"></a>模拟打造多机器的分布式系统</h2><p>前面这些单主机单虚拟机主要是用来自己做开发机，从这部分开始的内容主要将向大家介绍如何在单机上通过虚拟机来打造分布式造集群系统。这种多机器模式特别适合以下几种人：</p>
<ol>
<li><p>快速建立产品网络的多机器环境，例如web服务器、db服务器</p>
</li>
<li><p>建立一个分布式系统，学习他们是如何交互的</p>
</li>
<li><p>测试API和其他组件的通信</p>
</li>
<li><p>容灾模拟，网络断网、机器死机、连接超时等情况</p>
</li>
</ol>
<p>Vagrant支持单机模拟多台机器，而且支持一个配置文件Vagrntfile就可以跑分布式系统。</p>
<p>现在我们来建立多台VM跑起來，並且让他们之间能够相通信，假设一台是应用服务器、一台是DB服务器，那么这个结构在Vagrant中非常简单，其实和单台的配置差不多，你只需要通过config.vm.define来定义不同的角色就可以了，现在我们打开配置文件进行如下设置：</p>
<p>Vagrant.configure(“2”) do |config|<br>  config.vm.define :web do |web|<br>    web.vm.provider “virtualbox” do |v|<br>          v.customize [“modifyvm”, :id, “–name”, “web”, “–memory”, “512”]<br>    end<br>    web.vm.box = “base”<br>    web.vm.hostname = “web”<br>    web.vm.network :private_network, ip: “11.11.1.1”<br>  end</p>
<p>  config.vm.define :db do |db|<br>    db.vm.provider “virtualbox” do |v|<br>          v.customize [“modifyvm”, :id, “–name”, “db”, “–memory”, “512”]<br>    end<br>    db.vm.box = “base”<br>    db.vm.hostname = “db”<br>    db.vm.network :private_network, ip: “11.11.1.2”<br>  end<br>end<br>这里的设置和前面我们单机设置配置类似，只是我们使用了:web以及:db分別做了两个VM的设置，并且给每个VM设置了不同的hostname和IP，设置好之后再使用vagrant up将虚拟机跑起来：</p>
<blockquote>
<p>$ vagrant up<br>Bringing machine ‘web’ up with ‘virtualbox’ provider…<br>Bringing machine ‘db’ up with ‘virtualbox’ provider…<br>[web] Setting the name of the VM…<br>[web] Clearing any previously set forwarded ports…<br>[web] Creating shared folders metadata…<br>[web] Clearing any previously set network interfaces…<br>[web] Preparing network interfaces based on configuration…<br>[web] Forwarding ports…<br>[web] – 22 =&gt; 2222 (adapter 1)<br>[web] Running any VM customizations…<br>[web] Booting VM…<br>[web] Waiting for VM to boot. This can take a few minutes.<br>[web] VM booted and ready for use!<br>[web] Setting hostname…<br>[web] Configuring and enabling network interfaces…<br>[web] Mounting shared folders…<br>[web] – /vagrant<br>[db] Setting the name of the VM…<br>[db] Clearing any previously set forwarded ports…<br>[db] Fixed port collision for 22 =&gt; 2222. Now on port 2200.<br>[db] Creating shared folders metadata…<br>[db] Clearing any previously set network interfaces…<br>[db] Preparing network interfaces based on configuration…<br>[db] Forwarding ports…<br>[db] – 22 =&gt; 2200 (adapter 1)<br>[db] Running any VM customizations…<br>[db] Booting VM…<br>[db] Waiting for VM to boot. This can take a few minutes.<br>[db] VM booted and ready for use!<br>[db] Setting hostname…<br>[db] Configuring and enabling network interfaces…<br>[db] Mounting shared folders…<br>[db] – /vagrant</p>
</blockquote>
<p>看到上面的信息输出后，我们就可以通过vagrant ssh登录虚拟机了，但是这次和上次使用的不一样了，这次我们需要指定相应的角色，用来告诉ssh你期望连接的是哪一台：</p>
<p>$ vagrant ssh web<br>vagrant@web:~$</p>
<p>$ vagrant ssh db<br>vagrant@db:~$<br>是不是很酷！现在接下来我们再来验证一下虚拟机之间的通信，让我们先使用ssh登录web虚拟机，然后在web虚拟机上使用ssh登录db虚拟机(默认密码是vagrant)：</p>
<blockquote>
<p>$ vagrant ssh web<br>Linux web 2.6.32-38-server #83-Ubuntu SMP Wed Jan 4 11:26:59 UTC 2012 x86_64 GNU/Linux<br>Ubuntu 10.04.4 LTS</p>
</blockquote>
<blockquote>
<p>Welcome to the Ubuntu Server!</p>
<ul>
<li>Documentation:  <a href="http://www.ubuntu.com/server/doc" target="_blank" rel="noopener">http://www.ubuntu.com/server/doc</a><br>New release ‘precise’ available.<br>Run ‘do-release-upgrade’ to upgrade to it.</li>
</ul>
</blockquote>
<blockquote>
<p>Welcome to your Vagrant-built virtual machine.<br>Last login: Thu Aug  8 18:55:44 2013 from 10.0.2.2<br>vagrant@web:~$ ssh 11.11.1.2<br>The authenticity of host ‘11.11.1.2 (11.11.1.2)’ can’t be established.<br>RSA key fingerprint is e7:8f:07:57:69:08:6e:fa:82:bc:1c:f6:53:3f:12:9e.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘11.11.1.2’ (RSA) to the list of known hosts.<br><a href="mailto:vagrant@11.11.1.2" target="_blank" rel="noopener">vagrant@11.11.1.2</a>‘s password:<br>Linux db 2.6.32-38-server #83-Ubuntu SMP Wed Jan 4 11:26:59 UTC 2012 x86_64 GNU/Linux<br>Ubuntu 10.04.4 LTS</p>
</blockquote>
<blockquote>
<p>Welcome to the Ubuntu Server!</p>
<ul>
<li>Documentation:  <a href="http://www.ubuntu.com/server/doc" target="_blank" rel="noopener">http://www.ubuntu.com/server/doc</a><br>New release ‘precise’ available.<br>Run ‘do-release-upgrade’ to upgrade to it.</li>
</ul>
</blockquote>
<blockquote>
<p>Welcome to your Vagrant-built virtual machine.<br>Last login: Thu Aug  8 18:58:50 2013 from 10.0.2.2<br>vagrant@db:~$</p>
</blockquote>
<p>通过上面的信息我们可以看到虚拟机之间通信是畅通的，所以现在开始你伟大的架构设计吧，你想设计怎么样的架构都可以，唯一限制你的就是你主机的硬件配置了。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Vagrant</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Vagrant安装配置</title>
    <url>/2017/06/26/Vagrant%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>实际上Vagrant只是一个让你可以方便设置你想要的虚拟机的便携式工具，它底层支持VirtualBox、VMware甚至AWS作为虚拟机系统，本书中我们将使用VirtualBox来进行说明，所以第一步需要先安裝Vagrant和VirtualBox。</p>
<a id="more"></a>
<h2 id="VirtualBox安装"><a href="#VirtualBox安装" class="headerlink" title="VirtualBox安装"></a>VirtualBox安装</h2><p>VirtualBox是Oracle开源的虚拟化系统，它支持多个平台，所以你可以到官方网站：<a href="https://www.virtualbox.org/wiki/Downloads/" target="_blank" rel="noopener">https://www.virtualbox.org/wiki/Downloads/</a> 下载适合你平台的VirtualBox最新版本并安装，它的安装过程都很傻瓜化，一步一步执行就可以完成安装了。</p>
<h2 id="Vagrant安装"><a href="#Vagrant安装" class="headerlink" title="Vagrant安装"></a>Vagrant安装</h2><p>最新版本的Vagrant已经无法通过gem命令来安装，因为依赖库太多了，所以目前无法使用gem来安装，目前网络上面很多教程还是类似这样的命令，那些都是错误的。目前唯一安装的办法就是到官方网站下载打包好的安装包：<a href="http://www.vagrantup.com/downloads.html" target="_blank" rel="noopener">http://www.vagrantup.com/downloads.html</a> 他的安装过程和VirtualBox的安装一样都是傻瓜化安装，一步一步执行就可以完成安装。尽量下载最新的程序，因为VirtualBox经常升级，升级后有些接口会变化，老的Vagrant可能无法使用。</p>
<p>要想检测安装是否成功，可以打开终端命令行工具，输入vagrant，看看程序是不是已经可以运行了。如果不行，请检查一下$PATH里面是否包含vagrant所在的路径。</p>
<h2 id="Vagrant配置"><a href="#Vagrant配置" class="headerlink" title="Vagrant配置"></a>Vagrant配置</h2><p>当我们安装好VirtualBox和Vagrant后，我们要开始考虑在VM上使用什么操作系统了，一个打包好的操作系统在Vagrant中称为Box，即Box是一个打包好的操作系统环境，目前网络上什么都有，所以你不用自己去制作操作系统或者制作Box：vagrantbox.es上面有大家熟知的大多数操作系统，你只需要下载就可以了，下载主要是为了安装的时候快速，当然Vagrant也支持在线安装。没找到Mac的，其他地方找到了 <a href="http://files.dryga.com/boxes/osx-yosemite-0.2.1.box" target="_blank" rel="noopener">http://files.dryga.com/boxes/osx-yosemite-0.2.1.box</a></p>
<h2 id="建立开发环境目录"><a href="#建立开发环境目录" class="headerlink" title="建立开发环境目录"></a>建立开发环境目录</h2><p>我们的开发机是Mac，所以我建立了如下的开发环境目录，读者可以根据自己的系统不同建立一个目录就可以：</p>
<p>/Users/mater/vagrant</p>
<h2 id="下载box"><a href="#下载box" class="headerlink" title="下载box"></a>下载box</h2><p>前面讲了box是一个操作系统环境，实际上它是一个zip包，包含了Vagrant的配置信息和VirtualBox的虚拟机镜像文件.<a href="http://files.dryga.com/boxes/osx-yosemite-0.2.1.box" target="_blank" rel="noopener">http://files.dryga.com/boxes/osx-yosemite-0.2.1.box</a></p>
<p>当然你也可以选一个自己团队在用的系统，例如CentOS、Debian等，我们可以通过上面说的地址下载开源爱好者们制作好的box。</p>
<h2 id="添加box"><a href="#添加box" class="headerlink" title="添加box"></a>添加box</h2><p>添加box的命令如下：</p>
<p>vagrant box add base 远端的box地址或者本地的box文件名<br>vagrant box add 是添加box的命令</p>
<p>base是box的名称，可以是任意的字符串，base是默认名称，主要用来标识一下你添加的box，后面的命令都是基于这个标识来操作的。</p>
<p>例子：</p>
<p>vagrant box add base <a href="http://files.vagrantup.com/lucid64.box" target="_blank" rel="noopener">http://files.vagrantup.com/lucid64.box</a><br>vagrant box add base <a href="https://dl.dropbox.com/u/7225008/Vagrant/CentOS-6.3-x86_64-minimal.box" target="_blank" rel="noopener">https://dl.dropbox.com/u/7225008/Vagrant/CentOS-6.3-x86_64-minimal.box</a><br>vagrant box add base CentOS-6.3-x86_64-minimal.box<br>vagrant box add “CentOS 6.3 x86_64 minimal” CentOS-6.3-x86_64-minimal.box<br>我在开发机上面是这样操作的，首先进入我们的开发环境目录/Users/astaxie/vagrant，执行如下的命令</p>
<p>vagrant box add base lucid64.box<br>安装过程的信息：</p>
<p>Downloading or copying the box…<br>Extracting box…te: 47.5M/s, Estimated time remaining: –:–:–)<br>Successfully added box ‘base’ with provider ‘virtualbox’!<br>box中的镜像文件被放到了：/Users/astaxie/.vagrant.d/boxes/，如果在window系统中应该是放到了： C:\Users\当前用户名.vagrant.d\boxes\目录下。</p>
<p>通过vagrant box add这样的方式安装远程的box，可能很慢，所以建议大家先下载box到本地再执行这样的操作。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化的命令如下：</p>
<p>vagrant init<br>如果你添加的box名称不是base，那么需要在初始化的时候指定名称，例如</p>
<p>vagrant init “CentOS 6.3 x86_64 minimal”<br>初始化过程的信息：</p>
<p>A <code>Vagrantfile</code> has been placed in this directory.<br>You are now ready to <code>vagrant up</code> your first virtual environment!<br>Please read the comments in the Vagrantfile as well as documentation on <code>vagrantup.com</code> for more information on using Vagrant.<br>这样就会在当前目录生成一个 Vagrantfile的文件，里面有很多配置信息，后面我们会详细讲解每一项的含义，但是默认的配置就可以开箱即用。</p>
<h2 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h2><p>启动虚拟机的命令如下：</p>
<p>vagrant up<br>启动过程的信息:</p>
<p>Bringing machine ‘default’ up with ‘virtualbox’ provider…<br>[default] Importing base box ‘base’…<br>[default] Matching MAC address for NAT networking…<br>[default] Setting the name of the VM…<br>[default] Clearing any previously set forwarded ports…<br>[default] Creating shared folders metadata…<br>[default] Clearing any previously set network interfaces…<br>[default] Preparing network interfaces based on configuration…<br>[default] Forwarding ports…<br>[default] – 22 =&gt; 2222 (adapter 1)<br>[default] Booting VM…<br>[default] Waiting for VM to boot. This can take a few minutes.<br>[default] VM booted and ready for use!<br>[default] Mounting shared folders…<br>[default] – /vagrant</p>
<h2 id="连接到虚拟机"><a href="#连接到虚拟机" class="headerlink" title="连接到虚拟机"></a>连接到虚拟机</h2><p>上面已经启动了虚拟机，之后我们就可以通过ssh来连接到虚拟机了。比如在我的开发机中可以像这样来连接：</p>
<p>vagrant ssh<br>连接到虚拟机后的信息如下：</p>
<p>Linux lucid64 2.6.32-38-server #83-Ubuntu SMP Wed Jan 4 11:26:59 UTC 2012 x86_64 GNU/Linux<br>Ubuntu 10.04.4 LTS</p>
<p>Welcome to the Ubuntu Server!</p>
<ul>
<li>Documentation:  <a href="http://www.ubuntu.com/server/doc" target="_blank" rel="noopener">http://www.ubuntu.com/server/doc</a><br>New release ‘precise’ available.<br>Run ‘do-release-upgrade’ to upgrade to it.</li>
</ul>
<p>Welcome to your Vagrant-built virtual machine.<br>Last login: Fri Sep 14 07:31:39 2012 from 10.0.2.2<br>这样我们就可以像连接到一台服务器一样进行操作了。window机器不支持这样的命令，必须使用第三方客户端来进行连接，例如putty、Xshell4等.</p>
<blockquote>
<p>putty为例：</p>
</blockquote>
<blockquote>
<p>主机地址: 127.0.0.1</p>
</blockquote>
<blockquote>
<p>端口: 2222</p>
</blockquote>
<blockquote>
<p>用户名: vagrant</p>
</blockquote>
<blockquote>
<p>密码: vagrant</p>
</blockquote>
<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><p>进入系统之后我们可以看一下系统的基础信息：</p>
<p>vagrant@lucid64:/vagrant$ df -h<br>Filesystem            Size  Used Avail Use% Mounted on<br>/dev/mapper/lucid64-root<br>                       78G  945M   73G   2% /<br>none                  179M  176K  179M   1% /dev<br>none                  184M     0  184M   0% /dev/shm<br>none                  184M   64K  184M   1% /var/run<br>none                  184M     0  184M   0% /var/lock<br>none                  184M     0  184M   0% /lib/init/rw<br>none                   78G  945M   73G   2% /var/lib/ureadahead/debugfs<br>/dev/sda1             228M   17M  199M   8% /boot<br>/vagrant              298G   76G  222G  26% /vagrant<br>/vagrant这个目录是自动映射的，被映射到/Users/astaxie/vagrant，这样就方便我们以后在开发机中进行开发，在虚拟机中进行运行效果测试了。</p>
<h2 id="Vagrantfile配置文件详解"><a href="#Vagrantfile配置文件详解" class="headerlink" title="Vagrantfile配置文件详解"></a>Vagrantfile配置文件详解</h2><p>在我们的开发目录下有一个文件Vagrantfile，里面包含有大量的配置信息，主要包括三个方面的配置，虚拟机的配置、SSH配置、Vagrant的一些基础配置。Vagrant是使用Ruby开发的，所以它的配置语法也是Ruby的，但是我们没有学过Ruby的人还是可以跟着它的注释知道怎么配置一些基本项的配置。</p>
<ol>
<li><p>box设置</p>
<p>config.vm.box = “base”<br>上面这配置展示了Vagrant要去启用那个box作为系统，也就是上面我们输入vagrant init Box名称时所指定的box，如果沒有输入box名称的話，那么默认就是base，VirtualBox提供了VBoxManage这个命令行工具，可以让我们设定VM，用modifyvm这个命令让我们可以设定VM的名称和内存大小等等，这里说的名称指的是在VirtualBox中显示的名称，我们也可以在Vagrantfile中进行设定，在Vagrantfile中加入如下这行就可以设定了：</p>
<p>config.vm.provider “virtualbox” do |v|<br>v.customize [“modifyvm”, :id, “–name”, “astaxie”, “–memory”, “512”]<br>end<br>这行设置的意思是调用VBoxManage的modifyvm的命令，设置VM的名称为astaxie，内存为512MB。你可以类似的通过定制其它VM属性来定制你自己的VM。</p>
</li>
<li><p>网络设置<br>Vagrant有两种方式来进行网络连接，一种是host-only(主机模式)，意思是主机和虚拟机之间的网络互访，而不是虚拟机访问internet的技术，也就是只有你一個人自High，其他人访问不到你的虚拟机。另一种是Bridge(桥接模式)，该模式下的VM就像是局域网中的一台独立的主机，也就是说需要VM到你的路由器要IP，这样的话局域网里面其他机器就可以访问它了，一般我们设置虚拟机都是自high为主，所以我们的设置一般如下：</p>
<p>config.vm.network :private_network, ip: “11.11.11.11”<br>这里我们虚拟机设置为hostonly，并且指定了一个IP，IP的话建议最好不要用192.168..这个网段，因为很有可能和你局域网里面的其它机器IP冲突，所以最好使用类似11.11..这样的IP地址。</p>
</li>
<li><p>hostname设置<br>hostname的设置非常简单，Vagrantfile中加入下面这行就可以了：</p>
<p>config.vm.hostname = “go-app”<br>设置hostname非常重要，因为当我们有很多台虚拟服务器的时候，都是依靠hostname來做识别的，例如Puppet或是Chef，都是通过hostname來做识别的，既然设置那么简单，所以我们就別偷懒，设置一个。</p>
</li>
<li><p>同步目录<br>我们上面介绍过/vagrant目录默认就是当前的开发目录，这是在虚拟机开启的时候默认挂载同步的。我们还可以通过配置来设置额外的同步目录：<br>config.vm.synced_folder  “/Users/astaxie/data”, “/vagrant_data”<br>上面这个设定，第一个参数是主机的目录，第二个参数是虚拟机挂载的目录</p>
</li>
<li><p>端口转发<br>config.vm.network :forwarded_port, guest: 80, host: 8080<br>上面这句配置可厉害了，这一行的意思是把对host机器上8080端口的访问请求forward到虚拟机的80端口的服务上，例如你在你的虚拟机上使用nginx跑了一个Go应用，那么你在host机器上的浏览器中打开<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 时，Vagrant就会把这个请求转发到VM里面跑在80端口的nginx服务上，因此我们可以通过这个设置来帮助我们去设定host和VM之间，或是VM和VM之间的信息交互。<br>修改完Vagrantfile的配置后，记得要用vagrant reload命令来重启VM之后才能使用VM更新后的配置</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Vagrant</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Vagrant介绍</title>
    <url>/2017/06/26/Vagrant%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="虚拟开发环境"><a href="#虚拟开发环境" class="headerlink" title="虚拟开发环境"></a>虚拟开发环境</h2><p>平常我们经常会遇到这样的问题：在开发机上面开发完毕程序，放到正式环境之后会出现各种奇怪的问题：描述符少了、nginx配置不正确、MySQL编码不对、php缺少模块、glibc版本太低等。</p>
<p>所以我们就需要虚拟开发环境，我们虚拟和正式环境一样的虚拟开发环境，而随着个人开发机硬件的升级，我们可以很容易的在本机跑虚拟机，例如VMware、VirtualBox等。因此使用虚拟化开发环境，在本机可以运行自己喜欢的OS（Windows、Ubuntu、Mac等），开发的程序运行在虚拟机中，这样迁移到生产环境可以避免环境不一致导致的莫名错误。</p>
<a id="more"></a>
<p>虚拟开发环境特别适合团队中开发环境、测试环境、正式环境不同的场合，这样就可以使得整个团队保持一致的环境，我写这一章的初衷就是为了让大家和我的开发环境保持一致，让读者和我们整个大团队保持一致的开发环境。</p>
<h2 id="Vagrant"><a href="#Vagrant" class="headerlink" title="Vagrant"></a>Vagrant</h2><blockquote>
<p>Vagrant是一款用于构建及配置虚拟开发环境的软件，基于Ruby,主要以命令行的方式运行。</p>
</blockquote>
<blockquote>
<p>主要使用Oracle的开源VirtualBox虚拟化系统，与Chef，Salt，Puppet等环境配置管理软件搭配使用， 可以实行快速虚拟开发环境的构建。</p>
</blockquote>
<blockquote>
<p>早期以VirtualBox为对象，1.1以后的版本中开始对应VMware等虚拟化软件，包括Amazon EC2之类服务器环境的对应。</p>
</blockquote>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/Vagrant" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Vagrant</a></p>
</blockquote>
<p>官方文档：<a href="https://www.vagrantup.com/intro/getting-started/index.html" target="_blank" rel="noopener">https://www.vagrantup.com/intro/getting-started/index.html</a></p>
<p>Vagrant就是为了方便的实现虚拟化环境而设计的，使用Ruby开发，基于VirtualBox等虚拟机管理软件的接口，提供了一个可配置、轻量级的便携式虚拟开发环境。使用Vagrant可以很方便的就建立起来一个虚拟环境，而且可以模拟多台虚拟机，这样我们平时还可以在开发机模拟分布式系统。</p>
<p>Vagrant还会创建一些共享文件夹，用来给你在主机和虚拟机之间共享代码用。这样就使得我们可以在主机上写程序，然后在虚拟机中运行。如此一来团队之间就可以共享相同的开发环境，就不会再出现类似“只有你的环境才会出现的bug”这样的事情。</p>
<p>团队新员工加入，常常会遇到花一天甚至更多时间来从头搭建完整的开发环境，而有了Vagrant，只需要直接将已经打包好的package（里面包括开发工具，代码库，配置好的服务器等）拿过来就可以工作了，这对于提升工作效率非常有帮助。</p>
<p>Vagrant不仅可以用来作为个人的虚拟开发环境工具，而且特别适合团队使用，它使得我们虚拟化环境变得如此的简单，只要一个简单的命令就可以开启虚拟之路。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Vagrant</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>时间管理</title>
    <url>/2017/05/24/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="什么是时间管理"><a href="#什么是时间管理" class="headerlink" title="什么是时间管理"></a>什么是时间管理</h2><blockquote>
<p><strong>时间管理</strong>（Time Management）就是用技巧、技术和工具帮助人们完成工作，实现目标。时间管理并不是要把所有事情做完，而是更有效的运用时间。时间管理的目的除了要决定你该做些什么事情之外，另一个很重要的目的也是决定什么事情不应该做；时间管理不是完全的掌控，而是降低变动性。时间管理最重要的功能是透过事先的规划，做为一种提醒与指引。</p>
<p><a href="https://zh.wikipedia.org/zh-cn/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86</a></p>
</blockquote>
<p>时间的管理最重要的在于能够集中自己的大的整块时间进行某些问题的处理。</p>
<a id="more"></a>
<h2 id="时间流逝"><a href="#时间流逝" class="headerlink" title="时间流逝"></a>时间流逝</h2><p>以下是你必须要知道的真相</p>
<ol>
<li>平均每30分钟会受到一次打扰</li>
<li>平均每次打扰用时大约是五分钟，总共大约两小时。</li>
<li>如果你让自己一天做一件事情，你会花一整天去做；</li>
<li>如果你让自己一天做二十件事情，则会完成七至八件甚至更多。</li>
<li>一年之中，你真正在做有价值的事情的时间不会超过九十天。</li>
<li>三年内，如果你好好的规划一下你的人生和时间，你能够取得是之前的三到五倍。</li>
</ol>
<p>浪费时间的原因有主观和客观两大方面。这里，我们来分析一下浪费时间的主观原因，因为，这是一切的根源。</p>
<h2 id="主观原因"><a href="#主观原因" class="headerlink" title="主观原因"></a>主观原因</h2><h3 id="观念不对"><a href="#观念不对" class="headerlink" title="观念不对"></a>观念不对</h3><ul>
<li><p>进取心不足</p>
</li>
<li><p>缺乏时间意识</p>
</li>
<li>态度消极悲观</li>
</ul>
<h3 id="目标不明"><a href="#目标不明" class="headerlink" title="目标不明"></a>目标不明</h3><ul>
<li>缺乏计划</li>
<li>抓不住重点</li>
</ul>
<h3 id="技巧不够"><a href="#技巧不够" class="headerlink" title="技巧不够"></a>技巧不够</h3><ul>
<li>缺乏优先顺序</li>
<li>做事有头无尾。</li>
<li>没有条理，不简洁，简单的事情复杂化。</li>
<li>事必躬亲，不懂得授权。</li>
<li>不会拒绝别人的请求。</li>
</ul>
<h3 id="习惯不好"><a href="#习惯不好" class="headerlink" title="习惯不好"></a>习惯不好</h3><ul>
<li>5S整顿不足<br>（ps: 5S：整理（SEIRI）、整顿（SEITON）、清扫（SEISO）、清洁（SEIKETSU）、素养（SHITSUKE），又被称为“五常法则”或“五常法”,适用于制造业、服务业<img src="http://wiki.mbalib.com/w/images/0/0d/5S%E7%8E%B0%E5%9C%BA%E7%AE%A1%E7%90%86%E6%B3%95%E5%9B%BE%E7%A4%BA.gif" alt="img"><br><a href="http://wiki.mbalib.com/wiki/5S%E7%8E%B0%E5%9C%BA%E7%AE%A1%E7%90%86%E6%B3%95#.E4.BB.80.E4.B9.88.E6.98.AF5S.E7.8E.B0.E5.9C.BA.E7.AE.A1.E7.90.86.E6.B3.95" target="_blank" rel="noopener">http://wiki.mbalib.com/wiki/5S%E7%8E%B0%E5%9C%BA%E7%AE%A1%E7%90%86%E6%B3%95#.E4.BB.80.E4.B9.88.E6.98.AF5S.E7.8E.B0.E5.9C.BA.E7.AE.A1.E7.90.86.E6.B3.95</a>)</li>
<li>工作作风拖拉。</li>
</ul>
<h3 id="组织不当"><a href="#组织不当" class="headerlink" title="组织不当"></a>组织不当</h3><ul>
<li>工作流程不畅</li>
<li>标准不明确需返工</li>
<li>相互配合衔接不当</li>
</ul>
<p>摘自 <a href="http://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">http://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95</a></p>
<p>针对个人的情况有重点的解决主观原因。（感觉自己每个大项都占了。。）</p>
<h2 id="道"><a href="#道" class="headerlink" title="道"></a>道</h2><p>1、取消法：所有的事情，首先分析必要性，能取消的就取消，能回避的就回避（不认同，应该是适当的回避），集中做对你目标最有价值的事情。比如看电视、闲聊、发呆(包括发愁、批评社会)、漫无目的上网、过于广泛的兴趣、过于广泛的人际关系统统取消，只做最有价值的事情，比如学习、休息、工作。<br>2、以人替时法：能让别人代劳的事情，自己就不要做，学会运用别人的时间。因为每个人的精力都是有限的，所谓有所谓有所不为，把自己的精力和时间用在最能体现自己价值的方面。<br>3、改善效率法：学习最新的知识，掌握最新的工具，改进效率，本来花1个小时的工作，想办法变成0.5小时完成，这样可以节省更多时间用于学习。<br>4、以钱购时法：交通方面，能坐飞机，就不要坐火车;如果能打车，就不要等公交;乘坐最快的、最有助于休息、学习的交通工具;学习方面，采用最有效率的学习方法，能面授听课就不看视频;能看视频的，就不买图书;工作方面，用最好的工作设备比如用最好的电脑、用最快的传真机，说服你的老板不要在设备上斤斤计较，要分析好的设备所节省的时间、所带来的价值。时光一去不复返，千金散尽还复来<br>5、见缝插针法：在等人、在乘车、地铁时利用间隙时间听录音、思考。例如对于很多在北京工作的人，每天在路上大概需要2小时，如果每天的2小时利用来听录音，每年可以有720小时在学习，如果坚持10年，就是7200小时，这些时间不管是听管理知识、还是学英语，都可以取得很大的收益。</p>
<p>摘自<a href="http://www.rs66.com/a/2/88/zuiyouxiaode5geshijianguanlifangfa_105397.html" target="_blank" rel="noopener">http://www.rs66.com/a/2/88/zuiyouxiaode5geshijianguanlifangfa_105397.html</a></p>
<h2 id="术"><a href="#术" class="headerlink" title="术"></a>术</h2><p>1.</p>
<blockquote>
<p>“进程切换非常昂贵，避免多任务，保持单进程。”</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016051302.png" alt="img"></p>
<p>不要同时做多件事，结果可能都没做好，还拖长了工作时间。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016051303.png" alt="img"></p>
<p>上图是多任务状态和单进程状态的对比，可以看到，多任务状态会花费更多的时间。</p>
<p>2.</p>
<blockquote>
<p>“研究表明，集中注意力、高效工作，每天最多4小时。”</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016051304.png" alt="img"></p>
<p>一个人能够集中注意力的时间，是有限的。一般来说，高效工作只能持续四个小时，其余时间就都是低效工作了。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016051305.png" alt="img"></p>
<p>上图左侧是大多数人每天的时间分配，如果你能保证4个小时都高效工作，那么完全可以变成右侧的时间分配。</p>
<p>3.</p>
<blockquote>
<p>“划分任务的优先级，不要把’急切’当作’重要’。”</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016051306.png" alt="img"></p>
<p>你的时间有限，不可能做所有事。最重要的事，应该首先做。（推荐阅读<a href="http://www.ruanyifeng.com/blog/2009/01/stuff_that_matters.html" target="_blank" rel="noopener">《什么是重要的事情？》</a>）</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016051307.png" alt="img"></p>
<p>一个有用的技巧是，将所有任务按照”重要性”和”紧急性”两个维度，分成四个象限。第一象限优先级最高，第四象限最低。</p>
<p>4.</p>
<blockquote>
<p>“起床后，不要查看邮件和微信。”</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016051308.png" alt="img"></p>
<p>早晨精力最充沛，消耗在邮件和微信就太可惜了，应该用来做更重要的事。而且，邮件代表对别人优先级高，不等于对你优先级高。你的时间到底属于谁？你自己，还是某个给你写信的人？（推荐阅读<a href="http://www.ruanyifeng.com/blog/2011/01/never_check_email_first_thing_in_the_morning.html" target="_blank" rel="noopener">《为什么起床后不能收邮件？》</a>）</p>
<p>5.</p>
<blockquote>
<p>“避免开会，因为人类已知的最浪费时间的事情，就是开会。”</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016051309.png" alt="img"></p>
<p>越大的公司，越无法避免开会。但至少不要参加与你无关的会。站着开会，也许是一个缩短会议时间的好办法。</p>
<p>6.</p>
<blockquote>
<p>“早晨4点起床，到了中午，你就完成了一天的任务。”</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016051310.png" alt="img"></p>
<p>早晨4点起床开始工作，你会发现每天的时间多出了好多。有个日本人写了一本书《四点起床》，就是讲这个观点。</p>
<p>7.</p>
<blockquote>
<p>“你没空时不会做的事情，有空了也不会做。”</p>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016051311.png" alt="img"></p>
<p>世上并没有拖延症，只是不想做而已。如果可能，应该尽早放弃你没有意愿去做的那些事。而那些没有时间也会去做的事，才是你应该全力以赴的人生方向。</p>
<p>摘自 <a href="http://www.ruanyifeng.com/blog/2016/05/time-management.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/05/time-management.html</a></p>
<p>\8. 目标明确,明白为什么做这件事。目标要具体、具有可实现性</p>
<p>9.遵循你的生物钟。你办事效率最佳的时间是什么时候？将优先办的事情放在最佳时间里。</p>
<p>10.做好的事情要比把事情做好更重要。做好的事情，是有效果；把事情做好仅仅是有效率。首先考虑效果，然后才考虑效率.</p>
<p>11.学会说”不”。一旦确定了哪些事情是重要的，对那些不重要的事情就应当说”不”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.按照 “重要、紧急”的优先级列好工作内容。</p>
<p>2.将关键工作安排在不被打扰的时间。</p>
<p>3.预估被打扰的时间，这段时间做非关键工作。</p>
<p>4.不重要的事情说不，或分配他人。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/zh-cn/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86</a></p>
<p><a href="http://wiki.mbalib.com/wiki/5S%E7%8E%B0%E5%9C%BA%E7%AE%A1%E7%90%86%E6%B3%95#.E4.BB.80.E4.B9.88.E6.98.AF5S.E7.8E.B0.E5.9C.BA.E7.AE.A1.E7.90.86.E6.B3.95" target="_blank" rel="noopener">http://wiki.mbalib.com/wiki/5S%E7%8E%B0%E5%9C%BA%E7%AE%A1%E7%90%86%E6%B3%95#.E4.BB.80.E4.B9.88.E6.98.AF5S.E7.8E.B0.E5.9C.BA.E7.AE.A1.E7.90.86.E6.B3.95</a></p>
<p><a href="http://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">http://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95</a></p>
<p><a href="http://www.rs66.com/a/2/88/zuiyouxiaode5geshijianguanlifangfa_105397.html" target="_blank" rel="noopener">http://www.rs66.com/a/2/88/zuiyouxiaode5geshijianguanlifangfa_105397.html</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2016/05/time-management.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/05/time-management.html</a></p>
]]></content>
      <categories>
        <category>通用能力</category>
        <category>时间管理</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka原理</title>
    <url>/2017/05/06/Kafka%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>摘自一篇博客，找不到了 </p>
<h2 id="Kafka技术概览"><a href="#Kafka技术概览" class="headerlink" title="Kafka技术概览"></a>Kafka技术概览</h2><h3 id="Kafka的特性"><a href="#Kafka的特性" class="headerlink" title="Kafka的特性"></a>Kafka的特性</h3><p>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</p>
<p>可扩展性：kafka集群支持热扩展</p>
<p>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</p>
<p>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</p>
<p>高并发：支持数千个客户端同时读写</p>
<h3 id="Kafka一些重要设计思想"><a href="#Kafka一些重要设计思想" class="headerlink" title="Kafka一些重要设计思想"></a>Kafka一些重要设计思想</h3><p>下面介绍先大体介绍一下Kafka的主要设计思想，可以让相关人员在短时间内了解到kafka相关特性，如果想深入研究，后面会对其中每一个特性都做详细介绍。</p>
<a id="more"></a>
<h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><p>各个consumer可以组成一个组，每个消息只能被组中的一个consumer消费，如果一个消息可以被多个consumer消费的话，那么这些consumer必须在不同的组。</p>
<h4 id="消息状态"><a href="#消息状态" class="headerlink" title="消息状态"></a>消息状态</h4><p>在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。</p>
<h4 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h4><p>Kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。</p>
<h4 id="消息有效期"><a href="#消息有效期" class="headerlink" title="消息有效期"></a>消息有效期</h4><p>Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其中很多细节是可配置的。</p>
<h4 id="批量发送"><a href="#批量发送" class="headerlink" title="批量发送"></a>批量发送</h4><p>Kafka支持以消息集合为单位进行批量发送，以提高push效率。</p>
<h4 id="push-and-pull"><a href="#push-and-pull" class="headerlink" title="push-and-pull"></a>push-and-pull</h4><p>Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。</p>
<h4 id="负载均衡方面"><a href="#负载均衡方面" class="headerlink" title="负载均衡方面"></a>负载均衡方面</h4><p>Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。</p>
<h4 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h4><p>Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。</p>
<h4 id="分区机制partition"><a href="#分区机制partition" class="headerlink" title="分区机制partition"></a>分区机制partition</h4><p>Kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。</p>
<h4 id="离线数据装载"><a href="#离线数据装载" class="headerlink" title="离线数据装载"></a>离线数据装载</h4><p>Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。</p>
<h4 id="插件支持"><a href="#插件支持" class="headerlink" title="插件支持"></a>插件支持</h4><p>现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。</p>
<h3 id="kafka-应用场景"><a href="#kafka-应用场景" class="headerlink" title="kafka 应用场景"></a>kafka 应用场景</h3><h4 id="日志收集"><a href="#日志收集" class="headerlink" title="日志收集"></a>日志收集</h4><p>一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</p>
<h4 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h4><p>解耦和生产者和消费者、缓存消息等。</p>
<h4 id="用户活动跟踪"><a href="#用户活动跟踪" class="headerlink" title="用户活动跟踪"></a>用户活动跟踪</h4><p>Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</p>
<h4 id="运营指标"><a href="#运营指标" class="headerlink" title="运营指标"></a>运营指标</h4><p>Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</p>
<h4 id="流式处理"><a href="#流式处理" class="headerlink" title="流式处理"></a>流式处理</h4><p>比如spark streaming和storm</p>
<h4 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h4><h3 id="Kafka架构组件"><a href="#Kafka架构组件" class="headerlink" title="Kafka架构组件"></a>Kafka架构组件</h3><p>Kafka中发布订阅的对象是topic。我们可以为每类数据创建一个topic，把向topic发布消息的客户端称作producer，从topic订阅消息的客户端称作consumer。Producers和consumers可以同时从多个topic读写数据。一个kafka集群由一个或多个broker服务器组成，它负责持久化和备份具体的kafka消息。</p>
<ul>
<li>topic：消息存放的目录即主题</li>
<li>Producer：生产消息到topic的一方</li>
<li>Consumer：订阅topic消费消息的一方</li>
<li>Broker：Kafka的服务实例就是一个broker</li>
</ul>
<p><img src="/img/15255327943144.jpg" alt></p>
<h3 id="Kafka-Topic-amp-Partition"><a href="#Kafka-Topic-amp-Partition" class="headerlink" title="Kafka Topic &amp; Partition"></a>Kafka Topic &amp; Partition</h3><p>消息发送时都被发送到一个topic，其本质就是一个目录，而topic由是由一些Partition Logs(分区日志)组成,其组织结构如下图所示：<br><img src="/img/15255328151290.jpg" alt></p>
<p>我们可以看到，每个Partition中的消息都是有序的，生产的消息被不断追加到Partition log上，其中的每一个消息都被赋予了一个唯一的offset值。<br>Kafka集群会保存所有的消息，不管消息有没有被消费；我们可以设定消息的过期时间，只有过期的数据才会被自动清除以释放磁盘空间。比如我们设置消息过期时间为2天，那么这2天内的所有消息都会被保存到集群中，数据只有超过了两天才会被清除。<br>Kafka需要维持的元数据只有一个–消费消息在Partition中的offset值，Consumer每消费一个消息，offset就会加1。其实消息的状态完全是由Consumer控制的，Consumer可以跟踪和重设这个offset值，这样的话Consumer就可以读取任意位置的消息。<br>把消息日志以Partition的形式存放有多重考虑，第一，方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了；第二就是可以提高并发，因为可以以Partition为单位读写了。</p>
<h2 id="Kafka-核心组件"><a href="#Kafka-核心组件" class="headerlink" title="Kafka 核心组件"></a>Kafka 核心组件</h2><h3 id="Replications、Partitions-和Leaders"><a href="#Replications、Partitions-和Leaders" class="headerlink" title="Replications、Partitions 和Leaders"></a>Replications、Partitions 和Leaders</h3><p>通过上面介绍的我们可以知道，kafka中的数据是持久化的并且能够容错的。Kafka允许用户为每个topic设置副本数量，副本数量决定了有几个broker来存放写入的数据。如果你的副本数量设置为3，那么一份数据就会被存放在3台不同的机器上，那么就允许有2个机器失败。一般推荐副本数量至少为2，这样就可以保证增减、重启机器时不会影响到数据消费。如果对数据持久化有更高的要求，可以把副本数量设置为3或者更多。<br>Kafka中的topic是以partition的形式存放的，每一个topic都可以设置它的partition数量，Partition的数量决定了组成topic的log的数量。Producer在生产数据时，会按照一定规则（这个规则是可以自定义的）把消息发布到topic的各个partition中。上面将的副本都是以partition为单位的，不过只有一个partition的副本会被选举成leader作为读写用。<br>关于如何设置partition值需要考虑的因素。一个partition只能被一个消费者消费（一个消费者可以同时消费多个partition），因此，如果设置的partition的数量小于consumer的数量，就会有消费者消费不到数据。所以，推荐partition的数量一定要大于同时运行的consumer的数量。另外一方面，建议partition的数量大于集群broker的数量，这样leader partition就可以均匀的分布在各个broker中，最终使得集群负载均衡。在Cloudera,每个topic都有上百个partition。需要注意的是，kafka需要为每个partition分配一些内存来缓存消息数据，如果partition数量越大，就要为kafka分配更大的heap space。</p>
<h3 id="Producers"><a href="#Producers" class="headerlink" title="Producers"></a>Producers</h3><p>Producers直接发送消息到broker上的leader partition，不需要经过任何中介一系列的路由转发。为了实现这个特性，kafka集群中的每个broker都可以响应producer的请求，并返回topic的一些元信息，这些元信息包括哪些机器是存活的，topic的leader partition都在哪，现阶段哪些leader partition是可以直接被访问的。<br>Producer客户端自己控制着消息被推送到哪些partition。实现的方式可以是随机分配、实现一类随机负载均衡算法，或者指定一些分区算法。Kafka提供了接口供用户实现自定义的分区，用户可以为每个消息指定一个partitionKey，通过这个key来实现一些hash分区算法。比如，把userid作为partitionkey的话，相同userid的消息将会被推送到同一个分区。<br>以Batch的方式推送数据可以极大的提高处理效率，kafka Producer 可以将消息在内存中累计到一定数量后作为一个batch发送请求。Batch的数量大小可以通过Producer的参数控制，参数值可以设置为累计的消息的数量（如500条）、累计的时间间隔（如100ms）或者累计的数据大小(64KB)。通过增加batch的大小，可以减少网络请求和磁盘IO的次数，当然具体参数设置需要在效率和时效性方面做一个权衡。<br>Producers可以异步的并行的向kafka发送消息，但是通常producer在发送完消息之后会得到一个future响应，返回的是offset值或者发送过程中遇到的错误。这其中有个非常重要的参数“acks”,这个参数决定了producer要求leader partition 收到确认的副本个数，如果acks设置数量为0，表示producer不会等待broker的响应，所以，producer无法知道消息是否发送成功，这样有可能会导致数据丢失，但同时，acks值为0会得到最大的系统吞吐量。<br>若acks设置为1，表示producer会在leader partition收到消息时得到broker的一个确认，这样会有更好的可靠性，因为客户端会等待直到broker确认收到消息。若设置为-1，producer会在所有备份的partition收到消息时得到broker的确认，这个设置可以得到最高的可靠性保证。<br>Kafka 消息有一个定长的header和变长的字节数组组成。因为kafka消息支持字节数组，也就使得kafka可以支持任何用户自定义的序列号格式或者其它已有的格式如Apache Avro、protobuf等。Kafka没有限定单个消息的大小，但我们推荐消息大小不要超过1MB,通常一般消息大小都在1~10kB之前。</p>
<h3 id="Consumers"><a href="#Consumers" class="headerlink" title="Consumers"></a>Consumers</h3><p>Kafka提供了两套consumer api，分为high-level api和sample-api。Sample-api 是一个底层的API，它维持了一个和单一broker的连接，并且这个API是完全无状态的，每次请求都需要指定offset值，因此，这套API也是最灵活的。<br>在kafka中，当前读到消息的offset值是由consumer来维护的，因此，consumer可以自己决定如何读取kafka中的数据。比如，consumer可以通过重设offset值来重新消费已消费过的数据。不管有没有被消费，kafka会保存数据一段时间，这个时间周期是可配置的，只有到了过期时间，kafka才会删除这些数据。<br>High-level API封装了对集群中一系列broker的访问，可以透明的消费一个topic。它自己维持了已消费消息的状态，即每次消费的都是下一个消息。<br>High-level API还支持以组的形式消费topic，如果consumers有同一个组名，那么kafka就相当于一个队列消息服务，而各个consumer均衡的消费相应partition中的数据。若consumers有不同的组名，那么此时kafka就相当与一个广播服务，会把topic中的所有消息广播到每个consumer。<br><img src="/img/15255329976928.jpg" alt></p>
<h2 id="Kafka核心特性"><a href="#Kafka核心特性" class="headerlink" title="Kafka核心特性"></a>Kafka核心特性</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>我们上面已经知道了Kafka支持以集合（batch）为单位发送消息，在此基础上，Kafka还支持对消息集合进行压缩，Producer端可以通过GZIP或Snappy格式对消息集合进行压缩。Producer端进行压缩之后，在Consumer端需进行解压。压缩的好处就是减少传输的数据量，减轻对网络传输的压力，在对大数据处理上，瓶颈往往体现在网络上而不是CPU（压缩和解压会耗掉部分CPU资源）。<br>那么如何区分消息是压缩的还是未压缩的呢，Kafka在消息头部添加了一个描述压缩属性字节，这个字节的后两位表示消息的压缩采用的编码，如果后两位为0，则表示消息未被压缩。</p>
<h3 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h3><p>在消息系统中，保证消息在生产和消费过程中的可靠性是十分重要的，在实际消息传递过程中，可能会出现如下三中情况：</p>
<ul>
<li>一个消息发送失败</li>
<li>一个消息被发送多次</li>
<li>最理想的情况：exactly-once ,一个消息发送成功且仅发送了一次</li>
</ul>
<p>有许多系统声称它们实现了exactly-once，但是它们其实忽略了生产者或消费者在生产和消费过程中有可能失败的情况。比如虽然一个Producer成功发送一个消息，但是消息在发送途中丢失，或者成功发送到broker，也被consumer成功取走，但是这个consumer在处理取过来的消息时失败了。<br>从Producer端看：Kafka是这么处理的，当一个消息被发送后，Producer会等待broker成功接收到消息的反馈（可通过参数控制等待时间），如果消息在途中丢失或是其中一个broker挂掉，Producer会重新发送（我们知道Kafka有备份机制，可以通过参数控制是否等待所有备份节点都收到消息）。<br>从Consumer端看：前面讲到过partition，broker端记录了partition中的一个offset值，这个值指向Consumer下一个即将消费message。当Consumer收到了消息，但却在处理过程中挂掉，此时Consumer可以通过这个offset值重新找到上一个消息再进行处理。Consumer还有权限控制这个offset值，对持久化到broker端的消息做任意处理。</p>
<h3 id="备份机制"><a href="#备份机制" class="headerlink" title="备份机制"></a>备份机制</h3><p>备份机制是Kafka0.8版本的新特性，备份机制的出现大大提高了Kafka集群的可靠性、稳定性。有了备份机制后，Kafka允许集群中的节点挂掉后而不影响整个集群工作。一个备份数量为n的集群允许n-1个节点失败。在所有备份节点中，有一个节点作为lead节点，这个节点保存了其它备份节点列表，并维持各个备份间的状体同步。下面这幅图解释了Kafka的备份机制:<br><img src="/img/15255330211208.jpg" alt></p>
<h3 id="Kafka高效性相关设计"><a href="#Kafka高效性相关设计" class="headerlink" title="Kafka高效性相关设计"></a>Kafka高效性相关设计</h3><h4 id="消息的持久化"><a href="#消息的持久化" class="headerlink" title="消息的持久化"></a>消息的持久化</h4><p>Kafka高度依赖文件系统来存储和缓存消息，一般的人认为磁盘是缓慢的，这导致人们对持久化结构具有竞争性持怀疑态度。其实，磁盘远比你想象的要快或者慢，这决定于我们如何使用磁盘。<br>一个和磁盘性能有关的关键事实是：磁盘驱动器的吞吐量跟寻到延迟是相背离的，也就是所，线性写的速度远远大于随机写。比如：在一个6 7200rpm SATA RAID-5 的磁盘阵列上线性写的速度大概是600M/秒，但是随机写的速度只有100K/秒，两者相差将近6000倍。线性读写在大多数应用场景下是可以预测的，因此，操作系统利用read-ahead和write-behind技术来从大的数据块中预取数据，或者将多个逻辑上的写操作组合成一个大写物理写操作中。更多的讨论可以在<a href="http://queue.acm.org/detail.cfm?id=1563874" target="_blank" rel="noopener">ACMQueueArtical</a>中找到，他们发现，对磁盘的线性读在有些情况下可以比内存的随机访问要快一些。<br>为了补偿这个性能上的分歧，现代操作系统都会把空闲的内存用作磁盘缓存，尽管在内存回收的时候会有一点性能上的代价。所有的磁盘读写操作会在这个统一的缓存上进行。<br>此外，如果我们是在JVM的基础上构建的，熟悉Java内存应用管理的人应该清楚以下两件事情：</p>
<ol>
<li>一个对象的内存消耗是非常高的，经常是所存数据的两倍或者更多。</li>
<li>随着堆内数据的增多，Java的垃圾回收会变得非常昂贵。</li>
</ol>
<p>基于这些事实，利用文件系统并且依靠页缓存比维护一个内存缓存或者其他结构要好——我们至少要使得可用的缓存加倍，通过自动访问可用内存，并且通过存储更紧凑的字节结构而不是一个对象，这将有可能再次加倍。这么做的结果就是在一台32GB的机器上，如果不考虑GC惩罚，将最多有28-30GB的缓存。此外，这些缓存将会一直存在即使服务重启，然而进程内缓存需要在内存中重构（10GB缓存需要花费10分钟）或者它需要一个完全冷缓存启动（非常差的初始化性能）。它同时也简化了代码，因为现在所有的维护缓存和文件系统之间内聚的逻辑都在操作系统内部了，这使得这样做比one-off in-process attempts更加高效与准确。如果你的磁盘应用更加倾向于顺序读取，那么read-ahead在每次磁盘读取中实际上获取到这人缓存中的有用数据。<br>以上这些建议了一个简单的设计：不同于维护尽可能多的内存缓存并且在需要的时候刷新到文件系统中，我们换一种思路。所有的数据不需要调用刷新程序，而是立刻将它写到一个持久化的日志中。事实上，这仅仅意味着，数据将被传输到内核页缓存中并稍后被刷新。我们可以增加一个配置项以让系统的用户来控制数据在什么时候被刷新到物理硬盘上。</p>
<h4 id="常数时间性能保证"><a href="#常数时间性能保证" class="headerlink" title="常数时间性能保证"></a>常数时间性能保证</h4><p>消息系统中持久化数据结构的设计通常是维护着一个和消费队列有关的B树或者其它能够随机存取结构的元数据信息。B树是一个很好的结构，可以用在事务型与非事务型的语义中。但是它需要一个很高的花费，尽管B树的操作需要O(logN)。通常情况下，这被认为与常数时间等价，但这对磁盘操作来说是不对的。磁盘寻道一次需要10ms，并且一次只能寻一个，因此并行化是受限的。<br>直觉上来讲，一个持久化的队列可以构建在对一个文件的读和追加上，就像一般情况下的日志解决方案。尽管和B树相比，这种结构不能支持丰富的语义，但是它有一个优点，所有的操作都是常数时间，并且读写之间不会相互阻塞。这种设计具有极大的性能优势：最终系统性能和数据大小完全无关，服务器可以充分利用廉价的硬盘来提供高效的消息服务。<br>事实上还有一点，磁盘空间的无限增大而不影响性能这点，意味着我们可以提供一般消息系统无法提供的特性。比如说，消息被消费后不是立马被删除，我们可以将这些消息保留一段相对比较长的时间（比如一个星期）。</p>
<h4 id="进一步提高效率"><a href="#进一步提高效率" class="headerlink" title="进一步提高效率"></a>进一步提高效率</h4><p>我们已经为效率做了非常多的努力。但是有一种非常主要的应用场景是：处理Web活动数据，它的特点是数据量非常大，每一次的网页浏览都会产生大量的写操作。更进一步，我们假设每一个被发布的消息都会被至少一个consumer消费，因此我们更要怒路让消费变得更廉价。<br>通过上面的介绍，我们已经解决了磁盘方面的效率问题，除此之外，在此类系统中还有两类比较低效的场景：</p>
<ul>
<li>太多小的I/O操作</li>
<li>过多的字节拷贝</li>
</ul>
<p>为了减少大量小I/O操作的问题，kafka的协议是围绕消息集合构建的。Producer一次网络请求可以发送一个消息集合，而不是每一次只发一条消息。在server端是以消息块的形式追加消息到log中的，consumer在查询的时候也是一次查询大量的线性数据块。消息集合即MessageSet，实现本身是一个非常简单的API，它将一个字节数组或者文件进行打包。所以对消息的处理，这里没有分开的序列化和反序列化的上步骤，消息的字段可以按需反序列化（如果没有需要，可以不用反序列化）。<br>另一个影响效率的问题就是字节拷贝。为了解决字节拷贝的问题，kafka设计了一种“标准字节消息”，Producer、Broker、Consumer共享这一种消息格式。Kakfa的message log在broker端就是一些目录文件，这些日志文件都是MessageSet按照这种“标准字节消息”格式写入到磁盘的。<br>维持这种通用的格式对这些操作的优化尤为重要：持久化log 块的网络传输。流行的unix操作系统提供了一种非常高效的途径来实现页面缓存和socket之间的数据传递。在Linux操作系统中，这种方式被称作：sendfile system call（Java提供了访问这个系统调用的方法：FileChannel.transferTo api）。</p>
<p>为了理解sendfile的影响，需要理解一般的将数据从文件传到socket的路径：</p>
<ol>
<li>操作系统将数据从磁盘读到内核空间的页缓存中</li>
<li>应用将数据从内核空间读到用户空间的缓存中</li>
<li>应用将数据写回内核空间的socket缓存中</li>
<li>操作系统将数据从socket缓存写到网卡缓存中，以便将数据经网络发出</li>
</ol>
<p>这种操作方式明显是非常低效的，这里有四次拷贝，两次系统调用。如果使用sendfile，就可以避免两次拷贝：操作系统将数据直接从页缓存发送到网络上。所以在这个优化的路径中，只有最后一步将数据拷贝到网卡缓存中是需要的。<br>我们期望一个主题上有多个消费者是一种常见的应用场景。利用上述的zero-copy，数据只被拷贝到页缓存一次，然后就可以在每次消费时被重得利用，而不需要将数据存在内存中，然后在每次读的时候拷贝到内核空间中。这使得消息消费速度可以达到网络连接的速度。这样以来，通过页面缓存和sendfile的结合使用，整个kafka集群几乎都已以缓存的方式提供服务，而且即使下游的consumer很多，也不会对整个集群服务造成压力。<br>关于sendfile和zero-copy，请参考：<a href="https://www.ibm.com/developerworks/linux/library/j-zerocopy/" target="_blank" rel="noopener">zero-copy</a></p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol>
<li><a href="https://blog.csdn.net/lizhitao/article/details/39499283" target="_blank" rel="noopener">https://blog.csdn.net/lizhitao/article/details/39499283</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>SimHash</title>
    <url>/2017/05/06/SimHash/</url>
    <content><![CDATA[<p>本篇主要是对网上资源的整理，缺乏原创。</p>
<h2 id="什么是SimHash"><a href="#什么是SimHash" class="headerlink" title="什么是SimHash"></a>什么是SimHash</h2><p>SimHash是一种局部敏感hash(即Locality Sensitive Hashing，感兴趣可以自行学习下)，是google用来处理海量文本去重的算法。</p>
<h2 id="与普通Hash区别"><a href="#与普通Hash区别" class="headerlink" title="与普通Hash区别"></a>与普通Hash区别</h2><p>传统的加密式hash，比如md5，其设计的目的是为了让整个分布尽可能地均匀，输入内容哪怕只有轻微变化，hash就会发生很大地变化。<br>我们理想当中的哈希函数，需要对几乎相同的输入内容，产生相同或者相近的hashcode，换句话说，hashcode的相似程度要能直接反映输入内容的相似程度。很明显，前面所说的md5等传统hash无法满足我们的需求。  </p>
<a id="more"></a>
<p>假设有以下三段文本：</p>
<ul>
<li>the cat sat on the mat</li>
<li>the cat sat on a mat</li>
<li>we all scream for ice cream</li>
</ul>
<p>使用传统hash可能会产生如下的结果： </p>
<ol>
<li>the cat sat on the mat -&gt; 415542861</li>
<li>the cat sat on a mat -&gt; 668720516</li>
<li>we all scream for ice cream -&gt; 767429688</li>
</ol>
<p>使用simhash会应该产生类似如下的结果： </p>
<ol>
<li>the cat sat on the mat -&gt; 851459198 -&gt; 00110010110000000011110001111110 </li>
<li>the cat sat on a mat -&gt; 847263864 -&gt; 00110010100000000011100001111000 </li>
<li>we all scream for ice crea -&gt; 984968088 -&gt; 00111010101101010110101110011000</li>
</ol>
<p>可以看到SimHash比传统hash算出来更接近些。 </p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>simHash值生成过程：<br><img src="/img/15270623656302.jpg" alt><br>算法过程大概如下：</p>
<ol>
<li>分词，把需要判断文本分词形成这个文章的特征单词。最后形成去掉噪音词的单词序列并为每个词加上权重，我们假设权重分为5个级别（1~5）。比如：“ 美国“51区”雇员称内部有9架飞碟，曾看见灰色外星人 ” ==&gt; 分词后为 “ 美国（4） 51区（5） 雇员（3） 称（1） 内部（2） 有（1） 9架（3） 飞碟（5） 曾（1） 看见（3） 灰色（4） 外星人（5）”，括号里是代表单词在整个句子里重要程度，数字越大越重要。</li>
<li>hash，通过hash算法把每个词变成hash值，比如“美国”通过hash算法计算为 100101,“51区”通过hash算法计算为 101011。这样我们的字符串就变成了一串串数字，还记得文章开头说过的吗，要把文章变为数字计算才能提高相似度计算性能，现在是降维过程进行时。</li>
<li>加权，通过 2步骤的hash生成结果，需要按照单词的权重形成加权数字串，比如“美国”的hash值为“100101”，通过加权计算为“4 -4 -4 4 -4 4”；“51区”的hash值为“101011”，通过加权计算为 “ 5 -5 5 -5 5 5”。</li>
<li>合并，把上面各个单词算出来的序列值累加，变成只有一个序列串。比如 “美国”的 “4 -4 -4 4 -4 4”，“51区”的 “ 5 -5 5 -5 5 5”， 把每一位进行累加， “4+5 -4+-5 -4+5 4+-5 -4+5 4+5” ==》 “9 -9 1 -1 1 9”。这里作为示例只算了两个单词的，真实计算需要把所有单词的序列串累加。</li>
<li>降维，把4步算出来的 “9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的simhash签名。 如果每一位大于0 记为 1，小于0 记为 0。最后算出结果为：“1 0 1 0 1 1”。</li>
</ol>
<p>整个过程的流程图为：<br><img src="/img/15270624852812.jpg" alt></p>
<p>到此，如何从一个doc到一个simhash值的过程已经讲明白了。 但是还有一个重要的部分没讲：海明距离计算。</p>
<h2 id="simhash值的海明距离计算"><a href="#simhash值的海明距离计算" class="headerlink" title="simhash值的海明距离计算"></a>simhash值的海明距离计算</h2><p>二进制串A 和 二进制串B 的海明距离 就是 A xor B 后二进制中1的个数。</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A = 100111;</span><br><span class="line">B = 101010;</span><br><span class="line">hamming_distance(A, B) = count_1(A xor B) = count_1(001101) = 3;</span><br></pre></td></tr></table></figure></p>
<p>当我们算出所有doc的simhash值之后，需要计算doc A和doc B之间是否相似的条件是：<br>A和B的海明距离是否小于等于n，这个n值根据经验一般取值为3。</p>
<h2 id="海量数据计算海明距离"><a href="#海量数据计算海明距离" class="headerlink" title="海量数据计算海明距离"></a>海量数据计算海明距离</h2><p>计算文本相似度问题就转变为-&gt; 有10亿个不重复的64位的01字符串，任意给出一个64位的01字符串f，如何快速从中找出与f汉明距离小于3的字符串？</p>
<p>方法1：前0位上精确匹配，那就要在后面，也就是比较所有<br>方法2：前61位上精确匹配，后面就不需要比较了</p>
<p>那么折中的想法是 前d bits相同，留下3 bit在(64-d)bit小范围搜索，可行否?</p>
<p><strong>d bits的表示范围有2^d，总量N个指纹，平均每个范围只有N/(2^d)个指纹。<br>快速定位到前缀是d的位置以后，直接比较范围内N/(2^d)个指纹即可。</strong></p>
<p>假设我们要寻找海明距离3以内的数值，根据鸽巢原理，只要我们将整个64位的二进制串划分为4块，无论如何，匹配的两个simhash code之间至少有一块区域是完全相同的，如下图所示：<br><img src="/img/15270632191445.jpg" alt></p>
<p>由于我们无法事先得知完全相同的是哪一块区域，因此我们必须采用存储多份table的方式。在本例的情况下，我们需要存储4份table，并将64位的simhash code等分成4份；对于每一个输入的code，我们通过精确匹配的方式，查找前16位相同的记录作为候选记录，如下图所示： </p>
<p><img src="/img/15270632542779.jpg" alt></p>
<p>算法过程为：</p>
<ol>
<li>将64位的二进制串等分成四块 </li>
<li>调整上述64位二进制，将任意一块作为前16位，总共有四种组合，即每个指纹生成4个指纹。 </li>
<li>采用精确匹配的方式查找前16位 </li>
<li>如果样本库中存有2^30（差不多10亿）的哈希指纹，每个指纹存四份即 2^30 * 2^2 = 2^32个哈希指纹。共有2^16种类型，每种类型有 2^32 / 2^16 = 65536 个候选结果，大大减少了海明距离的计算成本。</li>
</ol>
<h2 id="与其他算法对比"><a href="#与其他算法对比" class="headerlink" title="与其他算法对比"></a>与其他算法对比</h2><ol>
<li>百度的去重算法<br>百度的去重算法最简单，就是直接找出此文章的最长的n句话，做一遍hash签名。n一般取3。 工程实现巨简单，据说准确率和召回率都能到达80%以上。</li>
<li>shingle算法<br>shingle原理略复杂，对于工程实现不够友好，速度太慢，基本上无法处理海量数据。</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://blog.csdn.net/lgnlgn/article/details/6008498" target="_blank" rel="noopener">https://blog.csdn.net/lgnlgn/article/details/6008498</a></li>
<li><a href="http://www.cnblogs.com/maybe2030/p/5203186.html" target="_blank" rel="noopener">http://www.cnblogs.com/maybe2030/p/5203186.html</a></li>
<li><a href="https://yanyiwu.com/work/2014/01/30/simhash-shi-xian-xiang-jie.html" target="_blank" rel="noopener">https://yanyiwu.com/work/2014/01/30/simhash-shi-xian-xiang-jie.html</a></li>
<li><a href="http://grunt1223.iteye.com/blog/964564" target="_blank" rel="noopener">http://grunt1223.iteye.com/blog/964564</a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>SimHash</tag>
      </tags>
  </entry>
  <entry>
    <title>Double-Array Trie</title>
    <url>/2017/05/06/Double-Array-Trie/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Double-Array Trie</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper watch机制</title>
    <url>/2017/04/24/zookeeper%E4%B9%8B%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="zookeeper-watch机制"><a href="#zookeeper-watch机制" class="headerlink" title="zookeeper watch机制"></a>zookeeper watch机制</h2><p>一个zk的节点可以被监控，包括这个目录中存储的数据的修改，子节点目录的变化，一旦变化可以通知设置监控的客户端，这个功能是zookeeper对于应用最重要的特性，通过这个特性可以实现的功能包括配置的集中管理，集群管理，分布式锁等等。<br><a id="more"></a></p>
<p><strong>getData(), getChildren(), and exists()</strong>可以设置对某个节点进行监听。<br><strong> New ZooKeeper时注册的watcher叫default watcher，它不是一次性的，只对client的连接状态变化作出反应。</strong></p>
<h2 id="zookeeper-watch机制特点"><a href="#zookeeper-watch机制特点" class="headerlink" title="zookeeper watch机制特点"></a>zookeeper watch机制特点</h2><h3 id="One-time-trigger"><a href="#One-time-trigger" class="headerlink" title="One-time trigger"></a>One-time trigger</h3><p>当数据改变的时候，那么一个Watch事件会产生并且被发送到客户端中。但是客户端只会收到一次这样的通知，如果以后这个数据再次发生改变的时候，之前设置Watch的客户端将不会再次收到改变的通知，因为Watch机制规定了它是一个一次性的触发器。           </p>
<p>当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.zk.nameservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ytf.zk.constant.ClientBase;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by</span></span><br><span class="line"><span class="comment"> * DATE: 17/4/23星期日.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Naming</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_PORT = <span class="number">2181</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT_PATH = <span class="string">"/root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHILD_PATH = <span class="string">"/root/childPath"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHILD_PATH_2 = <span class="string">"/root/childPath2"</span>;</span><br><span class="line">    <span class="keyword">static</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:"</span> + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, (watchedEvent) -&gt; &#123;</span><br><span class="line">                System.out.println(watchedEvent.getPath() + <span class="string">"触发了"</span> + watchedEvent.getType() + <span class="string">"事件!"</span> + <span class="string">"data:"</span> + Naming.getData(watchedEvent.getPath()));</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建根目录</span></span><br><span class="line">            zk.create(ROOT_PATH, ROOT_PATH.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            System.out.println(zk.getChildren(ROOT_PATH, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建子目录</span></span><br><span class="line">            zk.create(CHILD_PATH, <span class="string">"childPath"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            <span class="comment">// 取出子目录数据</span></span><br><span class="line">            System.out.println(CHILD_PATH + <span class="string">"数据: "</span> + <span class="keyword">new</span> String(zk.getData(CHILD_PATH, <span class="keyword">true</span>, <span class="keyword">null</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改子目录节点数据</span></span><br><span class="line">            zk.setData(CHILD_PATH, <span class="string">"modification"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(zk.getData(CHILD_PATH, <span class="keyword">true</span>, <span class="keyword">null</span>)));</span><br><span class="line"></span><br><span class="line">            zk.setData(CHILD_PATH, <span class="string">"modification2"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            zk.delete(CHILD_PATH, -<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 删除父目录节点</span></span><br><span class="line">            zk.delete(ROOT_PATH, -<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getData</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(zk.getData(path, <span class="keyword">false</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<blockquote>
<p>null触发了None事件!data:null<br>[]<br>/root/childPath数据: childPath<br>/root触发了NodeChildrenChanged事件!data:/root<br>/root/childPath触发了NodeDataChanged事件!data:modification<br>modification<br>/root/childPath触发了NodeDataChanged事件!data:modification2</p>
</blockquote>
<p>注意将第41行的参数true改为false后的执行结果：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.zk.nameservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ytf.zk.constant.ClientBase;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by</span></span><br><span class="line"><span class="comment"> * DATE: 17/4/23星期日.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Naming</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_PORT = <span class="number">2181</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT_PATH = <span class="string">"/root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHILD_PATH = <span class="string">"/root/childPath"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHILD_PATH_2 = <span class="string">"/root/childPath2"</span>;</span><br><span class="line">    <span class="keyword">static</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:"</span> + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, (watchedEvent) -&gt; &#123;</span><br><span class="line">                System.out.println(watchedEvent.getPath() + <span class="string">"触发了"</span> + watchedEvent.getType() + <span class="string">"事件!"</span> + <span class="string">"data:"</span> + Naming.getData(watchedEvent.getPath()));</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建根目录</span></span><br><span class="line">            zk.create(ROOT_PATH, ROOT_PATH.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            System.out.println(zk.getChildren(ROOT_PATH, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建子目录</span></span><br><span class="line">            zk.create(CHILD_PATH, <span class="string">"childPath"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            <span class="comment">// 取出子目录数据</span></span><br><span class="line">            System.out.println(CHILD_PATH + <span class="string">"数据: "</span> + <span class="keyword">new</span> String(zk.getData(CHILD_PATH, <span class="keyword">true</span>, <span class="keyword">null</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改子目录节点数据</span></span><br><span class="line">            zk.setData(CHILD_PATH, <span class="string">"modification"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(zk.getData(CHILD_PATH, <span class="keyword">false</span>, <span class="keyword">null</span>)));</span><br><span class="line"></span><br><span class="line">            zk.setData(CHILD_PATH, <span class="string">"modification2"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            zk.delete(CHILD_PATH, -<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 删除父目录节点</span></span><br><span class="line">            zk.delete(ROOT_PATH, -<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getData</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(zk.getData(path, <span class="keyword">false</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:</p>
<blockquote>
<p>null触发了None事件!data:null<br>[]<br>/root触发了NodeChildrenChanged事件!data:/root<br>/root/childPath数据: childPath<br>/root/childPath触发了NodeDataChanged事件!data:modification<br>modification</p>
</blockquote>
<p>看到对于路径/root/childPath的数据修改并没有监听到</p>
<h3 id="Sent-to-the-client"><a href="#Sent-to-the-client" class="headerlink" title="Sent to the client"></a>Sent to the client</h3><p>Watch的通知事件是从服务器异步发送给客户端，不同的客户端收到的Watch的时间可能不同。但是ZooKeeper有保证：当一个客户端在收到Watch事件之前是不会看到结点数据的变化的。例如：A=3，此时在上面设置了一次Watch，如果A突然变成4了，那么客户端会先收到Watch事件的通知，然后才会看到A=4。</p>
<p>Zookeeper 客户端和服务端是通过 Socket 进行通信的，由于网络存在故障，所以监听事件很有可能不会成功地到达客户端，监听事件是异步发送至监视者的，Zookeeper 可以保障顺序性(ordering guarantee)：即客户端只有首先收到监听事件后，才会感知到它所监听的 znode 发生了变化.</p>
<blockquote>
<p>a client will never see a change for which it has set a watch until it first sees the watch event). </p>
</blockquote>
<p>网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到都是一致的顺序。</p>
<blockquote>
<p>The key point is that everything seen by the different clients will have a consistent order.</p>
</blockquote>
<h3 id="The-data-for-which-the-watch-was-set"><a href="#The-data-for-which-the-watch-was-set" class="headerlink" title="The data for which the watch was set"></a>The data for which the watch was set</h3><p><strong>这部分是重点</strong></p>
<blockquote>
<p>This refers to the different ways a node can change. It helps to think of ZooKeeper as maintaining two lists of watches: data watches and child watches. getData() and exists() set data watches. getChildren() sets child watches. Alternatively, it may help to think of watches being set according to the kind of data returned. getData() and exists() return information about the data of the node, whereas getChildren() returns a list of children. Thus, setData() will trigger data watches for the znode being set (assuming the set is successful). A successful create() will trigger a data watch for the znode being created and a child watch for the parent znode. A successful delete() will trigger both a data watch and a child watch (since there can be no more children) for a znode being deleted as well as a child watch for the parent znode.</p>
</blockquote>
<p>这意味着 znode 节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监听链表：</p>
<p>数据监听和子节点监听(data watches and child watches) </p>
<p><strong>getData() and exists() 设置数据监听,getChildren() 设置子节点监听.</strong>也可以理解成设置为哪种监听是由返回的数据类型决定的。getData() 和 exists() 返回节点数据相关信息，getChildren()返回一个子节点列表。因此，setData()会触发数据监听，create()会触发数据监听及父节点的child watch; delete() 操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。</p>
<p>实验一下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.zk.nameservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ytf.zk.constant.ClientBase;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by</span></span><br><span class="line"><span class="comment"> * DATE: 17/4/23星期日.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Naming</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_PORT = <span class="number">2181</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT_PATH = <span class="string">"/root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHILD_PATH = <span class="string">"/root/childPath"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHILD_PATH_2 = <span class="string">"/root/childPath2"</span>;</span><br><span class="line">    <span class="keyword">static</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:"</span> + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, (watchedEvent) -&gt; &#123;</span><br><span class="line">                System.out.println(watchedEvent.getPath() + <span class="string">"触发了"</span> + watchedEvent.getType() + <span class="string">"事件!"</span> + <span class="string">"data:"</span> + Naming.getData(watchedEvent.getPath()));</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建根目录</span></span><br><span class="line">            zk.create(ROOT_PATH, ROOT_PATH.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            <span class="comment">// 创建子目录</span></span><br><span class="line">            zk.create(CHILD_PATH, <span class="string">"childPath"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建对子目录的监听</span></span><br><span class="line">            System.out.println(zk.getChildren(CHILD_PATH, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改子目录节点数据,观察根节点是否监听到</span></span><br><span class="line">            zk.setData(CHILD_PATH, <span class="string">"modification"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            zk.delete(CHILD_PATH, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除父目录节点</span></span><br><span class="line">            zk.delete(ROOT_PATH, -<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getData</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(zk.getData(path, <span class="keyword">false</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<blockquote>
<p>null触发了None事件!data:null<br>[]</p>
</blockquote>
<p>修改代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.zk.nameservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ytf.zk.constant.ClientBase;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by</span></span><br><span class="line"><span class="comment"> * DATE: 17/4/23星期日.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Naming</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_PORT = <span class="number">2181</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT_PATH = <span class="string">"/root"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHILD_PATH = <span class="string">"/root/childPath"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHILD_PATH_2 = <span class="string">"/root/childPath2"</span>;</span><br><span class="line">    <span class="keyword">static</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:"</span> + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, (watchedEvent) -&gt; &#123;</span><br><span class="line">                System.out.println(watchedEvent.getPath() + <span class="string">"触发了"</span> + watchedEvent.getType() + <span class="string">"事件!"</span> + <span class="string">"data:"</span> + Naming.getData(watchedEvent.getPath()));</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建根目录</span></span><br><span class="line">            zk.create(ROOT_PATH, ROOT_PATH.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            <span class="comment">// 创建子目录</span></span><br><span class="line">            zk.create(CHILD_PATH, <span class="string">"childPath"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建对子目录的数据监听</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(zk.getData(CHILD_PATH, <span class="keyword">true</span>, <span class="keyword">null</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改子目录节点数据,观察根节点是否监听到</span></span><br><span class="line">            zk.setData(CHILD_PATH, <span class="string">"modification"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            zk.delete(CHILD_PATH, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除父目录节点</span></span><br><span class="line">            zk.delete(ROOT_PATH, -<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getData</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(zk.getData(path, <span class="keyword">false</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:</p>
<blockquote>
<p>null触发了None事件!data:null<br>childPath<br><strong>/root/childPath触发了NodeDataChanged事件!data:modification</strong></p>
</blockquote>
<p>对比一下可以看出不同的操作触发不同的监听事件。</p>
<h2 id="各种watch触发的情况总结"><a href="#各种watch触发的情况总结" class="headerlink" title="各种watch触发的情况总结"></a>各种watch触发的情况总结</h2><p>可以注册watcher的方法：getData、exists、getChildren。      可以触发watcher的方法：create、delete、setData。连接断开的情况下触发的watcher会丢失。<br>一个Watcher实例是一个回调函数，被回调一次后就被移除了。如果还需要关注数据的变化，需要再次注册watcher。<br>New ZooKeeper时注册的watcher叫default watcher，它不是一次性的，只对client的连接状态变化作出反应。</p>
<h3 id="写操作与ZK内部产生的事件的对应关系"><a href="#写操作与ZK内部产生的事件的对应关系" class="headerlink" title="写操作与ZK内部产生的事件的对应关系"></a>写操作与ZK内部产生的事件的对应关系</h3><table>
<thead>
<tr>
<th></th>
<th>event For “/path”</th>
<th>event For “/path/child”</th>
</tr>
</thead>
<tbody>
<tr>
<td>create(“/path”)</td>
<td>EventType.NodeCreated</td>
<td>无</td>
</tr>
<tr>
<td>delete(“/path”)</td>
<td>EventType.NodeDeleted</td>
<td>无</td>
</tr>
<tr>
<td>setData(“/path”)</td>
<td>EventType.NodeDataChanged</td>
<td>无</td>
</tr>
<tr>
<td>create(“/path/child”)</td>
<td>EventType.NodeChildrenChanged</td>
<td>EventType.NodeCreated</td>
</tr>
<tr>
<td>delete(“/path/child”)</td>
<td>EventType.NodeChildrenChanged</td>
<td>EventType.NodeDeleted</td>
</tr>
<tr>
<td>setData(“/path/child”)</td>
<td>无</td>
<td>EventType.NodeDataChanged</td>
</tr>
</tbody>
</table>
<h3 id="事件类型与watcher的对应关系"><a href="#事件类型与watcher的对应关系" class="headerlink" title="事件类型与watcher的对应关系"></a>事件类型与watcher的对应关系</h3><table>
<thead>
<tr>
<th>event For “/path”</th>
<th>defaultWatcher</th>
<th>exists(“/path”)</th>
<th>getData(“/path”)</th>
<th>getChildren(“/path”)</th>
</tr>
</thead>
<tbody>
<tr>
<td>EventType.None</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>EventType.NodeCreated</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>EventType.NodeDeleted</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>EventType.NodeDataChanged</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>EventType.NodeChildrenChanged</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
</tr>
</tbody>
</table>
<h3 id="写操作与watcher的对应关系"><a href="#写操作与watcher的对应关系" class="headerlink" title="写操作与watcher的对应关系"></a>写操作与watcher的对应关系</h3><table>
<thead>
<tr>
<th></th>
<th>“/path”</th>
<th></th>
<th></th>
<th></th>
<th>“/path/child”</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>exists</td>
<td>getData</td>
<td>getChildren</td>
<td>exists</td>
<td>getData</td>
<td>getChildren</td>
</tr>
<tr>
<td>create(“/path”)</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>delete(“/path”)</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>setData(“/path”)</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>create(“/path/child”)</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>delete(“/path/child”)</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>setData(“/path/child”)</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p><strong>值得注意的是：getChildren(“/path”)监视/path的子节点，如果（/path）自己删了，也会触发NodeDeleted事件。</strong></p>
<h3 id="永久监听"><a href="#永久监听" class="headerlink" title="永久监听"></a>永久监听</h3><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://zookeeper.apache.org/doc/trunk/zookeeperProgrammers.html" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/trunk/zookeeperProgrammers.html</a><br><a href="http://lixuguang.iteye.com/blog/2342721" target="_blank" rel="noopener">http://lixuguang.iteye.com/blog/2342721</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka官方文档翻译--设计</title>
    <url>/2017/04/22/Kafka%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>我们设计Kafka用来作为统一的平台来处理大公司可能拥有的所有实时数据源。为了做到这点，我们必须思考大量的使用场景。</p>
<p>它必须有高吞吐去支持大数据流，例如实时日志聚合。</p>
<p>它必须优雅的处理数据积压，以支持定期从离线系统加载数据。</p>
<p>这也以为这系统必须支持低延迟的分发来处理传统消息系统的场景。</p>
<p>我们想支持分区的、分布式的、实时的处理数据源并创建新的数据源，这推动了我们的分区和消费模型。</p>
<p>最后，将流反馈到其他系统进行服务的情况下，我们知道系统必须能够保证容错性，在部分机器故障的时候提供服务。</p>
<p>支持这些使用推动我们做了一些列特殊的元素设计，比起传统的消息系统更像是数据库日志。我们将在以下章节介绍一些设计要素。</p>
<a id="more"></a>
<h3 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h3><h4 id="Don’t-fear-the-filesystem"><a href="#Don’t-fear-the-filesystem" class="headerlink" title="Don’t fear the filesystem!"></a>Don’t fear the filesystem!</h4><p>Kafka强依赖文件系统来存储和缓存消息。“磁盘是缓慢的”是一个通常的认知，这是人们怀疑持久化的结构能否提供强大的性能。事实上，磁盘比人们想象的更慢也更快，这基于如何去使用它们；一个合适的设计可以使磁盘和网络一样的快速。</p>
<p>影响磁盘性能的核心因素是磁盘驱动的吞吐和过去十年磁盘的查找方式不同了。使用六个7200rpm的SATA RAID-5阵列的JBOD配置线性写入能力为600MB/sec，而随机写的性能仅仅是100k/sec，相差了6000倍。线性写入和读取是最可预测的，并且被操作系统大量的优化。现代操作系统提供read-ahead和write-behind技术，他们大块预读数据，并将较小的罗机械合并成较大的物理写入。在ACM Queue的文章中可以找到此问题相关的进一步讨论；他们实际上发现顺序访问磁盘在某些情况下比随机访问内存还快。</p>
<p>为了弥补性能的差异，现代操作系统在使用主内存来做磁盘缓存时变的越来越激进。当内存被回收时，现代操作系统将乐意将所有可用内存转移到磁盘缓存，而且性能会降低很多。所有的磁盘读写都需要通过这层缓存。这个功能不会被轻易关闭，除非使用Direct IO，因此尽管在进程内缓存了数据，这些数据也有可能在操作系统的pagecache中缓存，从而被缓存了两次。</p>
<p>此外，我们建立在JVM之上，任何在Java内存上花费过时间的人都知道两件事情：</p>
<p>对象的内存开销非常大，通常将存储的数据大小翻倍（或更多）。</p>
<p>Java的内存回收随着堆内数据的增多变的越来越缓慢。</p>
<p>由于这些因素，使用文件系统并依赖于pagecache要优于维护内存中缓存或其他结构——我们至少可以通过直接访问内存来是可用内存增加一倍，并通过存储字节码而不是对象的方式来节约更多的内存。这样做将可以在32G的机器上使用28-30GB的内存，而不需要承受GC的问题。此外，及时重启服务，内存会保持有效，而进程内缓存将需要重建（对于10G的数据可能需要10分钟），否则需要从冷数据加载（可怕的初始化性能）。这也大大简化了代码，因为保持缓存和文件之间的一致性是由操作系统负责的，这比进程中操作更不容易出错。</p>
<p>这是一个简单的设计：在进程内尽量缓冲数据，空间不足时将所有数据刷写到磁盘，我们采用了相反的方式。数据并尽快写入一个持久化的日志而不需要立即刷到磁盘。实际上这只是意味着数据被转移到了内核的pagecache。</p>
<p>（以pagecache为中心的设计风格）</p>
<h4 id="Constant-Time-Suffices"><a href="#Constant-Time-Suffices" class="headerlink" title="Constant Time Suffices"></a>Constant Time Suffices</h4><p>在消息系统中使用持久化数据通常是具有关联的BTree或其他随机访问的数据结构，以维护消息的元数据。BTree是最通用的数据结构，可以在消息系统中支持各种各样的语义。BTree的操作时间复杂度是O(log N)。通常O(log N)被认为是固定时间的，但是在磁盘操作中却不是。每个磁盘一次只能执行一个seek，所以并行度受到限制。因此即使少量的磁盘搜索也会导致非常高的开销。由于操作系统将快速的缓存操作和非常慢的磁盘操作相结合，所以观察到树结构的操作通常是超线性的，因为数据随固定缓存增加。</p>
<p>直观的，持久化队列可以像日志的解决方案一样，简单的读取和追加数据到文件的结尾。这个结构的优势是所有的操作都是O(1)的，并且读取是可以并行不会阻塞的。这具有明显的性能优势，因为性能与数据大小完全分离，可以使用低速的TB级SATA驱动器。虽然这些驱动器的搜索性能不佳，但是对于大量读写而言，他们的性能是可以接受的，并且价格是三分之一容量是原来的三倍。</p>
<p>无需任何的性能代价就可以访问几乎无限的磁盘空间，这意味着我们可以提供一些在消息系统中非寻常的功能。例如，在Kafka中，我们可以将消息保留较长的时间（如一周），而不是在消费后就尽快删除。这位消费者带来了很大的灵活性。</p>
<h3 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h3><p>我们在效率上付出了很大的努力。主要的用例是处理web的数据，这个数据量非常大：每个页面可能会生成十几个写入。此外我们假设每个发布的消息至少被一个Consumer消费，因此我们尽可能使消费的开销小一些。</p>
<p>从构建和运行一些类似的系统的经验发现，效率是多租户操作的关键。如果下游基础服务成为瓶颈，那么应用程序的抖动将会引起问题。我们确保应用程序不会引起基础服务的Load问题，这个非常重要的，当一个集群服务上百个应用程序的时候，因为应用的使用模式的变化时非常频繁的。</p>
<p>我们在之前的章节中讨论过磁盘的效率。一旦不良的磁盘访问模式被消除，这种类型的系统有两个低效的原因：太多太小的IO操作和过多的数据拷贝。</p>
<p>太小的IO操作问题存在于客户端和服务端之间，也存在于服务端自身的持久化当中。</p>
<p>为了避免这个问题，我们的协议围绕“message set”抽象，通常是将消息聚合到一起。这允许网络请求将消息聚合到一起，并分摊网络往返的开销，而不是一次发送单个消息。服务端依次将大块消息追加到日志中，消费者一次线性获取一批数据。</p>
<p>这种简单的优化产生了一个数量级的加速。分批带来了更大的网络包，连续的磁盘操作，连续的内存块等等，这些都使得Kafka将随机消息写入转化为线性的写入并流向Consumer。</p>
<p>其他低效的地方是字符复制。在消息少时不是问题，但是对负载的影响是显而易见的。为了避免这种情况，我们采用被producer、broker、Consumer共享的标准的二进制消息格式（所以数据可以在传输时不需要进行修改）。</p>
<p>由Broker维护的消息日志本身只是一批文件，每个文件由一系列以相同格式写入的消息构成。保持相同的格式保证了最重要的优化：网络传输和持久化日志块。现在UNIX操作系统提供了高度优化的代码路径用于将pagecache的数据传输到网络；在Linux中，这有sendfile实现。<br><a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="noopener">sendfile system call</a></p>
<p>要理解sendfile的影响，了解从文件到网络传输数据的data path非常重要：</p>
<ol>
<li>操作系统从磁盘读取文件数据到pagecache，在内核空间</li>
<li>用户从内核空间将数据读到用户空间的buffer</li>
<li>操作系统重新将用户buffer数据读取到内核空间写入到socket中</li>
<li>操作系统拷贝socket buffer数据到NIC buffer并发送到网络<br>这显然是低效的，有四个副本和两个系统调用。使用sendfile，允许操作系统直接将数据从pagecache写入到网络，而避免不必要的拷贝。在这个过程中，只有最终将数据拷贝到NIC buffer是必要的。</li>
</ol>
<p>我们期望一个共同的场景是多个Consumer消费一个Topic数据，使用zero-copy优化，数据被拷贝到pagecache并且被多次使用，而不是每次读取的时候拷贝到内存。这允许以接近网络连接的速度消费消息。</p>
<p>pagecache和sendfile的组合意味着在消费者追上写入的情况下，将看不到磁盘上的任何读取活动，因为他们都将从缓存读取数据。</p>
<p>sendfile和更多的zero-copy背景知识见zero-copy</p>
<p>End-to-end Batch Compression</p>
<p>在一些场景下，CPU核磁盘并不是性能瓶颈，而是网络带宽。在数据中心和广域网上传输数据尤其如此。当然，用户可以压缩它的消息而不需要Kafka的支持，但是这可能导致非常差的压缩比，因为冗余的大部分是由于相同类型的消息之间的重复（例如JSON的字段名）。多个消息进行压缩比单独压缩每条消息效率更高。</p>
<p>Kafka通过允许递归消息来支持这一点。一批消息可以一起压缩并以此方式发送到服务端。这批消息将以压缩的形式被写入日志，只能在消费端解压缩。</p>
<p>Kafka支持GZIP，Snappy和LZ4压缩协议。更多的压缩相关的细节在这里。</p>
<h3 id="The-Producer"><a href="#The-Producer" class="headerlink" title="The Producer"></a>The Producer</h3><h4 id="Load-balancing"><a href="#Load-balancing" class="headerlink" title="Load balancing"></a>Load balancing</h4><p>Producer直接向Leader Partition所在的Broker发送数据而不需要经过任何路由的干预。为了支持Producer直接向Leader Partition写数据，所有的Kafka服务节点都支持Topic Metadata的请求，返回哪些Server节点存活的、Partition的Leader节点的分布情况。</p>
<p>由客户端控制将数据写到哪个Partition。这可以通过随机或者一些负载均衡的策略来实现（即客户端去实现Partition的选择策略）。Kafka暴露了一个接口用于用户去指定一个Key，通过Key hash到一个具体的Partition。例如，如果Key是User id，那么同一个User的数据将被发送到同一个分区。这样就允许消费者在消费时能够对消费的数据做一些特定的处理。这样的设计被用于处理“局部敏感”的数据（结合上面的场景，Partition内的数据是可以保持顺序消费的，那么同一个用户的数据在一个分区，那么就可以保证对任何一个用户的处理都是顺序的）。</p>
<h4 id="Asynchronous-send"><a href="#Asynchronous-send" class="headerlink" title="Asynchronous send"></a>Asynchronous send</h4><p>批处理是提升效率的主要方式一致，为了支持批处理，Kafka允许Producer在内存聚合数据并在一个请求中发出。批处理的大小可以是通过消息数量指定的，也可以是通过等待的时间决定的（例如64K或者10ms）。这样允许聚合更多的数据后发送，减少了IO操作。缓冲的数据大小是可以配置了，这样能适当增加延迟来提升吞吐。</p>
<p>更多的细节可以在Producer的配合和API文档中找到。</p>
<h3 id="The-Consumer"><a href="#The-Consumer" class="headerlink" title="The Consumer"></a>The Consumer</h3><p>Kafka Consumer通过给Leader Partition所在的Broker发送“fetch”请求来进行消费。Consumer在请求中指定Offset，并获取从指定的Offset开始的一段数据。因此Consumer对消费的位置有绝对的控制权，通过重新设置Offset就可以重新消费数据。</p>
<h4 id="Push-vs-Pull"><a href="#Push-vs-Pull" class="headerlink" title="Push vs Pull"></a>Push vs Pull</h4><p>我们考虑的一个初步问题是Consumer应该从Broker拉取数据还是Broker将数据推送给Consumer。在这方面，Kafka和大多数消息系统一样，采用传统的设计方式，由Producer想Broker推送数据，Consumer从Broker上拉取数据。一些日志中心系统，如<a href="https://github.com/facebookarchive/scribe" target="_blank" rel="noopener">Scribe</a>和<a href="http://flume.apache.org/" target="_blank" rel="noopener">Apache Flume</a>，遵循数据向下游推送的方式。两种方式各有利弊。基于推送的方式，由于是由Broker控制速率，不能很好对不同的Consumer做处理。Consumer的目标通常是以最大的速率消费消息，不幸的是，在一个基于推送的系统中，当Consumer消费速度跟不上生产速度 时，推送的方式将使Consumer“过载”。基于拉取的系统在这方面做的更好，Consumer只是消费落后并在允许时可以追上进度。消费者通过某种协议来缓解这种情况，消费者可以通过这种方式来表明它的负载，这让消费者获得充分的利用但不会“过载”。以上原因最终使我们使用更为传统的Pull的方式。</p>
<p>Pull模型的另一个优势是可以聚合数据批量发送给Consumer。Push模型必须考虑是立即推送数据给Consumer还是等待聚合一批数据之后发送。如果调整为低延迟，这将导致每次只发送一条消息（增加了网络交互）。基于Pull的模式，Consumer每次都会尽可能多的获取消息（受限于可消费的消息数和配置的每一批数据最大的消息数），所以可以优化批处理而不增加不必要的延迟。</p>
<p>基于Pull模式的一个缺陷是如果Broker没有数据，Consumer可能需要busy-waiting的轮训方式来保证高效的数据获取（在数据到达后快速的响应）。为了避免这种情况，我们在Pull请求中可以通过参数配置“long poll”的等待时间，可以在服务端等待数据的到达（可选的等待数据量的大小以保证每次传输的数据量，减少网络交互）。</p>
<p>你可以想象其他一些从端到端，采用Pull的可能的设计。Producer把数据写到本地日志，Broker拉取这些Consumer需要的数据。一个相似的被称为“store-and-forward”的Producer经常被提及。这是有趣的，但是我们觉得不太适合我们可能会有成千上万个Producer的目标场景。我们维护持久化数据系统的经验告诉我们，在系统中使多应用涉及到上千块磁盘将会使事情变得不可靠并且会使操作它们变成噩梦。最后再实践中，我们发现可以大规模的运行强大的SLAs通道，而不需要生产者持久化。</p>
<h4 id="Consumer-Position"><a href="#Consumer-Position" class="headerlink" title="Consumer Position"></a>Consumer Position</h4><p>记录哪些消息被消费过是消息系统的关键性能点。</p>
<p>大多数消息系统在Broker上保存哪些消息已经被消费的元数据。也就是说，Broker可以在消费传递给Consumer后立即记录或等待消费者确认之后记录。这是一个直观的选择，并且对于单个服务器而言并没有更好的方式可以存储这个状态。大多数消息系统中的存储设备并不能很好的伸缩，所以这也是务实的选择——当Broker确认消息被消费后就立即删除，以保证存储较少的数据。</p>
<p>让Broker和Consumer关于那些消息已经被消费了达成一致并不是一个简单的问题。如果Broker在将消息写到网络之后就立即认为消息已经被消费，那么如果Consumer消费失败（Consumer在消费消息之前Crash或者网络问题等）消息将丢失。为了解决这个问题，一些消息系统增加了ACK机制，消息被标记为只是发送出去而不是已经被消费，Broker需要等待Consumer发送的ACK请求之后标记具体哪些消息已经被消费了。这个策略修复了消息丢失的问题，但是引起了新的问题。第一，如果Consumer处理了消息，但是在发送ACK给Broker之前出现问题，那么消息会被重复消息。第二，Broker需要维护每一条消息的多个状态（是否被发送、是否被消费）。棘手的问题是要处理被发送出去但是没有被ACK的消息。</p>
<p>Kafka采用不同的方式处理。Topic被划分为多个内部有序的分区，每个分区任何时刻只会被一个group内的一个Consumer消费。这意味着一个Partition的Position信息只是一个数字，标识下一条要消费的消息的偏移量。这使得哪些消息已经被消费的状态变成了一个简单的数据。这个位置可以定期做CheckPoint。这使得消息的ACK的代价非常小。</p>
<p>这个方案还有其他的好处。消费者可以优雅的指定一个旧的偏移量并重新消费这些数据。这和通常的消息系统的观念相违背，但对很多消费者来说是一个很重要的特性。比如，如果Consumer程序存在BUG，在发现并修复后，可以通过重新消费来保证数据都正确的处理。</p>
<h4 id="Offline-Data-Load"><a href="#Offline-Data-Load" class="headerlink" title="Offline Data Load"></a>Offline Data Load</h4><p>可扩展的持久化存储的能力，是消费者可以定期的将数据导入到像Hadoop这样的离线系统或关系型数据仓库中。</p>
<p>在Hadoop的场景中，我们通过把数据分发到独立的任务中进行并行处理，按照node/topic/partition组合，充分使用另行能力加载数据。Hadoop提供任务管理，失败的任务可以重新启动，而不需要担心重复数据的危险——任务会从原始位置重新启动。</p>
<h3 id="Message-Delivery-Semantics"><a href="#Message-Delivery-Semantics" class="headerlink" title="Message Delivery Semantics"></a>Message Delivery Semantics</h3><p>现在我们对Producer和Consumer已经有了一定的了解，接着我们来讨论Kafka在Producer和Consumer上提供的语义。显然的，在分发消息时是可以有多种语义的：</p>
<ul>
<li>At most once：消息可能丢失，但不会重复投递</li>
<li>At least once：消息不会丢失，但可能会重复投递</li>
<li>Exactly once：消息不丢失、不重复，会且只会被分发一次（真正想要的）<br>值得注意的是这分为两个问题：发布消息的可用性和消费消息的可用性。</li>
</ul>
<p>许多系统都声称提供“exactly once”语义，仔细阅读会发现，这些声明是误导的（他们没有考虑Producer和Consumer可能Crash的场景，或是数据写入磁盘后丢失的情况）。</p>
<p>Kafka提供的语义是直接了当的。发送消息的时候我们有一个消息被Commit到Log的概念。一旦消息已经被Commit，它将不会丢失，只要还有一个复制了消息所在Partition的Broker存活着。“存活”的定义以及我们覆盖的失败的情况将在下一节描述。现在假设一个完美的Broker，并且不会丢失，来理解对Producer和Consumer提供的语义保证。如果Producer发送一条消息，并且发生了网络错误，我们是不能确认错误发生在消息Commit之前还是消息Commit之后的。类似于使用自增主键插入数据库，是不能确认写入之后的主键值的。</p>
<p>Producer没有使用的强制可能的语义。我们无法确认网络是否会发生异常，可以使Producer创建有序的主键使重试发送成为幂等的行为。这个特性对一个复制系统来说不是无价值的，因为服务器在发生故障的情况下依旧需要提供服务。使用这个功能，Producer可以重试，直到收到消息成功commit的响应，在这个点上保证消息发送的exactly once。我们希望把这个特性加到后续的Kafka版本中。</p>
<p>不是所有的场景都需要这样的保证。对应延迟敏感的场景，我们允许Producer指定其期望的可用性级别。如果Producer期望等待消息Commit，那么这可能消耗10ms。Producer也可以指定以异步的方式发送消息或只等Leader节点写入消息（不能Follower）。</p>
<p>接着我们从消费者的视角来描述语义。所有的副本都拥有偏移量相同的日志。Consumer控制它在日志中的偏移量。如果Consumer一直正常运行，它可以只把偏移量存储在内存中，但是如果Consumer crash且我们期望另一个新的Consumer接管消费，那么需要选择一个位置来开始消费。假设Consumer读取了一些消息——它有集中处理消息和位置的方式。</p>
<ol>
<li><p>它可以读取消息，然后保存位置信息，然后处理消息。在这个场景中，Consumer可能在保存位置信息后消费消息失败，那么下一次消费可能从保存的位点开始，尽管之前部分消息被处理失败。这是消费处理过程中失败的at-most-once（只被处理了一次，但是可能处理失败）。</p>
</li>
<li><p>它可以读取消息，之后处理消息，最后保存位置信息。这个场景中，Consumer可能在处理完消息，但是保存位点之前Crash，那么下一次会重新消费这些消息，尽管已经被消费过。这是Consumer Crash引起的at-least-once（消息可能会被处理多次）。在很多场景中，消息可以有一个主键，这样可以保证处理的幂等性（多次处理不会有影响）。</p>
</li>
</ol>
<p>那么什么是exactly once语义？这里的限制实际上不是消息系统的特性，而是消息处理和位置信息的保存。经典的解决方案是采用两阶段提交的方式来处理。但是这也可以用一个更简单的方式来处理：通过将消息处理结果和位置信息保存在同一位置上。这是更好的，因为很多Consumer期望写入的系统并不支持两阶段提交。例如, 我们的hadoop ETL工具从保存数据到hdfs上的同时也把位移位置也保存到hdfs中了, 这样可以保证数据和位移位置同时被更新或者都没更新.我们在很多系统上使用类似的模式, 用于解决那些需要这种强语义但是却没有主键用于区分重复的储存系统中.</p>
<p>默认Kafka提供at-least-once语义的消息分发(<a href="https://kafka.apache.org/documentation/streams/" target="_blank" rel="noopener">kafka stream</a>)，允许用户通过在处理消息之前保存位置信息的方式来提供at-most-once语义。exactly-once语义需要和输出系统像结合，Kafka提供的offset可以使这个实现变的“直接了当的”（变得比较简单）。</p>
<h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>Kafka为Topic的每个Partition日志进行备份，备份数量可以由用户进行配置。这保证了系统的自动容错，如果有服务器宕机，消息可以从剩余的服务器中读取。</p>
<p>其他消息系统提供了备份相关的功能，但在我们看来，这是一个附加的功能，不能被大量使用，并且伴随着大量的缺点：Slave是不活跃的（这里应该是指Slave只提供了备份，并不可以被消费等等）、吞吐受到很大的影响、需要手动配置等等。在Kafka中，我们默认就提供备份，实际上我们认为没有备份的Topic是一种特殊的备份，只是备份数为1。</p>
<p>备份的单位是Topic的分区。在没有发生异常的情况下，Kafka中每个分区都会有一个Leader和0或多个Follower。备份包含Leader在内（也就是说如果备份数为3，那么有一个Leader Partition和两个Follower Partition）。所有的读写请求都落在Leader Partition上。通常情况下分区要比Broker多，Leader分区分布在Broker上。Follower上的日志和Leader上的日志相同，拥有相同的偏移量和消息顺序（当然，在特定时间内，Leader上日志会有一部分数据还没复制到Follower上）。</p>
<p>Follower作为普通的Consumer消费Leader上的日志，并应用到自己的日志中。Leader允许Follower自然的，成批的从服务端获取日志并应用到自己的日志中。</p>
<p>大部分分布式系统都需要自动处理故障，需要对节点“alive”进行精确的定义。例如在Kafka中，节点存活需要满足两个条件：</p>
<p>节点需要保持它和ZooKeeper之间的Session（通过ZK的心跳机制）<br>如果是Follower，需要复制Leader上的写事件，并且复制进度没有“落后太多”<br>我们称满足这两个条件的节点为“同步的”来避免使用“alive”或“failed”这样模糊的概念。Leader节点保存同步中的Follower节点。如果一个Follower宕机或复制落后太多，Leader将从同步的Follower List中将其移除。通过replica.lag.time.max.ms配置来定义“落后太多”。</p>
<p>在分布式系统的术语中，我们只尝试处理“失败/恢复”模型——节点突然停止工作之后恢复的情况。Kafka不处理“拜占庭”问题。</p>
<p>一条消息在被应用到所有的备份上之后被认为是“已经提交的”。只有提交了的消息会被Consumer消费。这意味着Consumer不需要担心Leader节点宕机后消息会丢失。另一方面，Producer可以配置是否等待消息被提交，这取决于他们在延迟和可用性上的权衡。这个可以通过Producer的配置项中设置。</p>
<p>Kafka提供了一条消息被提交之后，只要还有一个备份可用，消息就不会丢失的保证。</p>
<p>Kafka保证在节点故障后依旧可用，但是无法再网络分区的情况下保持可用。</p>
<p>Replicated Logs: Quorums, ISRs, and State Machines (Oh my!)</p>
<p>Kafka分区机制的核心是日志复制。日志复制是分布式系统中最基础的东西，有很多方式可以实现。日志复制可以作为基于状态机的分布式系统的基础设置。</p>
<p>日志复制模型用于处理连续、有序的输入（例如给log entry添加0、1、2这样的编号）。有很多方式实现日志复制，最简单的方式是Leader选择和提供这个顺序之。只要Leader节点存活，Follower只需要按照Leader选择的值和顺序来复制即可。</p>
<p>当然，如果Leader不会宕机，那我们也不需要Follower了！在Leader宕机之后，我们需要在Follower中选择一个节点成为新的Leader。Follower可能会宕机或者日志落后较多，所以我们必须确保选择一个“及时同步”（复制进度和Leader最近的节点）成为新的Leader。复制算法必须提供这样的保证：如果Client收到一条消息已经被Commit了，如果Leader宕机，新Leader必须包含这条已经被Commit的消息。这是一个权衡：Leader在确认消息Commit之前需要等待更多的Follower来确认复制了消息来保证在Leader宕机后有更多可以成为Leader的Follower节点。</p>
<p>如果你选择了所需要的ACK的数量以及选择Leader时需要比较的日志数以确保能重合，这个叫做Quorum。</p>
<p>一个通用的来权衡的方式是提交日志和选择Leader时都采用大多数投票的原则。这不是Kafka使用的方式，但是无所谓，让我们去理解这种方式来了解实现原理。假设一共有2f+1个备份，那么f+1的副本必须在Leader提交commit之前接收到消息，这样就可以从f+1个节点中选择出新节点作为Leader。因为任何f+1个节点，必然有一个节点包含最全的日志。还有很多关于这个算法的细节需要处理（如何定义日志更全、在Leader节点宕机时保持日志一致性等）在这里先忽略。</p>
<p>大多数选票的方法有非常好的特性：延迟取决于同步最快的Server节点。这说明，如果备份数为3，那么延迟取决于两个备份节点中较快的节点。</p>
<p>有很多类似的算法变体，例如ZooKeeper的Zab，Raft,Viewstamped Replication等。和Kafka最相似的学术刊物是微软的PacificA。</p>
<p>大多数选票方式的取消是它不能容忍很多的故障，导致你没有可以被选为新Leader的节点。为了容忍一个节点故障，需要3分数据备份，容忍两个节点故障则需要5个节点。在我们的经验中，只有足够的冗余才能容忍单一的故障在实际系统中是不够的，每次写5次副本，使用5倍的存储空间，和1/5的带宽，在大体量的数据存储上不是很可行。这就是为什么quorum算法多多应用在像ZK这样存储配置的集群中，而不是数据存储系统中。例如HDFS的namenode的高可用建立在大多数选票的机制上，但是数据存储缺不是。</p>
<p>Kafka使用一个明显不同的方式来选择quorum集合。代替大多数选票，Kafka动态的维护一个“同步的备份（in-sync replicas ISR）”的集合。只有这个集合中的成员能被选举为Leader。一个写入请求需要同步到所有的同步中的备份才能认为是提交的。ISR集合在变更时会被持久化到ZK。因此，任何ISR中的备份都可以被选举为新的Leader。这对于Kafka这种拥有多分区并且需要保证这节点负载均衡的模型来说非常重要。使用ISR模型和f+1个副本，Kafka可以容忍f个备份不可用的情况。</p>
<p>对于大多数的场景，我们认为这样的妥协是合理的。在实践中，为了容忍f个节点故障，大多数选票原则和ISR方式都需要等待相同的备份在提交消息前进行确认（如需要容忍一个节点故障，大多数选票的选择需要3个节点，并且提交消息需要至少一个备份的确认；ISR只需要两个节点，需要确认的副本数一样是一个）。相对于大多数选票的原则，ISR方式不需要等待最慢的服务器确认消息是一个优势。尽管如此，我们进行改善，让客户端决定是否等待消息提交，使用较小的副本数，这样带来的吞吐和更小的磁盘空间要求是有价值的。</p>
<p>另一个重要的设计是Kafka不需要故障的节点恢复所有的数据。这是不常见的，复制算法依赖于存储介质在任何故障的情况下都不丢失数据并且不违反一致性原则。这个假设有两个主要的问题。第一，磁盘故障是持久化数据系统中最常见的问题，并且它通常导致数据不完整。第二，即使这不是一个问题，我们也不希望在每一次写入之后都使用fsync来保证一致性，这会使性能下降两三个数量级。我们的协议中允许一个副本重新加入到ISR集合中，在重新加入之前，它需要从新同步在故障时丢失的数据。</p>
<p>Unclean leader election: What if they all die?</p>
<p>Kafka保证的数据不丢失，在至少有一个备份保持同步的情况下。如果一个分区所有的备份的节点都故障，那么就不能提供这个保障了。</p>
<p>但是实践系统中需要一些合理的事情，在所有备份故障时。如果不巧遇上这个问题，去考虑哪些情况会发生是非常重要的。有两种方式去做：</p>
<p>等待一个ISR中的副本恢复并将其选举为新的Leader（期望它拥有所有的数据）。<br>选择第一个副本（无需在ISR中）作为Leader。<br>这是在可用性和一致性之间的权衡。如果我们等待ISR中的备份恢复，那么会在这个期间一直不可用。如果这样的副本被损坏，那么我们将永久性的失效。另一方便，如果使用不在ISR中的备份成为Leader，尽管它可能不包含所有的日志。默认情况下，Kafka使用第二种策略，当所有ISR中的备份不可用时，倾向于选择可能不一致的备份。这个方式可以通过unclean.leader.election.enable配置禁用，在哪些停机时间优于不一致的场景。</p>
<p>这种困境不是kafka特有的, 这存在于任何基于quorum方式的结构中. 例如, 多数投票算法, 如果大多数的服务器都永久性失效了, 你必须选择丢失全部的数据或者接受某一台可能数据不一致的服务器上的数据.</p>
<p>Availability and Durability Guarantees</p>
<p>在向Kafka写入数据时，Producer可以选择是否等待0，1或（-1）个备份响应。注意，这里说的“被所有备份响应”不是说被所有分配的备份响应，默认情况下只的时所有ISR集合中的备份响应。例如，如果一个Topic配置成只需要两个备份，并且一个备份故障了，那么写入一个备份即认为收到了所有响应。但是，如果这个备份也故障了，那么数据会丢失。这样保证了分区的最大可用，但是可能不是那些相对于可用性更需要可靠性的用户的需求。因此，我们提供两种Topic级别的配置，相对于可用性，优先保证可靠性：</p>
<p>禁用unclean leader election；如果所有备份不可用，那么分区保持不可用，直到最近的Leader重新恢复可用。这可能导致不可用，但是不会丢失数据。</p>
<p>配置一个最小的ISR大小；分区只会在满足最小ISR的情况下接受请求，这样可以避免数据只写入一个备份，而这个备份后续故障导致数据丢失。这个配置只在Producer使用acks=all的配置时有效。这个配置在一致性和可用性上做了权衡。更大的ISR提供了更好的一致性，但是降低了可用性，如果同步备份数小于最小ISR配置时将不可用。</p>
<p>Replica Management</p>
<p>以上的讨论都是基于一个日志，即一个Topic的分区考虑的。但是Kafka集群拥有成百上千这样的分区。我们尝试使用轮训的方式来平衡分区，避免高数量的Topic的分区集中在一部分少量的节点上。同样我们要平衡所有Leader分区，这样每个节点上承载的主分区都有一定的比例。</p>
<p>优化Leader的选举过程也是非常重要的，因为这是系统不可用的窗口期。一个直观的实现是，如果一个节点故障了，为这个节点上所有的分区都独立的执行一次选举。代替这种方式，我们选择一个Broker作为Controller，Controller负责一个故障节点影响的所有分区的Leader变更。这样的好处是我们可以批量处理，减少独立选举时大量的通知，这使得大量分区需要选举时变得更快，代价更小。如果Controller故障了，剩余的Broker中会有一个节点成为新的Controller。</p>
<h3 id="Log-Compaction"><a href="#Log-Compaction" class="headerlink" title="Log Compaction"></a>Log Compaction</h3><p>日志压缩确保Kafka会为一个Topic分区数据日志中保留至少message key的最后一个值。它解决了应用crash或系统故障或应用在操作期间重启来重新加载缓存的场景。让我们深入到细节中解释日志压缩是如何工作的。</p>
<p>到屋面位置，我们只说明了在一断时间或达到特定大小的时候丢弃就日志的简单方法。这适用于想日志这样每一条数据都是独立数据的情况。但是重要类别的数据是根据key处理的数据（例如DB中表的变更数据）。</p>
<p>让我们来讨论这样一个具体的流的例子。一个Topic包含了用户email address信息；每一次用户变更邮箱地址，我们都像这个topic发送一条消息，使用用户ID作为primay key。现在我们已经为用户ID为123的用户发送了一些消息，每条消息包含了email address的变更：</p>
<blockquote>
</blockquote>
<p>123 =&gt; <a href="mailto:bill@microsoft.com" target="_blank" rel="noopener">bill@microsoft.com</a><br>123 =&gt; <a href="mailto:bill@gatesfoundation.org" target="_blank" rel="noopener">bill@gatesfoundation.org</a><br>123 =&gt; <a href="mailto:bill@gmail.com" target="_blank" rel="noopener">bill@gmail.com</a></p>
<p>日志压缩为我们提供了更精细的保留机制，至少保存每个key最后一个变更（如123 =&gt; <a href="mailto:bill@gmail.com" target="_blank" rel="noopener">bill@gmail.com</a>）。这样做我们确保了这个日志包含了所有key最后一个值的快照。这样Consumer可以重建状态而不需要保留完成的变更日志。</p>
<p>让我们列一些日志压缩有用的场景，然后看他是如果被使用的。</p>
<ol>
<li><p>DB变更订阅。这是很常见的，一个数据在多个数据系统中，而且其中一个系统是数据库类型的（如RDBMS或KV系统）。例如可能有一个数据库，一个户缓存系统，一个搜索集群，一个Hadoop集群。DB的任何一个变更需要反映到缓存、搜索集群，最终保存到Hadoop中。在这个场景中，你只需要实时系统最新的更新日志。但是如果需要重新加载缓存或恢复宕机的检索节点，就需要完整的数据。</p>
</li>
<li><p>事件源。这是一种应用设计风格，它将查询处理和应用程序设计结合到一起，并使用日志作为程序的主要存储。</p>
</li>
<li><p>高可用日志。一个本地集成程序可以通过变更日志来做到容错，这样另一个程序能够在当前程序故障时继续处理。例如, 像流数据查询例子, 如计数, 汇总或其他的分组操作. 实时系统框架如Samza, 就是为了达到这个目的使用这个特性的。</p>
</li>
</ol>
<p>在这些场景中，主要处理实时的变更，但有时需要重新加载或重新处理时，需要加载所有数据。日志压缩允许使用相同的Topic来支持这些场景，这种日志使用风格在后续的内容中会更详细的描述。</p>
<p>想法很简单，我们有有无限的日志，以上每种情况记录变更日志，我们从一开始就捕获每一次变更。使用这个完整的日志，我们可以通过回放日志来恢复到任何一个时间点的状态。这种假设的情况下，完整的日志是不实际的，对于那些每一行记录会变更多次的系统，即使数据集很小，日志也会无限的增长下去。丢弃旧日志的简单操作可以限制空间的增长，但是无法重建状态——因为旧的日志被丢弃，可能一部分记录的状态会无法重建（这写记录所有的状态变更都在就日志中）。</p>
<p>日志压缩机制是更细粒度的，每个记录都保留的机制，而不是基于时间的粗粒度。这个想法是选择性的删除哪些有更新的变更的记录的日志。这样最终日志至少包含每个key的记录的最后一个状态。</p>
<p>这个策略可以为每个Topic设置，这样一个集群中，可以一部分Topic通过时间和大小保留日志，另外一些可以通过压缩保留。</p>
<p>这个功能的灵感来自于LinkedIn的最古老且最成功的基础设置——一个称为Databus的数据库变更日志缓存系统。不想大多数的日志存储系统，Kafka为了订阅而量身打造，用于线性的快速读写。和Databus不同，Kafka作为真实的存储，压缩日志是非常有用的，在上有数据源不能重放的情况下。</p>
<h4 id="Log-Compaction-Basics"><a href="#Log-Compaction-Basics" class="headerlink" title="Log Compaction Basics"></a>Log Compaction Basics</h4><p>这里是一个展示Kafka日志的逻辑结构的图（每条消息包含了一个offset）：<br><img src="/img/15042400214438.jpg" alt></p>
<p>Log head中包含传统的Kafka日志。它包含了连续的连续的offset和所有的消息。日志压缩增加了处理tail Log的选项。上图展示了日志压缩的的Log tail的情况。tail中的消息保存了初次写入时的offset。即使该offset的消息被压缩，所有offset仍然在日志中是有效的。在这个场景中，无法区分和下一个出现的更高offset的位置。如上面的例子中，36、37、38是属于相同位置的，从他们开始读取日志都将从38开始。</p>
<p>压缩允许删除。一条消息伴随着空的值被认为从日志中删除。这个删除标记将会引起所有之前拥有相同key的消息被移除（包括拥有key相同的新消息），但是删除标记比较特殊，它将在一定周期后被从日志中删除来示范空间。这个时间点被称为“delete retention point”。</p>
<p>压缩操作通过在后台周期性的拷贝日志段来完成。清除操作不会阻塞读取，并且可以被配置不超过一定IO吞吐来避免影响Producer和Consumer。实际的日志段压缩过程有点像如下：<br><img src="/img/15042400375238.jpg" alt></p>
<h4 id="What-guarantees-does-log-compaction-provide"><a href="#What-guarantees-does-log-compaction-provide" class="headerlink" title="What guarantees does log compaction provide?"></a>What guarantees does log compaction provide?</h4><p>日志压缩提供了如下的保证：</p>
<ol>
<li><p>所有跟上消费的Consumer能消费到所有写入的消息；这些消息有连续的序列号。Topic的min.compaction.lag.ms可以用于保证消息写入多久后才会被压缩。这限制了一条消息在Log Head中的最短存在时间。</p>
</li>
<li><p>消息的顺序会被保留。压缩不会重排序消息，只是移除其中一部分。</p>
</li>
<li><p>消息的Offset不会变更。这是消息在日志中的永久标志。</p>
</li>
<li><p>任何从头开始处理日志的Consumer至少会拿到每个key的最终状态。另外，只要Consumer在小于Topic的delete.retention.ms设置（默认24小时）的时间段内到达Log head，将会看到所有删除记录的所有删除标记。换句话说，因为移除删除标记和读取是同事发生的，Consumer可能会因为落后超过delete.retention.ms而导致错过删除标记。</p>
</li>
</ol>
<h4 id="Log-Compaction-Details"><a href="#Log-Compaction-Details" class="headerlink" title="Log Compaction Details"></a>Log Compaction Details</h4><p>日志压缩由Log Cleaner执行，后台线程池重新拷贝日志段，移除那些key存在于Log Head中的记录。每个压缩线程如下工作：</p>
<ol>
<li>选择Log Head相对于Log Head在日志中占更高比例的日志</li>
<li>创建Log Head中每个Key最后一个offset的摘要</li>
<li>从头到尾的拷贝日志，并删除之后日志终于到相同key的记录。新的、干净的日志将会立即被交到到日志中，所以只需要一个额外的日志段空间</li>
<li>Log Head的摘要实际上是一个空间紧凑的哈希表。每个条目使用24个字节。所以如果有8G的整理缓冲区, 则能迭代处理大约366G的日志头部(假设消息大小为1k)。<h4 id="Configuring-The-Log-Cleaner"><a href="#Configuring-The-Log-Cleaner" class="headerlink" title="Configuring The Log Cleaner"></a>Configuring The Log Cleaner</h4></li>
</ol>
<p>Log Cleaner默认启用。这会启动清理的线程池。如果要开始特定Topic的清理功能，可以开启特定的属性：</p>
<blockquote>
</blockquote>
<p>log.cleanup.policy=compact</p>
<p>这个可以通过创建Topic时配置或者之后使用Topic命令实现。</p>
<p>Log Cleaner可以配置保留最小的不压缩的日志头。可以通过配置压缩的延迟时间：</p>
<blockquote>
</blockquote>
<p>log.cleaner.min.compaction.lag.ms</p>
<p>这可以用于保证消息比在被压缩的消息大一段时间。如果没有设置，除了最后一个日志外，所有的日志都会被压缩。当前写入的自如端不会被压缩，即使所有的消息都落后于比配置的最小压缩时间。</p>
<p>更多的配置在<a href="http://kafka.apache.org/documentation.html#brokerconfigs" target="_blank" rel="noopener">这里</a></p>
<h3 id="Quotas"><a href="#Quotas" class="headerlink" title="Quotas"></a>Quotas</h3><p>从0.9版本开始，Kafka可以对生产和消费请求进行限额配置。基于字节速率来限制，每个group中所有的客户端共享一个限额。</p>
<h4 id="Why-are-quotas-necessary"><a href="#Why-are-quotas-necessary" class="headerlink" title="Why are quotas necessary?"></a>Why are quotas necessary?</h4><p>Producer和Consumer可能生产或消费大量的数据而耗尽Broker的资源，导致网络饱和。进行限额可以避免这些问题，特别是在多租户的集群中，一小部分低质量的客户端会降低整个集群的体验。实际上，当运行Kafka作为服务时，这还可以对API的使用进行限制。</p>
<h4 id="Client-groups"><a href="#Client-groups" class="headerlink" title="Client groups"></a>Client groups</h4><p>Kafka客户端的身份代表了用于鉴权。 在无鉴权机制的集群中, 用户身份是由服务器使用可配置的PrincipalBuilder进行选择的, Client-id作为客户端逻辑分组, 是由客户端应用选择的一个有意义的名称. 标量(user, client-id)定义共享这个用户身份和客户端ID的逻辑客户端分组.</p>
<p>配额可以用于(user, client-id)组合, 或user, client-id分组。</p>
<p>对一个给定的连接, 最符合这个连接的配额被使用到, 一个限额组的所有连接共享这个限额配置, 例如: 如果(user=”test-user”, client-id=”test-client”) 10MB/s的配额, 这个配置会被所有的具有”test-user”用户和客户端ID是 “test-client”的所有生产者所共享.</p>
<h4 id="Quota-Configuration"><a href="#Quota-Configuration" class="headerlink" title="Quota Configuration"></a>Quota Configuration</h4><p>配额可以按照(user, client-id)或者, user或client-id进行分组, 如果需要更高或更低的配额, 可以覆盖默配额, 这个机制类似于对日志主题配置的覆盖, user 或者 (user, client-id)配额可以覆盖写入到zookeeper下的 /config/users ,client-id配置, 可以写入到 /config/clients。这些覆盖写入会被服务器很快的读取到, 这让我们修改配置不需要重新启动服务器. 每个分组的默认配置也可以同样的方式动态修改。</p>
<p>限额的配置顺序如下:</p>
<ol>
<li>/config/users//clients/</li>
<li>/config/users//clients/</li>
<li>/config/users/</li>
<li>/config/users//clients/</li>
<li>/config/users//clients/</li>
<li>/config/users/</li>
<li>/config/clients/</li>
<li>/config/clients/<br>Broker的quota.producer.default，quota.consumer.default也可以用来配置默认的client-id分组的默认值。这可属性已经不鼓励使用，后续将会删除。默认client-id限额配置可以和其它默认配置一样, 在Zookeeper直接设置。</li>
</ol>
<h4 id="Enforcement"><a href="#Enforcement" class="headerlink" title="Enforcement"></a>Enforcement</h4><p>默认情况下，每个唯一的客户端group会收到一个集群配置的固定的限额。这个限额是基于每个Broker的。每个客户端能发布或获取在每台服务器都的最大速率, 我们按服务器定义配置, 而不是按整个集群定义,是因为如果是集群范围的需要额外的机制来共享配额的使用情况, 这会导致配额机制的实现比较难。</p>
<p>Broker检测到限额违规时时如何处理的？在我们的解决方案中，Broker不会返回错误给客户端，而是降低客户端的速率。Broker计算使客户端回到合理限额的需要的响应延迟。这种方法的处理对客户端是透明，使他们不必执行任何棘手的，特殊的操作。实际上，错误的客户端还可能加剧正在解决的限额问题。</p>
<p>客户端字节率在多个小窗口（例如每个1秒的30个窗口）上进行测量，以便快速检测和纠正配额违规。 通常，具有大的测量窗口（例如，每个30秒的10个窗口）导致大量的流量脉冲，随后是长时间的延迟，这在用户体验方面不是很好。</p>
<blockquote>
</blockquote>
<p>文章摘自：<a href="http://www.cnblogs.com/hzmark/p/kafka_design.html" target="_blank" rel="noopener">http://www.cnblogs.com/hzmark/p/kafka_design.html</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.cnblogs.com/hzmark/p/kafka_design.html" target="_blank" rel="noopener">http://www.cnblogs.com/hzmark/p/kafka_design.html</a><br><a href="https://kafka.apache.org/documentation/" target="_blank" rel="noopener">https://kafka.apache.org/documentation/</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka官方文档翻译--简介</title>
    <url>/2017/04/21/Kafka%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91--%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>Kafka擅长于做什么？</p>
<p>它被用于两大类应用：</p>
<ol>
<li>在应用间构建实时的数据流通道</li>
<li>构建传输或处理数据流的实时流式应用<a id="more"></a>
</li>
</ol>
<p>几个概念：</p>
<p>Kafka以集群模式运行在1或多台服务器上<br>Kafka以topics的形式存储数据流<br>每一个记录包含一个key、一个value和一个timestamp.</p>
<p>Kafka有4个核心API：</p>
<p>Producer API：用于应用程序将数据流发送到一个或多个Kafka topics<br>Consumer API：用于应用程序订阅一个或多个topics并处理被发送到这些topics中的数据<br>Streams API：允许应用程序作为流处理器，处理来自一个或多个topics的数据并将处理结果发送到一个或多个topics中，有效的将输入流转化为输出流<br>Connector API：用于构建和运行将Kafka topics和现有应用或数据系统连接的可重用的produers和consumers。例如，如链接到关系数据库的连接器可能会捕获某个表所有的变更<br><img src="/img/15042372711680.jpg" alt><br>Kafka客户端和服务端之间的通信是建立在简单的、高效的、语言无关的TCP协议上的。此协议带有版本且向后兼容。我们为Kafka提供了Java客户端，但是客户端可以使用多种语言。</p>
<h2 id="Topics-and-Logs"><a href="#Topics-and-Logs" class="headerlink" title="Topics and Logs"></a>Topics and Logs</h2><p>Topic是发布记录的类别。Kafka中的Topics一般是多订阅者的，也就是一个Topic可以有0个或多个Consumer订阅它的数据。</p>
<p>对于每个主题，Kafka会会维护一个如下所示的分区日志：<br><img src="/img/15042374175690.jpg" alt></p>
<p>每个分区是一个有序的，以不可变的记录顺序追加的Commit Log。分区中的每个记录都有一个连续的ID，称为Offset，唯一标识分区内的记录。</p>
<p>Kafka集群使用记录保存时间的配置来保存所有已发布的记录（无论他们是否被消费）。例如，配置策略为两天，那么在一条记录发布两天内，这条记录是可以被消费的，之后将被丢弃以腾出空间。Kafka的性能和数据量无关，所以存储长时间的数据并不会成为问题。<br><img src="/img/15042374457050.jpg" alt></p>
<p>实际上唯一需要保存的元数据是消费者的消费进度，即消费日志的偏移量（Offset）。这个Offset是由Consumer控制的：通常消费者会在读取记录时以线性方式提升Offset，但是事实上，由于Offset由Consumer控制，因此它可以以任何顺序消费记录。例如一个Consumer可以通过重置Offset来处理过去的数据或者跳过部分数据。</p>
<p>这个特征意味着Kafka的Consumer可以消费“过去”和“将来”的数据而不对集群和其他Consumer不造成太大的影响。例如，可以使用命令行工具tail来获取Topic尾部的内容而不对已经在消费Consumer造成影响。</p>
<p>分区日志有几个目的。第一，使服务器能承载日志的大小，每个分区的日志必须可以被保存在单个服务器上，但是一个Topic可以拥有多个分区，那么它可以处理任意大小的数据量。第二，它们作为并行度的单位（更多的是这点的考虑）。</p>
<h2 id="Distribution"><a href="#Distribution" class="headerlink" title="Distribution"></a>Distribution</h2><p>分区日志分布在集群中服务器中，每个服务器处理一部分分区的数据和请求。每个分区可以配置分布的服务器，以实现容错。</p>
<p>每个分区拥有一个Leader节点，和零或多个Follower。Leader处理该分区所有的读写请求，Follower复制Leader数据。如果Leader节点宕机，将会有一个Follower节点自动的转化为Leader。每个节点成为其部分分区的Leader，并成为剩余分区的Follower，这样整个集群的负载将比较均衡。</p>
<h2 id="Producers"><a href="#Producers" class="headerlink" title="Producers"></a>Producers</h2><p>Producer发送数据到它选择的Topic。Producer负责决定将数据发送到Topic的那个分区上。这可以通过简单的循环方式来平衡负载，或则可以根据某些语义来决定分区（例如基于数据中一些关键字）。</p>
<h2 id="Consumers"><a href="#Consumers" class="headerlink" title="Consumers"></a>Consumers</h2><p>Consumer使用一个group name来标识自己的身份，每条被发送到一个Topic的消息都将被分发到属于同一个group的Consumer的一个实例中（group name相同的Consumer属于一个组，一个Topic的一条消息会被这个组中的一个Consumer实例消费）。Consumer实例可以在单独的进程中或者单独的机器上。</p>
<p>如果所有的Consumer实例都是属于一个group的，那么所有的消息将被均衡的分发给每个实例。</p>
<p>如果所有的Consumer都属于不同的group，那么每条消息将被广播给所有的Consumer。<br><img src="/img/15042374736944.jpg" alt></p>
<p>（上图）一个包含两个Server的Kafka集群，拥有四个分区（P0-P3），有两个Consumer group：Group A和Group B。Group有C1、C2两个Consumer，GroupB有C3、C4、C5、C6四个Consumer。</p>
<p>更常见的是，Topic有少量的Consumer group，每一个都是“一个逻辑上的订阅者”。每个group包含多个Consumer实例，为了可伸缩性和容错性。这就是一个发布-订阅模式，只是订阅方是一个集群。</p>
<p>Kafka中消费的实现方式是“公平”的将分区分配给Consumer，每一个时刻分区都拥有它唯一的消费者。Consumer成员关系有Kafka程度动态维护。如果新的Consumer加入了分区，那么它会从这个分区其他的Consumer中分配走一部分分区；如果部分Consumer实例宕机，它的分区会被其他Consumer实例接管。</p>
<p>Kafka只保证同一个分区内记录的顺序，而不是同一个Topic的不同分区间数据的顺序。每个分区顺序结合按Key分配分区的能力，能满足大多数程序的需求。如果需要全局的顺序，可以使用只有一个分区的Topic，这意味着每个group只能有一个Consumer实例（因为一个分区同一时刻只能被一份Consumer消费——多加的Consumer只能用于容错）。</p>
<h2 id="Guarantees"><a href="#Guarantees" class="headerlink" title="Guarantees"></a>Guarantees</h2><p>Kafka高级API中提供一些能力：</p>
<p>被一个Producer发送到特定Topic分区的消息将按照他们的发送顺序被添加到日志中。这意味着，如果M1、M2是被同一个Producer发送出来的，且M1先发送，那么M1拥有更小的Offset，在日志中的位置更靠前。</p>
<p>Consumer按照消息的存储顺序在日志文件中查找消息。</p>
<p>对于复制配置参数为N的Topic，我们能容忍N-1的服务器故障，而不会丢失已经Commit的数据。有关这些保证更详细的信息，参见文档的设计部分。</p>
<h2 id="Kafka-as-a-Messaging-System"><a href="#Kafka-as-a-Messaging-System" class="headerlink" title="Kafka as a Messaging System"></a>Kafka as a Messaging System</h2><p>Kafka的流模式和传统的消息系统有什么区别？</p>
<p>消息传统上有两种模式：队列和发布-订阅。在队列中，一群Consumer从一个Server读取数据，每条消息被其中一个Consumer读取。在发布-订阅中，消息被广播给所有的Consumer。这两种模式有各自的优缺点。队列模式的优点是你可以在多个消费者实例上分配数据处理，从而允许你对程序进行“伸缩”。确定是队列不是多用户的，一旦消息被一个Consumer读取就不会再给其他Consumer。发布订阅模式允许广播数据到多个Consumer，那么就没办法对单个Consumer进行伸缩。</p>
<p>Kafka的Consumer group包含两个概念。与队列一样，消费组允许通过一些进程来划分处理（每个进程处理一部分）。与发布订阅一样，Kafka允许广播消息到不同的Consumer group。</p>
<p>Kafka模式的优势是每个Topic都拥有队列和发布-订阅两种模式。</p>
<p>Kafka比传统的消息系统有更强的顺序保证。</p>
<p>传统的消息系统在服务器上按顺序保存消息，如果多个Consumer从队列中消费消息，服务器按照存储的顺序输出消息。然后服务器虽然按照顺序输出消息，但是消息将被异步的传递给Consumer，所以他们将以不确定的顺序到达Consumer。这意味着在并行消费中将丢失消息顺序。传统消息系统通常采用“唯一消费者”的概念只让一个Consumer进行消费，但这就丢失了并行处理的能力。</p>
<p>Kafka做的更好一些。通过提供分区的概念，Kafka能提供消费集群顺序和负载的平衡。这是通过将分区分配个一个Consumer group中唯一的一个Consumer而实现的，一个分区只会被一个分组中的一个Consumer进行消费。通过这么实现，能让一个Consumer消费一个分区并按照顺序处理消息。因为存在多个分区，所有可以在多个Consumer实例上实现负载均衡。注意，一个分组内的Consumer实例数不能超过分区数。</p>
<h2 id="Kafka-as-a-Storage-System"><a href="#Kafka-as-a-Storage-System" class="headerlink" title="Kafka as a Storage System"></a>Kafka as a Storage System</h2><p>任何将发送消息和消费结构的消息队列都有效的用作一个消息的存储系统。不同的是Kafka是一个更好的存储系统。</p>
<p>被写入到Kafka的数据将被写入磁盘并复制以保证容错。Kafka允许Producer等待确定，以保证Producer可以确认消息被成功持久化并复制完成。</p>
<p>Kafka使用的存储结构，使其提供相同的能力，无论是存储50KB或者50TB持久化数据。</p>
<p>因为允许客户端控制读取的位置，可以将Kafka视为高性能，低延迟的日志存储、复制、传播的分布式系统。</p>
<h2 id="Kafka-for-Stream-Processing"><a href="#Kafka-for-Stream-Processing" class="headerlink" title="Kafka for Stream Processing"></a>Kafka for Stream Processing</h2><p>仅仅是读写和存储流数据是不够的，Kafka的目标是对流失数据的实时处理。</p>
<p>在Kafka中，Stream Producer从输入的Topic中读取数据，执行一些操作，生成输出流到输出的Topic中。</p>
<p>例如，零售的应用程序将收到销售和出货的输入流，并输出根据该数据计算的重排序和价格调整后的数据流。</p>
<p>可以使用Producer和Consumer实现简单的处理。对于更复杂的转换，Kafka提供的完成的Stream API，允许构建将流中数据聚合或将流连接到一起的应用。</p>
<p>这用于解决以下的一些困难：处理无需的数据，执行有状态的计算等。</p>
<p>Stream API基于Kafka的核心函数构建：使用Producer和Consumer API用于输入，使用Kafka作为有状态的存储，使用group机制来实现Stream处理器的容错。</p>
<h2 id="Putting-the-Pieces-Together"><a href="#Putting-the-Pieces-Together" class="headerlink" title="Putting the Pieces Together"></a>Putting the Pieces Together</h2><p>消息、存储和流处理这种组合看是不寻常，但是Kafka作为流式平台这是必须的。</p>
<p>类似HDFS的分布式文件系统存储静态的文件用于批处理。这种的系统允许存储和处理历史数据。</p>
<p>传统的企业消息系统允许处理在你订阅之后的未来的数据。以这种方式构建的应用程序在未来数据到达时进行处理。</p>
<p>Kafka组合这些能力，并且组合这些对Kafka作为流应用平台和流数据通道至关重要。</p>
<p>通过组合存储和低延迟的订阅，流应用程序能以相同的方式处理过去和未来的数据。一个单一的程序可以处理过去的历史数据，并且不会在达到一个位置时停止，而是能继续处理将来到达的数据。这是一个广泛的流处理的概念，其中包含批处理和消息驱动的应用程序。</p>
<p>同样，对于数据流通道，组合订阅机制和实时事件使Kafka成为非常低延迟的管道；数据的存储能力使其能和可能会进行停机维护的周期性处理数据的离线系统集成，或用于必须保证数据被确认交付的场景。流处理程序可以在数据到达后进行处理。</p>
<p>其他关闭Kafka提供的API、功能，参阅其他文档。</p>
<blockquote>
<p>出处：<a href="http://www.cnblogs.com/hzmark/p/kafka_introduction.html" target="_blank" rel="noopener">http://www.cnblogs.com/hzmark/p/kafka_introduction.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>ZSH 安装</title>
    <url>/2017/03/29/ZSH-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>介绍下比较好用的zsh安装以及相关的配置</p>
<a id="more"></a>
<h2 id="安装iTerm2"><a href="#安装iTerm2" class="headerlink" title="安装iTerm2"></a>安装iTerm2</h2><p>iTerm2官方下载地址 <a href="http://www.iterm2.com/downloads.html" target="_blank" rel="noopener">http://www.iterm2.com/downloads.html</a></p>
<h2 id="安装Oh-My-Bash"><a href="#安装Oh-My-Bash" class="headerlink" title="安装Oh My Bash"></a>安装Oh My Bash</h2><ol>
<li>通过cat /etc/shells命令可以查看当前系统可以使用哪些shell；<ul>
<li>/bin/bash</li>
<li>/bin/csh</li>
<li>/bin/ksh</li>
<li>/bin/sh</li>
<li>/bin/tcsh</li>
<li>/bin/zsh</li>
</ul>
</li>
<li><p>通过echo $SHELL命令可以查看我们当前正在使用的shell；</p>
<ul>
<li>Mac系统中默认的shell为bash shell</li>
<li>/bin/bash</li>
</ul>
</li>
<li><p>如果当前的shell不是zsh，我们可以通过chsh -s /bin/zsh命令可以将shell切换为shell之zsh，终端重启之后即可生效。</p>
</li>
<li><p>将shell切换为zsh之后，我们就可以安装Oh My ZSH了<br>官方推荐的安装方法为：</p>
</li>
</ol>
<p>sh -c “$(curl -fsSL <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;" target="_blank" rel="noopener">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</a></p>
<p>记住，爱翻墙的童鞋记得先关闭代理哦，不然没法下载成功的<br>出线以下提示，便是安装成功了^_^<br><img src="/img/15301540285993.jpg" alt></p>
<h2 id="配置agnoster主题"><a href="#配置agnoster主题" class="headerlink" title="配置agnoster主题"></a>配置agnoster主题</h2><p>Oh My Zsh提供的所有主题在线预览：<br><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a></p>
<p>安装成功之后，我们可以通过vi ~/.zshrc，设置ZSH_THEME=”agnoster”对主题进行修改。</p>
<p>注意，agnoster主题能否设置成功，还依赖于以下东西：</p>
<ol>
<li><p>Solarized Dark配色方案<br>下载完成之后解压，在iTerm2的Preferences——Profiles——colors——Load Presets——Solarized Dark即可设置终端配色</p>
</li>
<li><p>特殊字体安装<br>下载完成之后解压，执行其中的install.sh文件，在iTerm2的Preferences——Profiles——Text中同时将Regular Font和Non—ASCII Font设置为Meslo LG M DZ Regular for Powerline即可</p>
</li>
</ol>
<h2 id="主题列表"><a href="#主题列表" class="headerlink" title="主题列表"></a>主题列表</h2><p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/themes</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>ZSH</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ概述</title>
    <url>/2017/02/05/RabbitMQ%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>mac上安装rabbitmq比较简单，参考官网教程 <a href="http://www.rabbitmq.com/install-standalone-mac.html" target="_blank" rel="noopener">http://www.rabbitmq.com/install-standalone-mac.html</a> 即可。遇到了下载很慢问题，找了其他网站上下。</p>
<p>其他系统安装方式在官网也有详细描述，不再累述。</p>
<a id="more"></a>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li>查找默认配置位置：find / -name “rabbitmq.config.example”，我这边搜索结果是：/usr/share/doc/rabbitmq-server-3.6.1/rabbitmq.config.example</li>
<li>复制默认配置：cp /usr/share/doc/rabbitmq-server-3.6.1/rabbitmq.config.example /etc/rabbitmq/</li>
<li>修改配置文件名：cd /etc/rabbitmq ; mv rabbitmq.config.example rabbitmq.config</li>
<li>开启 Web 界面管理：rabbitmq-plugins enable rabbitmq_management</li>
<li>重启 RabbitMQ 服务：service rabbitmq-server restart</li>
<li>开放防火墙端口：<ul>
<li>sudo iptables -I INPUT -p tcp -m tcp –dport 15672 -j ACCEPT</li>
<li>sudo iptables -I INPUT -p tcp -m tcp –dport 5672 -j ACCEPT</li>
<li>sudo service iptables save</li>
<li>sudo service iptables restart</li>
</ul>
</li>
<li>浏览器访问：<a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a> 默认管理员账号：guest 默认管理员密码：guest</li>
</ol>
<p>参考<a href="https://github.com/judasn/Linux-Tutorial/blob/master/RabbitMQ-Install-And-Settings.md" target="_blank" rel="noopener">https://github.com/judasn/Linux-Tutorial/blob/master/RabbitMQ-Install-And-Settings.md</a></p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>简单来说就是消息队列服务器</p>
<h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>消息交换机，服务器中的实体，用来接收生产者发送的消息并将这些消息路由给服务器中的队列</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>消息队列载体，用来保存消息直到发送给消费者，每个消息都会被投入到一个或多个队列</p>
<h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p>绑定器，它的作用就是把exchange和queue按照路由规则绑定起来</p>
<h3 id="Binding-Key"><a href="#Binding-Key" class="headerlink" title="Binding Key"></a>Binding Key</h3><p>绑定关键字，Exchange视自身类型来决定Binding的路由行为</p>
<h3 id="Routing-Key"><a href="#Routing-Key" class="headerlink" title="Routing Key"></a>Routing Key</h3><p>消息的路由关键字，Exchange根据这个关键字决定如何路由某条消息</p>
<h3 id="vhost"><a href="#vhost" class="headerlink" title="vhost"></a>vhost</h3><p>虚拟主机，一批交换器、消息队列和相关对象，虚拟主机是共享相同的身份认证和加密环境的独立服务器域，一个broker里可以开设多个vhost，用作不同用户的权限分离</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>多路复用连接中的一条独立的双向数据流通道，为会话提供物理传输介质，在客户端的每个连接里，可建立多个channel</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消费者，一个从消息队列中请求消息的客户端应用程序</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>生产者，一个向交换器发布消息的客户端应用程序</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/img/15255306886088.jpg" alt></p>
<ol>
<li>消息生产者将消息发布(Public)到 Exchange 中.</li>
<li>Exchange 根据队列的绑定关系将消息分发到不同的 Queue 中.</li>
<li>AMQP broker 根据订阅规则将消息发送给消费者 或 消费者自行根据需要从消息队列中获取消息.</li>
</ol>
<p>Message是当前模型中所操纵的基本单位，它由Producer产生，经过Broker被Consumer所消费。它的基本结构有两部分: Header和Body。Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。Body是真正需要传送的数据，它是对Broker不可见的二进制数据流，在传输过程中不应该受到影响。</p>
<h2 id="Exchange-和-Exchange-类型"><a href="#Exchange-和-Exchange-类型" class="headerlink" title="Exchange 和 Exchange 类型"></a>Exchange 和 Exchange 类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>默认预定义的名字</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct Exchange</td>
<td>空字符串和 amq.direct</td>
</tr>
<tr>
<td>Fanout Exchange</td>
<td>amq.fanout</td>
</tr>
<tr>
<td>Topic Exchange</td>
<td>amq.topic</td>
</tr>
<tr>
<td>Headers Exchange</td>
<td>amq.match(在 RabbitMQ 中, 额外提供amq.headers)</td>
</tr>
</tbody>
</table>
<h3 id="关于默认-Exchange"><a href="#关于默认-Exchange" class="headerlink" title="关于默认 Exchange"></a>关于默认 Exchange</h3><p>默认的 exchange 是一个由 broker 预创建的匿名的(即名字是空字符串) direct exchagne. 对于简单的程序来说, 默认的 exchange 有一个实用的属性: 如果没有显示地绑定 Exchnge, 那么创建的每个 queue 都会自动绑定到这个默认的 exchagne 中, 并且此时这个 queue 的 route key 就是这个queue 的名字.</p>
<p>例如当我们声明了一个名为 “search-indexing-online” 的 queue, 那么 AMQP broker 会以 “search-indexing-online” 作为 route key 将此 queue 绑定到默认的 exchange 中. 因此当一个消息以 route key 为 “search-indexing-online” 投递到默认的 exchange 中时, 此消息就会被路由到这个 queue 中去. 换句话说, 由于有默认的 exchagne 的存在, 我们就好像可以直接将消息投递到指定的 queue 中去而不需要经过 exchange 一样.</p>
<h2 id="RabbitMQ应用场景"><a href="#RabbitMQ应用场景" class="headerlink" title="RabbitMQ应用场景"></a>RabbitMQ应用场景</h2><p>官网中有很详细的样例，各个语言都有，<a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">http://www.rabbitmq.com/getstarted.html</a> 此处不再说明。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>服务重启时, 是否能恢复队列中的数据.</p>
<p>考虑这样的场景, 当消息被暂存到队列后, 在没有被提取的情况下, RabbitMQ 服务停掉了怎么办.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'hello'</span>)</span><br><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>, routing_key=<span class="string">''</span>, body=<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码, 我们创建了一条内容为 Hello World! 的消息, 通过命令行工具:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span>  ./rabbitmqctl list_queues</span><br><span class="line">Listing queues ...</span><br><span class="line">hello    1</span><br><span class="line">...done.</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ./rabbitmqctl list_exchanges</span><br><span class="line">Listing exchanges ...</span><br><span class="line">    direct</span><br><span class="line">amq.direct    direct</span><br><span class="line">amq.fanout    fanout</span><br><span class="line">amq.headers    headers</span><br><span class="line">amq.match    headers</span><br><span class="line">amq.rabbitmq.log    topic</span><br><span class="line">amq.rabbitmq.trace    topic</span><br><span class="line">amq.topic    topic</span><br><span class="line">first    fanout</span><br><span class="line">...done.</span><br></pre></td></tr></table></figure>
<p>可以查到, 在名为 hello 的队列中, 有 1 条消息. 有一个类型为 fanout , 名为 first 的交换器.</p>
<p>此时通过 Ctrl-C 或 ./rabbitmqctl stop 把 RabbitMQ 服务停掉, 再重启. 交换器, 队列, 消息都是不会恢复的.</p>
<p>所以, 默认情况下, <strong>消息</strong>, <strong>队列</strong>, <strong>交换器</strong> 都不具有持久化的性质. 如果我们需要持久化功能, 那么在声明的时候就需要配置好.</p>
<p>交换器和队列的持久化性质, 在声明时通过一个 durable 参数即可实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'fanout'</span>, durable=<span class="literal">True</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>, durable=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这样, 在服务重启之后, first 和 hello 都会恢复. 但是 hello 中的消息不会, 还需要额外配置. 这是 <strong>消息</strong> 的属性的相关内容:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                      routing_key=<span class="string">''</span>,</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                         delivery_mode = <span class="number">2</span>,<span class="comment"># make message persistent</span></span><br><span class="line">                      ))</span><br></pre></td></tr></table></figure>
<p>这里注意一下, 消息的持久化并不是一个很强的约束, 涉及数据落地的时机, 及系统层面的 <strong>fsync</strong> 等问题, 不要认为消息完全不会丢. 如果要尽可能高地提高消息的持久化的有效性, 还需要配置其它的一些机制, 比如后面会谈到的 <strong>状态反馈</strong> 中的 <strong>confirm mode</strong>.</p>
<p><strong>交换器 , 队列, 消息</strong> 这三者的持久化问题都介绍过了. 前两者是一经声明, 则其性质无法再被更改, 即你不能先声明一个非持久化的队列, 再声明一个持久化的同名队列, 企图修改它, 这是不行的. 你重复声明时, 相关参数需要一致. 当然, 你可以删除它们再重新声明:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.queue_delete(queue=<span class="string">'hello'</span>)</span><br><span class="line">channel.exchange_delete(exchange=<span class="string">'first'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><p>交换器如何把消息给到哪些队列, 是每个队列给一条, 或者把一条消息给多个队列.</p>
<p>我们考虑交换器 Exchange 和队列 Queue 的关系. Exchange 在得到消息后会依据规则把消息投到一个或多个队列当中.</p>
<p>在调度策略方面, 有两个需要了解的地方, 一是交换器的类型(前面我们用的是 fanout), 二是交换器和队列的绑定关系. 在绑定了的前提下, 我们再谈不同类型的交换器的规则. 绑定动作本身也会影响交换器的行为.</p>
<p>交换器的类型, 内置的有四种, 分别是:</p>
<ul>
<li>fanout</li>
<li>direct</li>
<li>topic</li>
<li>headers</li>
</ul>
<p>下面一一介绍.</p>
<h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><p>故名思义, fanout 类型的交换器, 其行为是把消息转发给所有绑定的队列上, 就是一个”广播”行为.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(&apos;localhost&apos;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&apos;first&apos;, type=&apos;fanout&apos;)</span><br><span class="line">channel.queue_declare(queue=&apos;A&apos;)</span><br><span class="line">channel.queue_declare(queue=&apos;B&apos;)</span><br><span class="line">channel.queue_declare(queue=&apos;C&apos;)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=&apos;first&apos;, queue=&apos;A&apos;)</span><br><span class="line">channel.queue_bind(exchange=&apos;first&apos;, queue=&apos;B&apos;)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=&apos;first&apos;,</span><br><span class="line">                      routing_key=&apos;&apos;,</span><br><span class="line">                      body=&apos;Hello World!&apos;)</span><br></pre></td></tr></table></figure>
<p>运行 N 次, 通过 rabbitmqctl 可以看到 A 和 B 中就有 N 条消息, 而 C 中没有消息. 因为只有 A 和 B 是绑定到了 first 上的.</p>
<h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p>direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 routing_key , 消息的 routing_key 匹配时, 才会被交换器投送到绑定的队列中去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'direct'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'B'</span>)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'A'</span>, routing_key=<span class="string">'a'</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'B'</span>, routing_key=<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                      routing_key=<span class="string">'a'</span>,</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>A 和 B 虽然都绑定在了类型为 direct 的 first 上, 但是绑定时的 routing_key 不同.</p>
<p>当一个 routing_key 为 a 的消息出来时, 只会被 first 投送到 A 里.</p>
<h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><p>topic 和 direct 类似, 只是匹配上支持了”模式”, 在”点分”的 routing_key 形式中, 可以使用两个通配符:</p>
<ul>
<li>* 表示一个词.</li>
<li># 表示零个或多个词.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'topic'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'B'</span>)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'A'</span>, routing_key=<span class="string">'a.*.*'</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'B'</span>, routing_key=<span class="string">'a.#'</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                      routing_key=<span class="string">'a'</span>,</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                      routing_key=<span class="string">'a.b.c'</span>,</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>在发出的两条消息当中, a 只会被 a.# 匹配到. 而 a.b.c 会被两个都匹配到.</p>
<p>所以, 最终的结果会是 A 中有一条消息, B 中有两条消息.</p>
<h3 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h3><p>headers 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型.</p>
<p>在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'headers'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'B'</span>)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'A'</span>, arguments=&#123;<span class="string">'a'</span>: <span class="string">'1'</span>&#125;)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'B'</span>, arguments=&#123;<span class="string">'b'</span>: <span class="string">'2'</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'x-match'</span>: <span class="string">'all'</span>&#125;)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                      routing_key=<span class="string">''</span>,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                          headers = &#123;<span class="string">'a'</span>: <span class="string">'2'</span>&#125;,</span><br><span class="line">                      ),</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                      routing_key=<span class="string">''</span>,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                          headers = &#123;<span class="string">'a'</span>: <span class="string">'1'</span>, <span class="string">'b'</span>: <span class="string">'2'</span>&#125;,</span><br><span class="line">                      ),</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>绑定时, 通过 arguments 参数设定匹配规则, x-match 是一个特殊的规则, 表示需要全部匹配上, 还是只匹配一条:</p>
<ul>
<li>all , 全部匹配.</li>
<li>any , 只匹配一个.</li>
</ul>
<p>消息的 headers 属性会用于规则的匹配.</p>
<p>上面的代码中, 第一条消息不会匹配任何规则. 第二条消息, 匹配到 A , 但是不会匹配到 B (虽然有一条 b:2 ).</p>
<p>最终的结果是, A 中有一条消息, B 中没有消息.</p>
<h2 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h2><p>队列面对消费者时, 如何把消息吐出去, 来一个消费者就把消息全给它, 还是只给一条.</p>
<p>调度策略是影响 Exchange 是不是要把消息给 Queue , 而分配策略影响队列如何把消息给 Consuming .</p>
<p>考虑这样的场景: 队列中有多条消息, 每一个消费者取出消息后, 都要花 10 秒来处理它, 处理完一条消息之后才可能再取出一条继续处理. 刚开始只有一个消费者, 过了 2 秒后来了第二个消费者, 此时, 这两个消费者获取消息的行为是一个什么状态?</p>
<p>我们的需求可能是, 当一个消费者来时, 只给它一条消息, 等它再”请求”时, 再给. 或者也可能是, 当有消费者时, 就把目前有的消息全给它(因为不知道是否还有其它的消费者, 所以既然来了一个就让它尽量多处理一些消息).</p>
<p>先产生一些等待处理的消息:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                          routing_key=<span class="string">''</span>,</span><br><span class="line">                          body=str(i))</span><br></pre></td></tr></table></figure>
<p>然后是消费者的实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">print</span> body</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=<span class="string">'A'</span>, no_ack=<span class="literal">True</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<p>上面的代码, 是假设处理一条消息需要 10 秒的时间. 但是事实上, 你只要一执行代码, 马上再使用 rabbitmqctl 查看队列状态时, 会发现队列已经空了. 因为在关闭 ack 的情况下, Queue 的行为是, 一旦有消费者请求, 那么当前队列中的消息它都会一次性吐很多出去.</p>
<p>ack 机制在后面 状态反馈 会介绍到, 简单来说是一种确认消息被正确处理的机制.</p>
<p>如果我们想一次只吐一条消息, 当其它消费者连上来时, 还可以并行处理, 简单地把 ack 打开就可以了(默认就是打开的).</p>
<p>再考虑一下细节. 当有多个消费者连上时, 它是从队列一次取一条消息, 还是一次取多条消息(这样至少可以改善性能). 这可以通过配置 channel 的 qos 相关参数实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-importpika</span></span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line">channel.basic_qos(prefetch_count=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">defcallback(ch, method, properties, body):</span><br><span class="line">    importtime</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">print</span> body</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<p>通过配置 prefetch_count 参数, 来设置一次从队列中取多少条消息. 要看到效果, 至少需要启 2 个消费者.</p>
<p>之前是 10 个数字按顺序入了队列, channel 的配置是一次取 2 个, 那么启 2 个消费者的话, 过 10 秒, 在两个消费者的输出中分别能看到 0 , 2 . 这时把两个消费者都 Ctrl-C , 通过 rabbitmqctl 能看到 A 队列中还有 8 条消息.</p>
<h2 id="状态反馈"><a href="#状态反馈" class="headerlink" title="状态反馈"></a>状态反馈</h2><p>当消息从某一个队列中被提出后, 这个消息的生命周期就此结束, 还是说需要一个具体的信号以明确标识消息已被正确处理.</p>
<p>状态反馈 的功能目的是为了确认行为的结果. 比如, 当你向 Exchange 提交一个消息时, 这个消息是否提交成功, 是否送达到了队列中. 当你从队列中提取消息之后, RabbitMQ 的 Server 如何处理, 因为在提取消息之后, Consuming 可能判断消息有问题, 可能在处理的过程中出现了异常.</p>
<p>在一些关键的节点上, 要保证消息的正确处理, 安全处理, 是需要很多细节上的控制的. AMQP 协议本身也为此作了相关设计, 甚至是事务机制. 事实上在 AMQP 中要确保消息的业务可靠性只能使用事务, 不过在 RabbitMQ 中有一些相应的简便的扩展机制来达到同样目的.</p>
<h3 id="信息发布的确认"><a href="#信息发布的确认" class="headerlink" title="信息发布的确认"></a>信息发布的确认</h3><p>回看一下之前的一段代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">'first'</span>, routing_key=<span class="string">''</span>, body=<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码要做的事, 是把一条消息发给名为 first 的交换器. 这个过程中可能出现意外:</p>
<ul>
<li>exchange 的名字写错了.</li>
<li>exchange 得到消息后, 发现没有对应的 queue 可以投送.</li>
<li>投送到 queue 后当前没有消费者来提取它.</li>
</ul>
<p>上面的三种情况, 第一种, 会直接引发一个调用错误. 第三种, 通常不是问题, 反正消息会在 queue 中暂存. 但是第二种情况很多时候是需要避免的, 否则消息就丢失了, 更严重的是 Producing 对此浑然不知.</p>
<p>在这个地方, 我们就需要确认消息发出之后, 是否成功地被投送到 queue 中去了(或者知道它不能被投送到任何 queue 中去).</p>
<p>要确认这些状态信息, 首先需要把 channel 设置到 confirm mode , 也称之为 Publisher Acknowledgements 机制 (和消息的 ack 机制区分开). 它的目的就是为了确认 Producing 发出的信息的状态.</p>
<p>打开 confirm mode 的方法是:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.confirm_delivery()</span><br></pre></td></tr></table></figure>
<p>之后的 publish 行为就可以收到服务器的反馈. 比如在 basic_publish 函数中, 通过 mandatory=True 参数来确认发出的消息是否有 queue 接收, 并且所有 queue 都成功接收.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#channel.queue_bind(exchange='first', queue='A')</span></span><br><span class="line"></span><br><span class="line">channel.confirm_delivery()</span><br><span class="line"></span><br><span class="line">r = channel.basic_publish(exchange=<span class="string">'first'</span>,</span><br><span class="line">                          routing_key=<span class="string">''</span>,</span><br><span class="line">                          body=<span class="string">'Hello'</span>,</span><br><span class="line">                          mandatory=<span class="literal">True</span>,</span><br><span class="line">                         )</span><br><span class="line"><span class="keyword">print</span> r</span><br></pre></td></tr></table></figure>
<p>上面的代码中, 因为名为 first 的 Exchange 没有绑定任何的 queue , 在 mandatory 参数的作用下, basic_publish 会返回 False .</p>
<p>对于持久化性质, confirm mode 的确认结果是表示, 一条 persisting 的消息, 投送给一个 durable 的队列成功, 并且数据已经成功写到磁盘. 当然, 因为系统缓存的问题, 为确保数据成功落地, 得到确认信息有时可能需要长达几百毫秒的时间, 应用对此应该有所准备, 而不至于在性能上受此影响.</p>
<h3 id="消息提取的确认"><a href="#消息提取的确认" class="headerlink" title="消息提取的确认"></a>消息提取的确认</h3><p>在未关闭消息的 ack 机制的情况下, 当消息被 Consuming 从队列中提取后, 在未明确获取确认信息之前, 队列中的消息是不会被删除的. 这样, 流程上就变成, 当消息被提取之后, 队列中的这条消息处于”等待确认”的状态. 如果 Consuming 反馈”成功”给队列, 则消息可以安全地被删除了. 如果反馈”拒绝”给队列, 则消息可能还需要再次被其它 Consuming 提取.</p>
<p>看下面的例子, 我们先创建顺序的 10 个数字为内容的 10 条消息:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'first'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'first'</span>, queue=<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">'first'</span>, routing_key=<span class="string">''</span>, body=str(i))</span><br></pre></td></tr></table></figure>
<p>提取消息的逻辑:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">r = channel.basic_get(queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>) <span class="comment">#0</span></span><br><span class="line"><span class="keyword">print</span> r[<span class="number">-1</span>], r[<span class="number">0</span>].delivery_tag</span><br></pre></td></tr></table></figure>
<p>上面的代码会提取第一条消息, 但是并没有向 Queue 反馈此消息是否被正确处理, 所以这条消息在队列中仍然存在, 直到 Connection 被释放后, 被提取过但是未被确认的消息的状态被重置, 它就可以被重新提取.</p>
<p>要确认消息, 或者拒绝消息, 使用对应的 basic_ack 和 baskc_reject 方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">r = channel.basic_get(queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>) <span class="comment">#0</span></span><br><span class="line"><span class="keyword">print</span> r[<span class="number">-1</span>], r[<span class="number">0</span>].delivery_tag</span><br><span class="line"><span class="comment">#channel.basic_ack(delivery_tag=r[0].delivery_tag)</span></span><br><span class="line">channel.basic_reject(delivery_tag=r[<span class="number">0</span>].delivery_tag)</span><br></pre></td></tr></table></figure>
<p>AMQP 协议中, 只提供了 reject 方法, 它只能处理一条消息. 因为 Consuming 是可以一次性提取多条消息的, 所以 RabbitMQ 为此做了扩展, 提供了 basic_nack 方法, 它和 basic_reject 的唯一区别就是支持一次性拒绝多条消息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">r = channel.basic_get(queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>) <span class="comment">#0</span></span><br><span class="line">r = channel.basic_get(queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>) <span class="comment">#1</span></span><br><span class="line">r = channel.basic_get(queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>) <span class="comment">#2</span></span><br><span class="line">channel.basic_nack(delivery_tag=r[<span class="number">0</span>].delivery_tag, multiple=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>delivery_tag 是在 channel 中的一个消息计数, 每次消息提取行为都对应一个数字. nack 的 multiple 机制会自动把不大于指定 delivery_tag 的消息提取都 reject 掉.</p>
<p>在 reject 和 nack 中还有一个 requeue 参数, 表示被拒绝的消息是否可以被重新分配. 默认是 True . 如果消息被 reject 之后, 不希望再被其它的 Consuming 得到, 可以把 requeue 参数设置成 False :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">r = channel.basic_get(queue=<span class="string">'A'</span>, no_ack=<span class="literal">False</span>) <span class="comment">#0</span></span><br><span class="line">channel.basic_nack(delivery_tag=r[<span class="number">0</span>].delivery_tag, multiple=<span class="literal">False</span>, requeue=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>basic_consume 和 basic_get 都是从指定 queue 中提取消息, 前者是一个更高层的方法, 还支持 qos 等.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>spring事务管理</title>
    <url>/2016/11/23/spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="事务是什么"><a href="#事务是什么" class="headerlink" title="事务是什么"></a>事务是什么</h2><p>弄清spring事务管理机制，首先要弄清什么是事务。<br>人们创建了一个术语来表示事务：ACID。ACID代表四个特性，相信大家都很熟悉，但我也要贴出来。</p>
<blockquote>
<p>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
</blockquote>
<blockquote>
<p>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
</blockquote>
<blockquote>
<p>隔离性：数据库允许多个并发事务同时对齐数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
</blockquote>
<blockquote>
<p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
</blockquote>
<p>（以上内容来自维基百科）</p>
<p>但ACID还是太过抽象，事务到底是怎么创建出来的？下面通过具体的代码来描述下。</p>
<a id="more"></a>
<h2 id="如何开启事务"><a href="#如何开启事务" class="headerlink" title="如何开启事务"></a>如何开启事务</h2><p>mysql中默认是自动提交事务的，可以通过</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>关闭自动提交。</p>
<p>或者通过</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br></pre></td></tr></table></figure>
<p>显示指定开启一个事务。</p>
<p><strong><em>这是什么意思呢？</em></strong><br>不特殊指定，<strong>每条DML语句都是个事务</strong>；若指定了begin，则遇到commit或ddl语句事务结束。<br>现在就很清楚了，原来事务是这样产生的，原来这就是一个事务。<br>那多个事务如何协同工作？有的事务是查找，有的是删除，根据acid特性，事务间是有隔离性的，那到底要隔离到什么程度呢？并发的事务如何相互影响？<br>这就牵扯出了另外一个经典话题——</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><blockquote>
<p>可序列化(Serializable)<br>最高的隔离级别。在基于锁机制并发控制的DBMS实现可序列化，要求在选定对象上的读锁和写锁保持直到事务结束后才能释放。在SELECT 的查询中使用一个“WHERE”子句来描述一个范围时应该获得一个“范围锁(range-locks)”。这种机制可以避免“幻影读(phantom reads)”现象（详见下文）。当采用不基于锁的并发控制时不用获取锁。但当系统探测到几个并发事务有“写冲突”的时候，只有其中一个是允许提交的。这种机制的详细描述见“快照隔离”</p>
</blockquote>
<blockquote>
<p>可重复读(Repeatable reads)<br>在可重复读(REPEATABLE READS)隔离级别中，基于锁机制并发控制的DBMS需要对选定对象的读锁(read locks)和写锁(write locks)一直保持到事务结束，但不要求“范围锁(range-locks)”，因此可能会发生“幻读(phantom reads)”。</p>
</blockquote>
<blockquote>
<p>提交读(Read committed)<br>在提交读(READ COMMITTED)级别中，基于锁机制并发控制的DBMS需要对选定对象的写锁(write locks)一直保持到事务结束，但是读锁(read locks)在SELECT操作完成后马上释放（因此“不可重复读”现象可能会发生，见下面描述）。和前一种隔离级别一样，也不要求“范围锁(range-locks)”。</p>
</blockquote>
<blockquote>
<p>未提交读(Read uncommitted)<br>未提交读(READ UNCOMMITTED)是最低的隔离级别。允许脏读(dirty reads)，事务可以看到其他事务“尚未提交”的修改。</p>
</blockquote>
<blockquote>
<p>通过比低一级的隔离级别要求更多的限制，高一级的级别提供更强的隔离性。标准允许事务运行在更强的事务隔离级别上。(如在可重复读(REPEATABLE READS)隔离级别上执行提交读(READ COMMITTED)的事务是没有问题的)</p>
</blockquote>
<p>（以上内容来自维基百科.)</p>
<p>不同的隔离级别并发时产生的结果也不一样。mysql中默认的隔离级别是 可重复读，在这个隔离级别下，同一个事务内多次读得到的结果是一样的，即使有其他事务删除了数据，仍不影响读事务的结果。</p>
<p>下面我们就以可重复读为例，看看事务是否是可重复读的。</p>
<h3 id="验证可重复读"><a href="#验证可重复读" class="headerlink" title="验证可重复读"></a>验证可重复读</h3><h4 id="在表中预置两条数据"><a href="#在表中预置两条数据" class="headerlink" title="在表中预置两条数据"></a>在表中预置两条数据</h4><table>
<thead>
<tr>
<th>id</th>
<th>tenant_id</th>
<th>modify_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>2</td>
<td>2016-11-16 17:06:25</td>
</tr>
<tr>
<td>8</td>
<td>1</td>
<td>2016-11-16 17:06:25</td>
</tr>
</tbody>
</table>
<h4 id="开启查询事务-事务A"><a href="#开启查询事务-事务A" class="headerlink" title="开启查询事务(事务A)"></a>开启查询事务(事务A)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tenant;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>id</th>
<th>tenant_id</th>
<th>modify_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>2</td>
<td>2016-11-16 17:06:25</td>
</tr>
<tr>
<td>8</td>
<td>1</td>
<td>2016-11-16 17:06:25</td>
</tr>
</tbody>
</table>
<p>可以看到此时表中仍有两条数据。</p>
<h4 id="另启一个删除事务（事务B）"><a href="#另启一个删除事务（事务B）" class="headerlink" title="另启一个删除事务（事务B）"></a>另启一个删除事务（事务B）</h4><p>由于mysql每个dml语句都是自动提交的，这里我们直接写delete语句即可：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tenant <span class="keyword">where</span> tenant_id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tenant;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>id</th>
<th>tenant_id</th>
<th>modify_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>2</td>
<td>2016-11-16 17:06:25</td>
</tr>
</tbody>
</table>
<p>可以看到tenant_id为1的记录已经被删除，表中只剩下一条记录。</p>
<h4 id="回到事务A查看表中记录"><a href="#回到事务A查看表中记录" class="headerlink" title="回到事务A查看表中记录"></a>回到事务A查看表中记录</h4><p>还记得事务A第一次查询时有两条记录么？现在表中数据已经被删除了一条，按照“可重复读”的隔离级别，在事务A中再次执行select操作，看到的应该还是两条记录，执行下看看</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tenant;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>id</th>
<th>tenant_id</th>
<th>modify_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>2</td>
<td>2016-11-16 17:06:25</td>
</tr>
<tr>
<td>8</td>
<td>1</td>
<td>2016-11-16 17:06:25</td>
</tr>
</tbody>
</table>
<p>果然，和第一次的select结果相同。</p>
<p>看到没，就是这么神奇。事务B虽然已经把tenant_id为1的记录删除了，但事务A仍然可以看到那条记录，就好像事务A完全不知道有事务B，丝毫没受事务B的影响。</p>
<p>这是“可重复读”隔离级别下的结果，大家可以去验证下“读以提交”的结果。</p>
<h4 id="提交事务A再查"><a href="#提交事务A再查" class="headerlink" title="提交事务A再查"></a>提交事务A再查</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tenant_wechat_auth;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>id</th>
<th>tenant_id</th>
<th>modify_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>2</td>
<td>2016-11-16 17:06:25</td>
</tr>
</tbody>
</table>
<p>提交之后事务结束，然后再次查询时就看不到已经被删除的记录了。</p>
<p>如此下来，不禁要问，mysql是如何做到的？<br>这里就引出了另外一个经典方案——</p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>mysql给每个表隐含加了两列：创建版本号，结束版本号。<br>mysql每当新开启一个事务时，事务版本号会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来喝查询到的每行记录的版本号进行比较。</p>
<p>在“可重复读”隔离级别下的mcvv的具体操作：</p>
<blockquote>
<p>SELECT<br>InnoDB会根据以下两个条件检查每条记录：<br>a.InnoDB只查找版本遭遇当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。<br>b.行的删除版本要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。<br>INSERT<br>InnoDB为新插入的每一行保存当前系统版本号座位行版本号。<br>DELETE<br>InnoDB为删除的每一行保存当前系统版本号座位删除标识。<br>UPDATE<br>InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。</p>
</blockquote>
<p>（以上内容来自《高性能MYSQL》）</p>
<p>所以这就很好解释了我们的结果（结果自己分析下吧，看我写的分析过程的时间自己完全可以分析出来）。</p>
<h2 id="spring事务管理机制"><a href="#spring事务管理机制" class="headerlink" title="spring事务管理机制"></a>spring事务管理机制</h2><p>前面弄清了什么是事务，下面就可以谈一下spring是如何管理事务了。</p>
<h3 id="spring中事务属性"><a href="#spring中事务属性" class="headerlink" title="spring中事务属性"></a>spring中事务属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许你会奇怪，为什么接口只提供了获取属性的方法，而没有提供相关设置属性的方法。其实道理很简单，事务属性的设置完全是程序员控制的，因此程序员可以自定义任何设置属性的方法，而且保存属性的字段也没有任何要求。唯一的要求的是，Spring 进行事务操作的时候，通过调用以上接口提供的方法必须能够返回事务相关的属性取值。</p>
<h3 id="事务隔离级别-1"><a href="#事务隔离级别-1" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li>TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。</li>
<li>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li>
<li>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
<li>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<p>这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而 PROPAGATION_NESTED是 Spring 所特有的。以 PROPAGATION_NESTED 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</p>
<h3 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h3><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p>
<h3 id="事务的只读属性"><a href="#事务的只读属性" class="headerlink" title="事务的只读属性"></a>事务的只读属性</h3><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。在 TransactionDefinition 中以 boolean 类型来表示该事务是否只读。</p>
<h3 id="事务的回滚规则"><a href="#事务的回滚规则" class="headerlink" title="事务的回滚规则"></a>事务的回滚规则</h3><p>通常情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常），则默认将回滚事务。如果没有抛出任何异常，或者抛出了已检查异常，则仍然提交事务。这通常也是大多数开发者希望的处理方式，也是 EJB 中的默认处理方式。但是，我们可以根据需要人为控制事务在抛出某些未检查异常时任然提交事务，或者在抛出某些已检查异常时回滚事务。</p>
<h2 id="Spring-事务管理-API-分析"><a href="#Spring-事务管理-API-分析" class="headerlink" title="Spring 事务管理 API 分析"></a>Spring 事务管理 API 分析</h2><p>spring并不直接管理事务，而是提供了多种事务管理器，它们将事务管理职责委托给JTA或者其他其他持久化机制所提供的平台相关的事务实现。</p>
<p>Spring 框架中，涉及到事务管理的 API 大约有100个左右，其中最重要的有三个：TransactionDefinition、PlatformTransactionManager、TransactionStatus。所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。“给定的事务规则”就是用 TransactionDefinition 表示的，“按照……来执行提交或者回滚操作”便是用 PlatformTransactionManager 来表示，而 TransactionStatus 用于表示一个运行着的事务的状态。</p>
<h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><p>该接口在前面已经介绍过，它用于定义一个事务。它包含了事务的静态属性，比如：事务传播行为、超时时间等等。Spring 为我们提供了一个默认的实现类：DefaultTransactionDefinition，该类适用于大多数情况。如果该类不能满足需求，可以通过实现 TransactionDefinition 接口来实现自己的事务定义。</p>
<h3 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h3><p>PlatformTransactionManager 用于执行具体的事务操作。接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Public <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span></span>&#123;</span><br><span class="line">  <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span><span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span><span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据底层所使用的不同的持久化 API 或框架，PlatformTransactionManager 的主要实现类大致如下：</p>
<ul>
<li>DataSourceTransactionManager：适用于使用JDBC和iBatis进行数据持久化操作的情况。</li>
<li>HibernateTransactionManager：适用于使用Hibernate进行数据持久化操作的情况。</li>
<li>JpaTransactionManager：适用于使用JPA进行数据持久化操作的情况。</li>
<li>另外还有JtaTransactionManager 、JdoTransactionManager、JmsTransactionManager等等。</li>
</ul>
<p>如果我们使用JTA进行事务管理，我们可以通过 JNDI 和 Spring 的 JtaTransactionManager 来获取一个容器管理的 DataSource。JtaTransactionManager 不需要知道 DataSource 和其他特定的资源，因为它将使用容器提供的全局事务管理。而对于其他事务管理器，比如DataSourceTransactionManager，在定义时需要提供底层的数据源作为其属性，也就是 DataSource。与 HibernateTransactionManager 对应的是 SessionFactory，与 JpaTransactionManager 对应的是 EntityManagerFactory 等等。</p>
<p>各部分关系如下图：<br><img src="/img/Spring%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE.png" alt="Spring事务配置"></p>
<h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><p>PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。返回的TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。TransactionStatus 接口提供了一个简单的控制事务执行和查询事务状态的方法。该接口定义如清单3所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于注解的声明式事务实现"><a href="#基于注解的声明式事务实现" class="headerlink" title="基于注解的声明式事务实现"></a>基于注解的声明式事务实现</h3><p>目前这种方式是最流行的，上古的编程式事务并没有接触过，感兴趣可以上网搜下。</p>
<p>@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transfer</span><span class="params">(Long fromId， Long toId， <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bankDao.transfer(fromId， toId， amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 使用 BeanPostProcessor 来处理 Bean 中的标注，因此我们需要在配置文件中作如下声明来激活该后处理 Bean:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>与前面相似，transaction-manager 属性的默认值是 transactionManager，如果事务管理器 Bean 的名字即为该值，则可以省略该属性。</p>
<p>虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 小组建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>spring bean初始化过程</title>
    <url>/2016/11/06/spring-bean%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="实例化过程"><a href="#实例化过程" class="headerlink" title="实例化过程"></a>实例化过程</h2><p><img src="/img/spring%20bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="spring bean实例化过程"></p>
<a id="more"></a>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml:"></a>applicationContext.xml:</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:spring=<span class="string">"http://www.springframework.org/schema/tool"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tool http://www.springframework.org/schema/tool/spring-tool.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">    &lt;context:component-scan base-package="com.ytf.spring"&gt;&lt;/context:component-scan&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;bean id="beanPost" class="com.ytf.spring.InitBeanProcess.BeanPost"&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;bean name=<span class="string">"animal"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.ytf.spring.InitBeanProcess.Animal"</span> init-method=<span class="string">"animalInit"</span></span><br><span class="line">          destroy-method=<span class="string">"animalDestroy"</span>&gt;</span><br><span class="line">        &lt;property name="spiece" value="dog"&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name="sex" value="male"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Animal-java实现了各种接口"><a href="#Animal-java实现了各种接口" class="headerlink" title="Animal.java实现了各种接口"></a>Animal.java实现了各种接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.spring.InitBeanProcess;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String spiece;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSpiece</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spiece;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpiece</span><span class="params">(String spiece)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.spiece = spiece;</span><br><span class="line">        System.out.println(<span class="string">"Set Spiece:"</span> + <span class="keyword">this</span>.spiece);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        System.out.println(<span class="string">"Set Sex:"</span> + <span class="keyword">this</span>.sex);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal Instantiation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BeanFactoryAware.setBeanFactory"</span>);</span><br><span class="line">        beanFactory.getBean(Animal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BeanNameAware.setBeanName,beanId: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"InitializingBean.afterPropertiesSet"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ApplicationContextAware.setApplicationContext"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">animalInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal Init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">animalDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animal Destroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DisposableBean.destroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Spiece:"</span> + <span class="keyword">this</span>.spiece + <span class="string">";Sex:"</span> + <span class="keyword">this</span>.sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BeanPost-java实现BeanPostProcessor接口"><a href="#BeanPost-java实现BeanPostProcessor接口" class="headerlink" title="BeanPost.java实现BeanPostProcessor接口"></a>BeanPost.java实现BeanPostProcessor接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.spring.InitBeanProcess;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanPost</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object o, String s)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Animal) &#123;</span><br><span class="line">            Animal animal = (Animal) o;</span><br><span class="line">            System.out.println(<span class="string">"BeanPostProcessor.postProcessBeforeInitialization"</span>);</span><br><span class="line">            animal.setSpiece(<span class="string">"monkey"</span>);</span><br><span class="line">            <span class="keyword">return</span> animal;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object o, String s)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Animal) &#123;</span><br><span class="line">            Animal animal = (Animal) o;</span><br><span class="line">            System.out.println(<span class="string">"BeanPostProcessor.postProcessAfterInitialization"</span>);</span><br><span class="line">            animal.setSex(<span class="string">"female"</span>);</span><br><span class="line">            <span class="keyword">return</span> animal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ProveBeanInit-java-是测试类"><a href="#ProveBeanInit-java-是测试类" class="headerlink" title="ProveBeanInit.java 是测试类"></a>ProveBeanInit.java 是测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytf.spring.InitBeanProcess;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProveBeanInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext cpa = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application.xml"</span>);</span><br><span class="line">        Animal animal = (Animal)cpa.getBean(<span class="string">"animal"</span>);</span><br><span class="line">        System.out.println(animal);</span><br><span class="line">        cpa.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><blockquote>
<p>Animal Instantiation<br>Set Spiece:dog<br>Set Sex:male<br>BeanNameAware.setBeanName,beanId: animal<br>BeanFactoryAware.setBeanFactory<br>ApplicationContextAware.setApplicationContext<br>BeanPostProcessor.postProcessBeforeInitialization<br>Set Spiece:monkey<br>InitializingBean.afterPropertiesSet<br>Animal Init<br>BeanPostProcessor.postProcessAfterInitialization<br>Set Sex:female<br>Spiece:monkey;Sex:female<br>DisposableBean.destroy<br>Animal Destroy</p>
</blockquote>
<p>可见，初始化顺序确实如图说明。</p>
<h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><ol>
<li>如果去掉BeanPost,改为Animal实现BeanPostProcessor，会导致BeanPostProcessor的两个方法不运行。</li>
<li>网上有说使用注解@PostConstruct、@PreDestroy 代替 init-method,destroy-method，实际运行发现并不是一样的，换成注解，产生的结果如下：</li>
</ol>
<blockquote>
<p>Animal Instantiation<br>BeanNameAware.setBeanName,beanId: animal<br>BeanFactoryAware.setBeanFactory<br>ApplicationContextAware.setApplicationContext<br>BeanPostProcessor.postProcessBeforeInitialization<br>Set Spiece:monkey<br><strong><em>Animal Init<br>InitializingBean.afterPropertiesSet</em></strong><br>BeanPostProcessor.postProcessAfterInitialization<br>Set Sex:female<br>Spiece:monkey;Sex:female<br><strong><em>Animal Destroy</em></strong><br><strong><em>DisposableBean.destroy</em></strong></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springmvc 请求处理过程</title>
    <url>/2016/11/03/springmvc-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>一个请求到达服务器之后，springmvc处理过程：<br><img src="/img/springmvc%20%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="springmvc 请求处理过程"></p>
<a id="more"></a>
<ul>
<li>(1) <strong>Http请求</strong>：客户端请求提交到DispatcherServlet。 </li>
<li>(2) <strong>寻找处理器</strong>：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 </li>
<li>(3) <strong>调用处理器</strong>：DispatcherServlet将请求提交到Controller。 </li>
<li>(4)(5)<strong>调用业务处理和返回结果</strong>：Controller调用业务逻辑处理后，返回ModelAndView。 </li>
<li>(6)(7)<strong>处理视图映射并返回模型</strong>： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 </li>
<li>(8) <strong>Http响应</strong>：视图负责将结果显示到客户端。</li>
</ul>
<p>图中有些过程没有说清楚，比如怎么找到HandlerMapping以及业务逻辑代码怎么被调用？<br>这就需要看DispatcherServlet源码了。<br>先上一段关键代码，DispatcherServlet.doDispatcher() 方法,核心流程都在这个方法里。</p>
<h2 id="DispatcherServlet-doDispatch"><a href="#DispatcherServlet-doDispatch" class="headerlink" title="DispatcherServlet.doDispatch"></a>DispatcherServlet.doDispatch</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   HttpServletRequest processedRequest = request;</span><br><span class="line">   HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">   WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">      Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         processedRequest = checkMultipart(request);</span><br><span class="line">         multipartRequestParsed = (processedRequest != request);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">         mappedHandler = getHandler(processedRequest);</span><br><span class="line">         <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            noHandlerFound(processedRequest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">         HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">         String method = request.getMethod();</span><br><span class="line">         <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">         <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">            <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         applyDefaultViewName(processedRequest, mv);</span><br><span class="line">         mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         dispatchException = ex;</span><br><span class="line">      &#125;</span><br><span class="line">      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">      triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">         <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">         <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">         <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个出现的核心接口：getHandler()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mappedHandler = getHandler(processedRequest);</span><br></pre></td></tr></table></figure>
<p>它是在org.springframework.web.servlet包中定义的HandlerMapping接口：</p>
<h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + ".pathWithinHandlerMapping";</span><br><span class="line"> </span><br><span class="line">    String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + ".bestMatchingPattern";</span><br><span class="line"> </span><br><span class="line">    String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + ".introspectTypeLevelMapping";</span><br><span class="line"> </span><br><span class="line">    String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + ".uriTemplateVariables";</span><br><span class="line"> </span><br><span class="line">    String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + ".producibleMediaTypes";</span><br><span class="line"> </span><br><span class="line">    <span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了阅读方便，去掉了源码中的注释，类中定义的几个常量先不管。关键在于这个接口中唯一的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>
<p>回到DispatcherServlet的处理流程，当DispatcherServlet接收到web请求后，由标准Servlet类处理方法doGet或者doPost，经过几次转发后，遍历DispatcherServlet中所有<br>HandlerMapping实现类（容器启动时会将实现类注入进来，看源码！）。<br>web请求的HttpServletRequest对象为参数，依次调用HandlerMapping实现类的getHandler方法，第一个不为null的作为结果返回。<br>DispatcherServlet类中的这个遍历方法不长，贴一下:</p>
<h3 id="getHandler"><a href="#getHandler" class="headerlink" title="getHandler()"></a>getHandler()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * Return the HandlerExecutionChain for this request. * &lt;p&gt;Tries all handler mappings in order. * <span class="doctag">@param</span> request current HTTP request * <span class="doctag">@return</span> the HandlerExecutionChain, or &lt;code&gt;null&lt;/code&gt; if no handler could be found */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(</span><br><span class="line">                        <span class="string">"Testing handler map ["</span> + hm + <span class="string">"] in DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，一个web请求经过处理后，会得到一个HandlerExecutionChain对象，这就是SpringMVC对URl映射给出的回答。<br>需要留意的是，HandlerMapping接口的getHandler方法参数是HttpServletRequest，这意味着，HandlerMapping的实现类可以利用HttpServletRequest中的 所有信息来做出这个HandlerExecutionChain对象的生成”决策“。这包括，请求头、url路径、cookie、session、参数等等一切你从一个web请求中可以得到的任何东西（最常用的是url路径）。<br>getHandler()的具体实现有兴趣饿的可以跟进去看下。</p>
<p>HandlerExecutionChain是我们接触的第二个核心类，从名字可以直观的看得出，这个对象是一个执行链的封装。<br>HandlerExecutionChain类的代码不长，它定义在org.springframework.web.servlet包中， 为了更直观的理解，先上代码:</p>
<h3 id="HandlerExecutionChain"><a href="#HandlerExecutionChain" class="headerlink" title="HandlerExecutionChain"></a>HandlerExecutionChain</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerExecutionChain</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(handler, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerExecutionChain</span><span class="params">(Object handler, HandlerInterceptor[] interceptors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerExecutionChain) &#123;</span><br><span class="line">            HandlerExecutionChain originalChain = (HandlerExecutionChain) handler;</span><br><span class="line">            <span class="keyword">this</span>.handler = originalChain.getHandler();</span><br><span class="line">            <span class="keyword">this</span>.interceptorList = <span class="keyword">new</span> ArrayList&lt;HandlerInterceptor&gt;();</span><br><span class="line">            CollectionUtils.mergeArrayIntoCollection(originalChain.getInterceptors(), <span class="keyword">this</span>.interceptorList);</span><br><span class="line">            CollectionUtils.mergeArrayIntoCollection(interceptors, <span class="keyword">this</span>.interceptorList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.handler = handler;</span><br><span class="line">            <span class="keyword">this</span>.interceptors = interceptors;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handler;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(HandlerInterceptor interceptor)</span> </span>&#123;</span><br><span class="line">        initInterceptorList();</span><br><span class="line">        <span class="keyword">this</span>.interceptorList.add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(HandlerInterceptor[] interceptors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            initInterceptorList();</span><br><span class="line">            <span class="keyword">this</span>.interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initInterceptorList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.interceptorList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.interceptorList = <span class="keyword">new</span> ArrayList&lt;HandlerInterceptor&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.interceptorList.addAll(Arrays.asList(<span class="keyword">this</span>.interceptors));</span><br><span class="line">            <span class="keyword">this</span>.interceptors = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> HandlerInterceptor[] getInterceptors() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.interceptorList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.interceptors = <span class="keyword">this</span>.interceptorList.toArray(<span class="keyword">new</span> HandlerInterceptor[<span class="keyword">this</span>.interceptorList.size()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.interceptors;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"HandlerExecutionChain with no handler"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"HandlerExecutionChain with handler ["</span>).append(<span class="keyword">this</span>.handler).append(<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.interceptorList)) &#123;</span><br><span class="line">            sb.append(<span class="string">" and "</span>).append(<span class="keyword">this</span>.interceptorList.size()).append(<span class="string">" interceptor"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.interceptorList.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">"s"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>关注两行即可知道这个类的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br></pre></td></tr></table></figure>
<p>一个实质执行对象，还有一堆拦截器。<br>HandlerInterceptor也是SpringMVC的核心接口，定义如下：</p>
<h3 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拦截器就是我们定义的interceptor，关于拦截器的讲解在 <a href="https://mastertf.github.io/2016/10/09/spring-%E6%8B%A6%E6%88%AA%E5%99%A8/" target="_blank" rel="noopener">spring拦截器</a><br>至此，HandlerExecutionChain整个执行脉络也就清楚了：在真正调用其handler对象前，HandlerInterceptor接口实现类组成的数组将会被遍历，其preHandle方法会被依次调用，然后真正的handler对象将被调用。<br>handler对象被调用后，就生成了需要的响应数据，在将处理结果写到HttpServletResponse对象之前（SpringMVC称为渲染视图），其postHandle方法会被依次调用。视图渲染完成后，最后afterCompletion方法会被依次调用，整个web请求的处理过程就结束了。</p>
<p>这个HandlerExecutionChain类中以Object引用所声明的handler对象，到底是什么？它是怎么被调用的？<br>继续看DispatcherServlet.doDispatch()方法24行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<h3 id="getHandlerAdapter-："><a href="#getHandlerAdapter-：" class="headerlink" title="getHandlerAdapter()："></a>getHandlerAdapter()：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the HandlerAdapter for this handler object.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler object to find an adapter for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException if no HandlerAdapter can be found for the handler. This is a fatal error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Testing handler adapter ["</span> + ha + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ha.supports(handler)) &#123;</span><br><span class="line">         <span class="keyword">return</span> ha;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +</span><br><span class="line">         <span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码已经很明显了，HandlerExecutionChain中的handler对象会被作为参数传递进去，在DispatcherServlet类中注册的HandlerAdapter实现类列表会被遍历，然后返回第一个supports方法返回true的HandlerAdapter对象。<br>获得到HandlerAdapter对象后，调用handle方法处理handler对象，并返回ModelAndView这个包含了视图和数据的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<p>ModelAndView对象的代码就不贴了，它是SpringMVC中对视图和数据的一个聚合类。其中的视图，就是由SpringMVC的最后一个核心接口View所抽象：</p>
<h3 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    String RESPONSE_STATUS_ATTRIBUTE = View.class.getName() + ".responseStatus";</span><br><span class="line"> </span><br><span class="line">    String PATH_VARIABLES = View.class.getName() + ".pathVariables";</span><br><span class="line"> </span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的数据，最后会作为一个Map对象传递到View实现类中的render方法，调用这个render方法，就完成了视图到响应的渲染。这个View实现类，就是来自HandlerAdapter中的handle方法的返回结果。当然从ModelAndView到真正的View实现类有一个解析的过程，ModelAndView中可以有真正的视图对象，也可以只是有一个视图的名字，SpringMVC会负责将视图名称解析为真正的视图对象。</p>
<p>至此，我们了解了一个典型的完整的web请求在SpringMVC中的处理过程和其中涉及到的核心类和接口。</p>
<p>在一个典型的SpringMVC调用中，HandlerExecutionChain中封装handler对象就是用@Controller注解标识的类的一个实例，根据类级别和方法级别的@RequestMapping注解，由默认注册的DefaultAnnotationHandlerMapping（3.1.3中更新为RequestMappingHandlerMapping类，但是为了向后兼容，DefaultAnnotationHandlerMapping也可以使用）生成HandlerExecutionChain对象，再由AnnotationMethodHandlerAdapter（3.1.3中更新为RequestMappingHandlerAdapter类，但是为了向后兼容，AnnotationMethodHandlerAdapter也可以使用）来执行这个HandlerExecutionChain对象，生成最终的ModelAndView对象后，再由具体的View对象的render方法渲染视图。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring 拦截器</title>
    <url>/2016/10/09/spring-%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h2 id="处理器拦截器简介"><a href="#处理器拦截器简介" class="headerlink" title="处理器拦截器简介"></a>处理器拦截器简介</h2><p>Spring Web MVC的处理器拦截器（如无特殊说明，下文所说的拦截器即处理器拦截器）<br>类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。</p>
<h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h2><ol>
<li>日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等。</li>
<li>权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面；</li>
<li>性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）；</li>
<li>通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。</li>
<li>OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。</li>
</ol>
<p>…………本质也是AOP（面向切面编程），也就是说符合横切关注点的所有功能都可以放入拦截器实现。</p>
<a id="more"></a>
<h2 id="拦截器接口"><a href="#拦截器接口" class="headerlink" title="拦截器接口"></a>拦截器接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3, ModelAndView var4)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>preHandle：</li>
</ol>
<ul>
<li>预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器（如Controller实现）；</li>
<li>返回值：true表示继续流程（如调用下一个拦截器或处理器）；false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应。</li>
</ul>
<ol start="2">
<li>postHandle：后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</li>
<li>afterCompletion：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。</li>
</ol>
<h2 id="拦截器适配器"><a href="#拦截器适配器" class="headerlink" title="拦截器适配器"></a>拦截器适配器</h2><p>有时候我们可能只需要实现三个回调方法中的某一个，如果实现HandlerInterceptor接口的话，三个方法必须实现，不管你需不需要，此时spring提供了一个HandlerInterceptorAdapter适配器（一种适配器设计模式的实现），允许我们只实现需要的回调方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerInterceptorAdapter</span> <span class="keyword">implements</span> <span class="title">AsyncHandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerInterceptorAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConcurrentHandlingStarted</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行流程图"><a href="#运行流程图" class="headerlink" title="运行流程图"></a>运行流程图</h2><h3 id="正常流程"><a href="#正常流程" class="headerlink" title="正常流程"></a>正常流程</h3><p><img src="/img/%E6%AD%A3%E5%B8%B8%E6%B5%81%E7%A8%8B.png" alt="正常流程"></p>
<h3 id="中断流程"><a href="#中断流程" class="headerlink" title="中断流程"></a>中断流程</h3><p><img src="/img/%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B.png" alt="中断流程"></p>
<p>中断流程中，比如是HandlerInterceptor4中断的流程（preHandle返回false），此处仅调用它之前拦截器的preHandle返回true的afterCompletion方法。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://jinnianshilongnian.iteye.com/blog/1670856" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1670856</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>详解CMS垃圾回收机制</title>
    <url>/2016/04/23/%E8%AF%A6%E8%A7%A3CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="什么是CMS？"><a href="#什么是CMS？" class="headerlink" title="什么是CMS？"></a>什么是CMS？</h2><p>Concurrent Mark Sweep。<br>看名字就知道，CMS是一款并发、使用标记-清除算法的gc。<br>CMS是针对老年代进行回收的GC。</p>
<a id="more"></a>
<h2 id="CMS有什么用？"><a href="#CMS有什么用？" class="headerlink" title="CMS有什么用？"></a>CMS有什么用？</h2><p>CMS以获取最小停顿时间为目的。<br>在一些对响应时间有很高要求的应用或网站中，用户程序不能有长时间的停顿，CMS 可以用于此场景。</p>
<h2 id="CMS如何执行？"><a href="#CMS如何执行？" class="headerlink" title="CMS如何执行？"></a>CMS如何执行？</h2><p>总体来说CMS的执行过程可以分为以下几个阶段：  </p>
<h3 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h3><p>初始标记阶段需要STW(Stop The World)。<br>该阶段进行可达性分析，标记GC ROOT能直接关联到的对象。<br>注意是<strong>直接关联</strong>,间接关联的对象在下一阶段标记。</p>
<h3 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h3><p>此阶段是和用户线程并发执行的过程。<br>该阶段进行GC ROOT TRACING，在第一个阶段被暂停的线程重新开始运行。<br>由前阶段标记过的对象出发，所有可到达的对象都在本阶段中标记。</p>
<h3 id="并发预清理"><a href="#并发预清理" class="headerlink" title="并发预清理"></a>并发预清理</h3><p>并发预处理阶段做的工作还是标记，与3.4的重标记功能相似。<br>既然相似为什么要有这一步？<br>前面我们讲过，CMS是以获取最短停顿时间为目的的GC。<br>重标记需要STW，因此重标记的工作尽可能多的在并发阶段完成来减少STW的时间。<br>此阶段标记<strong>从新生代晋升的对象、新分配到老年代的对象</strong>以及在<strong>并发阶段被修改了的对象</strong>。</p>
<hr>
<p>此阶段比较复杂，从大家容易忽略或者说不理解的地方抛出一个问题大家思考下：<br>  ● <strong>如何确定老年代的对象是活着的？</strong><br>答案很简单，通过GC ROOT TRACING可到达的对象就是活着的。<br>继续延伸，如果存在以下场景怎么办：<br><img src="/2016/04/23/详解CMS垃圾回收机制/new_reference_old.png" title="new reference old">   </p>
<p>老年代进行GC时如何确保上图中Current Obj标记为活着的？<br>（确认新生代的对象是活着的也存在相同问题，大家可以思考下，文章后面会给出答案）<br> 答案是必须扫描新生代来确保。<strong>这也是为什么CMS虽然是老年代的gc，但仍要扫描新生代的原因</strong>。(注意初始标记也会扫描新生代)<br>在CMS日志中我们可以清楚地看到扫描日志：</p>
<blockquote>
<p>[GC[YG occupancy: 820 K (6528 K)]<br>[Rescan (parallel) , 0.0024157 secs]<br>[weak refs processing, 0.0000143 secs]<br>[scrub string table, 0.0000258 secs]<br>[1 CMS-remark: 479379K(515960K)] 480200K(522488K), 0.0025249 secs]<br>[Times: user=0.01 sys=0.00, real=0.00 secs]<br>Rescan阶段(remark阶段的一个子阶段)会扫描新生代和老年代中的对象。在日志中可以看到此阶段标识为Rescan (parallel)，说明此阶段是并行进行的。</p>
</blockquote>
<p><strong>重点来了：全量的扫描新生代和老年代会不会很慢？</strong>肯定会。<br>CMS号称是停顿时间最短的GC，如此长的停顿时间肯定是不能接受的。<br>如何解决呢？<br>大家可以先思考下。</p>
<p><strong>必须要有一个能够快速识别新生代和老年代活着的对象的机制。</strong><br><strong>先说新生代。</strong><br>新生代垃圾回收完剩下的对象全是活着的，并且活着的对象很少。<br><strong>如果在扫描新生代前进行一次Minor GC，情况是不是就变得好很多？</strong><br>CMS 有两个参数：<strong>CMSScheduleRemarkEdenSizeThreshold</strong>、<strong>CMSScheduleRemarkEdenPenetration</strong>，默认值分别是2M、50%。两个参数组合起来的意思是预清理后，eden空间使用超过2M时启动可中断的并发预清理（CMS-concurrent-abortable-preclean），直到eden空间使用率达到50%时中断，进入remark阶段。<br>如果能在可中止的预清理阶段发生一次Minor GC,那就万事大吉、天下太平了。<br>这里有一个小问题,<strong>可终止的预清理要执行多长时间来保证发生一次Minor GC?</strong><br>答案是没法保证。道理很简单，因为垃圾回收是JVM自动调度的,什么时候进行GC我们控制不了。<br>但此阶段总有一个执行时间吧？是的。<br>CMS提供了一个参数<strong>CMSMaxAbortablePrecleanTime</strong> ，默认为5S。<br>只要到了5S，不管发没发生Minor GC，有没有到CMSScheduleRemardEdenPenetration都会中止此阶段，进入remark。<br>如果在5S内还是没有执行Minor GC怎么办？<br>CMS提供CMSScavengeBeforeRemark参数，使remark前强制进行一次Minor GC。<br>这样做利弊都有。好的一面是减少了remark阶段的停顿时间;坏的一面是Minor GC后紧跟着一个remark pause。如此一来，停顿时间也比较久。<br>CMS日志如下：</p>
<blockquote>
<p>7688.150: [CMS-concurrent-preclean-start]<br>7688.186: [CMS-concurrent-preclean: 0.034/0.035 secs]<br>7688.186: [CMS-concurrent-abortable-preclean-start]<br>7688.465: [GC 7688.465: [ParNew: 1040940K-&gt;1464K(1044544K), 0.0165840 secs] 1343593K-&gt;304365K(2093120K),<br>0.0167509 secs]7690.093: [CMS-concurrent-abortable-preclean: 1.012/1.907 secs]  7690.095: [GC[YG occupancy: 522484 K (1044544 K)]<br>7690.095: [Rescan (parallel) , 0.3665541 secs]7690.462: [weak refs processing, 0.0003850 secs] [1 CMS-remark: 302901K(1048576K)] 825385K(2093120K), 0.3670690 secs]</p>
</blockquote>
<p><strong>7688.186启动了可终止的预清理，在随后的三秒内启动了Minor GC，然后进入了Remark阶段.</strong><br>实际上为了减少remark阶段的STW时间，预清理阶段会尽可能多做一些事情来减少remark停顿时间。<br>remark的rescan阶段是多线程的，为了便于多线程扫描新生代，<strong>预清理阶段会将新生代分块</strong>。<br>每个块中存放着多个对象，这样remark阶段就不需要从头开始识别每个对象的起始位置。<br>多个线程的职责就很明确了，把分块分配给多个线程，很快就扫描完。<br>遗憾的是，这种办法仍然是建立在发生了Minor GC的条件下。<br>如果没有发生Minor GC，top（下一个可以分配的地址空间）以下的所有空间被认为是一个块(这个块包含了新生代大部分内容)。<br>这种块对于remark阶段并不会起到多少作用，因此并行效率也会降低。</p>
<hr>
<p><strong>ok，新生代的机制讲完了，下面讲讲老年代</strong>。<br>老年代的机制与一个叫<strong>CARD TABLE</strong>的东西（这个东西其实就是个数组,数组中每个位置存的是一个byte）密不可分。<br>CMS将老年代的空间分成大小为512bytes的块，card table中的每个元素对应着一个块。<br>并发标记时，如果某个对象的引用发生了变化，就标记该对象所在的块为<strong> dirty card</strong>。<br>并发预清理阶段就会重新扫描该块，将该对象引用的对象标识为可达。<br>举个例子：<br>并发标记时对象的状态：<br><img src="/2016/04/23/详解CMS垃圾回收机制/concurrent_mark.png" title="concurrent mark"></p>
<p><strong>但随后current obj的引用发生了变化：</strong><br><img src="/2016/04/23/详解CMS垃圾回收机制/referrence_changed.png" title="referrence changed"> </p>
<p>current obj所在的块被标记为了dirty card。<br>随后到了pre-cleaning阶段，还记得该阶段的任务之一就是标记这些在并发标记阶段被修改了的对象么？之后那些通过current obj变得可达的对象也被标记了，变成下面这样：<br><img src="/2016/04/23/详解CMS垃圾回收机制/dirty_card.png" title="dirty card"></p>
<p>同时dirty card标志也被清除。<br>老年代的机制就是这样。<br><strong>不过card table还有其他作用</strong>。<br>还记得前面提到的那个问题么？进行Minor GC时,如果有老年代引用新生代，怎么识别？<br>(有研究表明，在所有的引用中，老年代引用新生代这种场景不足1%.原因大家可以自己分析下)<br>当有老年代引用新生代，对应的card table被标识为相应的值（card table中是一个byte，有八位，约定好每一位的含义就可区分哪个是引用新生代，哪个是并发标记阶段修改过的）。<br><strong>所以，Minor GC通过扫描card table就可以很快的识别老年代引用新生代</strong>。<br>这里提一下，hotspot 虚拟机使用字节码解释器、JIT编译器、 write barrier维护 card table。<br>当字节码解释器或者JIT编译器更新了引用，就会触发write barrier操作card table.<br>再提一下，由于card table的存在，当老年代空间很大时会发生什么？（这里大家可以自由发挥想象）<br>至此，预清理阶段的工作讲完。</p>
<h3 id="重标记-STW"><a href="#重标记-STW" class="headerlink" title="重标记(STW)"></a>重标记(STW)</h3><p>暂停所有用户线程，重新扫描堆中的对象，进行可达性分析,标记活着的对象。<br>有了前面的基础，这个阶段的工作量被大大减轻，停顿时间因此也会减少。<br>注意这个阶段是多线程的。</p>
<h3 id="并发清理。"><a href="#并发清理。" class="headerlink" title="并发清理。"></a>并发清理。</h3><p>用户线程被重新激活，同时清理那些无效的对象。</p>
<h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><p>CMS清除内部状态，为下次回收做准备。 </p>
<hr>
<p>CMS执行过程讲完了，重点讲解了并发预清理时的操作及CMS几个关键参数。你们可以消化一下，消化完了可以休息一下，因为事情还没结束。</p>
<h2 id="CMS有什么问题"><a href="#CMS有什么问题" class="headerlink" title="CMS有什么问题"></a>CMS有什么问题</h2><p>every coin has two sides ——高中英语作文我经常用的一句话。<br>在我看来，<strong>CMS这三个字母就隐含了问题所在。并发+标记-清除算法 是问题的来源。</strong> </p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="抢占CPU"><a href="#抢占CPU" class="headerlink" title="抢占CPU"></a>抢占CPU</h4><p>并发意味着多线程抢占CPU资源，即GC线程与用户线程抢占CPU。这可能会造成用户线程执行效率下降。<br>CMS默认的回收线程数是<strong>(CPU个数+3)/4</strong>。这个公式的意思是当CPU大于4个时,保证回收线程占用至少25%的CPU资源，这样用户线程占用75%的CPU，这是可以接受的。<br>但是，如果CPU资源很少，比如只有两个的时候怎么办？按照上面的公式，CMS会启动1个GC线程。相当于GC线程占用了50%的CPU资源，这就可能导致用户程序的执行速度忽然降低了50%，50%已经是很明显的降低了。<br>这种场景怎么处理呢？<br>我给的答案是可以不用考虑这种场景。现在的PC机中都至少有双核处理器，更别说大型的服务器了。<br>CMS的解决方案是提供了一个 incremental mode（增量模式）。<br>在这种模式下，进行并发标记、清理时让GC线程、用户线程交替运行，尽量减少GC线程独占CPU资源的时间。<br>这会造成GC时间更长，但对用户线程造成的影响就会少一些。<br>但实践证明，这种模式下CMS的表现很一般，并没有什么大的优化。<br>i-CMS已经被声明为“deprecated”，不再提倡使用。<br>(<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector</a>)</p>
<h4 id="浮动垃圾"><a href="#浮动垃圾" class="headerlink" title="浮动垃圾"></a>浮动垃圾</h4><p>并发清理阶段用户线程还在运行，这段时间就可能产生新的垃圾，新的垃圾在此次GC无法清除，只能等到下次清理。这些垃圾有个专业名词：浮动垃圾。<br>由于垃圾回收阶段用户线程仍在执行，必需预留出内存空间给用户线程使用。因此不能像其他回收器那样，等到老年代满了再进行GC。<br>CMS 提供了CMSInitiatingOccupancyFraction参数来设置老年代空间使用百分比,达到百分比就进行垃圾回收。<br>这个参数默认是92%，参数选择需要看具体的应用场景。<br>设置的太小会导致频繁的CMS GC，产生大量的停顿；反过来想，设置的太高会发生什么？<br>假设现在设置为99%，还剩1%的空间可以使用。<br>在并发清理阶段，若用户线程需要使用的空间大于1%，就会产生Concurrent  Mode Failure错误，意思就是说并发模式失败。<br>这时，虚拟机就会启动备案：使用Serial Old收集器重新对老年代进行垃圾回收.如此一来，停顿时间变得更长。<br>所以CMSInitiatingOccupancyFraction的设置要具体问题具体分析。<br>网上有一些设置此参数的公式，个人认为不是很严谨(原因就是CMS另外一个问题导致的),因此不写出来以免大家疑惑。</p>
<p>其实CMS有动态检查机制。<br>CMS会根据历史记录，预测老年代还需要多久填满及进行一次回收所需要的时间。<br>在老年代空间用完之前，CMS可以根据自己的预测自动执行垃圾回收。<br>这个特性可以使用参数UseCMSInitiatingOccupancyOnly来关闭。</p>
<p>这里提个问题，如果让你设计，<strong>如何预测什么时候开始自动执行</strong>？</p>
<h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>4.3 前两个问题是由并发引起的，接下来要说的问题就是由标记-清除算法引起的。<br>使用标记-清除算法可能造成大量的空间碎片。空间碎片过多，就会给大对象分配带来麻烦。<br>往往老年代还有很大剩余空间，但无法找到足够大的连续空间来分配当前对象,不得不触发一次Full GC。<br>CMS的解决方案是使用UseCMSCompactAtFullCollection参数(默认开启)，在顶不住要进行Full GC时开启内存碎片整理。<br>这个过程需要STW，碎片问题解决了,但停顿时间又变长了。<br>虚拟机还提供了另外一个参数CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认为0，每次进入Full GC时都进行碎片整理）。<br>延伸一个“foreground collector”的东西给大家，这个玩意在Java8中也声明为deprecated。(<a href="https://bugs.openjdk.java.net/browse/JDK-8027132" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-8027132</a>)<br>CMS存在的问题已经讲清楚，大家消化下。</p>
<hr>
<p>至此，CMS相关内容已经讲完。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>CMS采用了多种方式尽可能降低GC的暂停时间,减少用户程序停顿</strong>。<br><strong>停顿时间降低的同时牺牲了CPU吞吐量</strong> 。<br><strong>这是在停顿时间和性能间做出的取舍，可以简单理解为”空间(性能)”换时间</strong>。</p>
<p>文中提到的几个问题大家可以把自己当成设计者来思考。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector</a><br><a href="https://blogs.oracle.com/jonthecollector/entry/did_you_know" target="_blank" rel="noopener">https://blogs.oracle.com/jonthecollector/entry/did_you_know</a><br><a href="http://dept.cs.williams.edu/~freund/cs434/hotspot-gc.pdf" target="_blank" rel="noopener">http://dept.cs.williams.edu/~freund/cs434/hotspot-gc.pdf</a><br><a href="https://plumbr.eu/handbook/garbage-collection-algorithms-implementations" target="_blank" rel="noopener">https://plumbr.eu/handbook/garbage-collection-algorithms-implementations</a><br><a href="https://blogs.msdn.microsoft.com/abhinaba/2009/03/02/back-to-basics-generational-garbage-collection/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/abhinaba/2009/03/02/back-to-basics-generational-garbage-collection/</a><br><a href="https://bugs.openjdk.java.net/browse/JDK-8027132" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-8027132</a><br>《深入理解Java虚拟机 JVM高级特性与最佳实践》</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>CMS</tag>
      </tags>
  </entry>
</search>
